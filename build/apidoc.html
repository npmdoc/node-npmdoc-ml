<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/mljs/ml"

    >ml (v2.0.0)</a>
</h1>
<h4>Machine learning tools</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.ml">module ml</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.HashTable">
            function <span class="apidocSignatureSpan">ml.</span>HashTable
            <span class="apidocSignatureSpan">(options = {})</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix">
            function <span class="apidocSignatureSpan">ml.</span>Math.SparseMatrix
            <span class="apidocSignatureSpan">(rows, columns, options = {})</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Matrix">
            function <span class="apidocSignatureSpan">ml.</span>Matrix
            <span class="apidocSignatureSpan">(Array)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.PadArray">
            function <span class="apidocSignatureSpan">ml.</span>PadArray
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.SL.KNN">
            function <span class="apidocSignatureSpan">ml.</span>SL.KNN
            <span class="apidocSignatureSpan">(reload, model)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.SL.NaiveBayes">
            function <span class="apidocSignatureSpan">ml.</span>SL.NaiveBayes
            <span class="apidocSignatureSpan">(reload, model)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.SL.PLS">
            function <span class="apidocSignatureSpan">ml.</span>SL.PLS
            <span class="apidocSignatureSpan">(X, Y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.SL.SVM">
            function <span class="apidocSignatureSpan">ml.</span>SL.SVM
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.binarySearch">
            function <span class="apidocSignatureSpan">ml.</span>binarySearch
            <span class="apidocSignatureSpan">(haystack, needle, comparator, low, high)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.nn.SOM">
            function <span class="apidocSignatureSpan">ml.</span>nn.SOM
            <span class="apidocSignatureSpan">(x, y, options, reload)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ml.</span>AU</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ml.</span>ArrayUtils</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ml.</span>BitArray</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ml.</span>Clust</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ml.</span>Clust.hclust</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ml.</span>Math</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ml.</span>Math.BellOptimizer</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ml.</span>Math.CurveFitting</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ml.</span>Math.Distance</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ml.</span>Math.Similarity</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ml.</span>Math.SparseMatrix.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ml.</span>Matrix.DC</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ml.</span>Matrix.DC.CholeskyDecomposition.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ml.</span>Matrix.DC.LuDecomposition.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ml.</span>Matrix.DC.QrDecomposition.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ml.</span>Matrix.DC.SingularValueDecomposition.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ml.</span>Matrix.algebra</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ml.</span>Matrix.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ml.</span>NN</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ml.</span>RNG</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ml.</span>Regression</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ml.</span>Regression.NLR</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ml.</span>SL</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ml.</span>SL.CV</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ml.</span>SL.KNN.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ml.</span>SL.NaiveBayes.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ml.</span>SL.PLS.OPLS.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ml.</span>SL.SVM.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ml.</span>Stat</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ml.</span>Stat.array</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ml.</span>Stat.matrix</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ml.</span>nn</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ml.</span>nn.SOM.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ml.</span>numSort</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ml.AU">module ml.AU</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.AU.SNV">
            function <span class="apidocSignatureSpan">ml.AU.</span>SNV
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.AU.applyDotProduct">
            function <span class="apidocSignatureSpan">ml.AU.</span>applyDotProduct
            <span class="apidocSignatureSpan">(firstVector, secondVector)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.AU.coordArrayToCoordMatrix">
            function <span class="apidocSignatureSpan">ml.AU.</span>coordArrayToCoordMatrix
            <span class="apidocSignatureSpan">(array, dimensions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.AU.coordArrayToPoints">
            function <span class="apidocSignatureSpan">ml.AU.</span>coordArrayToPoints
            <span class="apidocSignatureSpan">(array, dimensions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.AU.coordMatrixToCoordArray">
            function <span class="apidocSignatureSpan">ml.AU.</span>coordMatrixToCoordArray
            <span class="apidocSignatureSpan">(coordMatrix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.AU.coordMatrixToPoints">
            function <span class="apidocSignatureSpan">ml.AU.</span>coordMatrixToPoints
            <span class="apidocSignatureSpan">(matrix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.AU.getEquallySpacedData">
            function <span class="apidocSignatureSpan">ml.AU.</span>getEquallySpacedData
            <span class="apidocSignatureSpan">(x, y, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.AU.pointsToCoordArray">
            function <span class="apidocSignatureSpan">ml.AU.</span>pointsToCoordArray
            <span class="apidocSignatureSpan">(points)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.AU.pointsToCoordMatrix">
            function <span class="apidocSignatureSpan">ml.AU.</span>pointsToCoordMatrix
            <span class="apidocSignatureSpan">(matrix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.AU.scale">
            function <span class="apidocSignatureSpan">ml.AU.</span>scale
            <span class="apidocSignatureSpan">(input, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ml.BitArray">module ml.BitArray</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.BitArray.and">
            function <span class="apidocSignatureSpan">ml.BitArray.</span>and
            <span class="apidocSignatureSpan">(arr1, arr2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.BitArray.count">
            function <span class="apidocSignatureSpan">ml.BitArray.</span>count
            <span class="apidocSignatureSpan">(arr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.BitArray.getBit">
            function <span class="apidocSignatureSpan">ml.BitArray.</span>getBit
            <span class="apidocSignatureSpan">(arr, n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.BitArray.not">
            function <span class="apidocSignatureSpan">ml.BitArray.</span>not
            <span class="apidocSignatureSpan">(arr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.BitArray.or">
            function <span class="apidocSignatureSpan">ml.BitArray.</span>or
            <span class="apidocSignatureSpan">(arr1, arr2)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.BitArray.parseBinaryString">
            function <span class="apidocSignatureSpan">ml.BitArray.</span>parseBinaryString
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.BitArray.parseHexString">
            function <span class="apidocSignatureSpan">ml.BitArray.</span>parseHexString
            <span class="apidocSignatureSpan">(str)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.BitArray.setBit">
            function <span class="apidocSignatureSpan">ml.BitArray.</span>setBit
            <span class="apidocSignatureSpan">(arr, n, val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.BitArray.toBinaryString">
            function <span class="apidocSignatureSpan">ml.BitArray.</span>toBinaryString
            <span class="apidocSignatureSpan">(arr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.BitArray.toDebug">
            function <span class="apidocSignatureSpan">ml.BitArray.</span>toDebug
            <span class="apidocSignatureSpan">(arr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.BitArray.toHexString">
            function <span class="apidocSignatureSpan">ml.BitArray.</span>toHexString
            <span class="apidocSignatureSpan">(arr)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.BitArray.xor">
            function <span class="apidocSignatureSpan">ml.BitArray.</span>xor
            <span class="apidocSignatureSpan">(arr1, arr2)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ml.Clust">module ml.Clust</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Clust.kmeans">
            function <span class="apidocSignatureSpan">ml.Clust.</span>kmeans
            <span class="apidocSignatureSpan">(data, K, options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ml.Clust.</span>hclust</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ml.Clust.hclust">module ml.Clust.hclust</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Clust.hclust.agnes">
            function <span class="apidocSignatureSpan">ml.Clust.hclust.</span>agnes
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Clust.hclust.diana">
            function <span class="apidocSignatureSpan">ml.Clust.hclust.</span>diana
            <span class="apidocSignatureSpan">(data, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ml.Math">module ml.Math</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.DistanceMatrix">
            function <span class="apidocSignatureSpan">ml.Math.</span>DistanceMatrix
            <span class="apidocSignatureSpan">(data, distanceFn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.Kernel">
            function <span class="apidocSignatureSpan">ml.Math.</span>Kernel
            <span class="apidocSignatureSpan">(type, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.Matrix">
            function <span class="apidocSignatureSpan">ml.Math.</span>Matrix
            <span class="apidocSignatureSpan">(Array)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SG">
            function <span class="apidocSignatureSpan">ml.Math.</span>SG
            <span class="apidocSignatureSpan">(data, h, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SGG">
            function <span class="apidocSignatureSpan">ml.Math.</span>SGG
            <span class="apidocSignatureSpan">(data, h, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix">
            function <span class="apidocSignatureSpan">ml.Math.</span>SparseMatrix
            <span class="apidocSignatureSpan">(rows, columns, options = {})</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ml.Math.</span>BellOptimizer</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ml.Math.</span>CurveFitting</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ml.Math.</span>Distance</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ml.Math.</span>Similarity</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ml.Math.BellOptimizer">module ml.Math.BellOptimizer</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.BellOptimizer.optimizeGaussianSum">
            function <span class="apidocSignatureSpan">ml.Math.BellOptimizer.</span>optimizeGaussianSum
            <span class="apidocSignatureSpan">(xy, group, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.BellOptimizer.optimizeGaussianTrain">
            function <span class="apidocSignatureSpan">ml.Math.BellOptimizer.</span>optimizeGaussianTrain
            <span class="apidocSignatureSpan">(xy, group, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.BellOptimizer.optimizeLorentzianSum">
            function <span class="apidocSignatureSpan">ml.Math.BellOptimizer.</span>optimizeLorentzianSum
            <span class="apidocSignatureSpan">(xy, group, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.BellOptimizer.optimizeLorentzianTrain">
            function <span class="apidocSignatureSpan">ml.Math.BellOptimizer.</span>optimizeLorentzianTrain
            <span class="apidocSignatureSpan">(xy, group, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.BellOptimizer.optimizeSingleGaussian">
            function <span class="apidocSignatureSpan">ml.Math.BellOptimizer.</span>optimizeSingleGaussian
            <span class="apidocSignatureSpan">(xy, peak, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.BellOptimizer.optimizeSingleLorentzian">
            function <span class="apidocSignatureSpan">ml.Math.BellOptimizer.</span>optimizeSingleLorentzian
            <span class="apidocSignatureSpan">(xy, peak, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.BellOptimizer.singleGaussian">
            function <span class="apidocSignatureSpan">ml.Math.BellOptimizer.</span>singleGaussian
            <span class="apidocSignatureSpan">(t, p, c)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.BellOptimizer.singleLorentzian">
            function <span class="apidocSignatureSpan">ml.Math.BellOptimizer.</span>singleLorentzian
            <span class="apidocSignatureSpan">(t, p, c)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ml.Math.CurveFitting">module ml.Math.CurveFitting</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.CurveFitting.Matrix">
            function <span class="apidocSignatureSpan">ml.Math.CurveFitting.</span>Matrix
            <span class="apidocSignatureSpan">(Array)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.CurveFitting.lm_Broyden_J">
            function <span class="apidocSignatureSpan">ml.Math.CurveFitting.</span>lm_Broyden_J
            <span class="apidocSignatureSpan">(p_old, y_old, J, p, y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.CurveFitting.lm_FD_J">
            function <span class="apidocSignatureSpan">ml.Math.CurveFitting.</span>lm_FD_J
            <span class="apidocSignatureSpan">(func, t, p, y, dp, c)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.CurveFitting.lm_matx">
            function <span class="apidocSignatureSpan">ml.Math.CurveFitting.</span>lm_matx
            <span class="apidocSignatureSpan">(func, t, p_old, y_old, dX2, J, p, y_dat, weight_sq, dp, c, iteration)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.CurveFitting.optimize">
            function <span class="apidocSignatureSpan">ml.Math.CurveFitting.</span>optimize
            <span class="apidocSignatureSpan">(func, p, t, y_dat, weight, dp, p_min, p_max, c, opts)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ml.Math.Distance">module ml.Math.Distance</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.Distance.additiveSymmetric">
            function <span class="apidocSignatureSpan">ml.Math.Distance.</span>additiveSymmetric
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.Distance.avg">
            function <span class="apidocSignatureSpan">ml.Math.Distance.</span>avg
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.Distance.bhattacharyya">
            function <span class="apidocSignatureSpan">ml.Math.Distance.</span>bhattacharyya
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.Distance.canberra">
            function <span class="apidocSignatureSpan">ml.Math.Distance.</span>canberra
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.Distance.chebyshev">
            function <span class="apidocSignatureSpan">ml.Math.Distance.</span>chebyshev
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.Distance.clark">
            function <span class="apidocSignatureSpan">ml.Math.Distance.</span>clark
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.Distance.czekanowski">
            function <span class="apidocSignatureSpan">ml.Math.Distance.</span>czekanowski
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.Distance.dice">
            function <span class="apidocSignatureSpan">ml.Math.Distance.</span>dice
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.Distance.divergence">
            function <span class="apidocSignatureSpan">ml.Math.Distance.</span>divergence
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.Distance.euclidean">
            function <span class="apidocSignatureSpan">ml.Math.Distance.</span>euclidean
            <span class="apidocSignatureSpan">(p, q)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.Distance.fidelity">
            function <span class="apidocSignatureSpan">ml.Math.Distance.</span>fidelity
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.Distance.gower">
            function <span class="apidocSignatureSpan">ml.Math.Distance.</span>gower
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.Distance.harmonicMean">
            function <span class="apidocSignatureSpan">ml.Math.Distance.</span>harmonicMean
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.Distance.hellinger">
            function <span class="apidocSignatureSpan">ml.Math.Distance.</span>hellinger
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.Distance.innerProduct">
            function <span class="apidocSignatureSpan">ml.Math.Distance.</span>innerProduct
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.Distance.intersection">
            function <span class="apidocSignatureSpan">ml.Math.Distance.</span>intersection
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.Distance.jaccard">
            function <span class="apidocSignatureSpan">ml.Math.Distance.</span>jaccard
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.Distance.jeffreys">
            function <span class="apidocSignatureSpan">ml.Math.Distance.</span>jeffreys
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.Distance.jensenDifference">
            function <span class="apidocSignatureSpan">ml.Math.Distance.</span>jensenDifference
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.Distance.jensenShannon">
            function <span class="apidocSignatureSpan">ml.Math.Distance.</span>jensenShannon
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.Distance.kdivergence">
            function <span class="apidocSignatureSpan">ml.Math.Distance.</span>kdivergence
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.Distance.kulczynski">
            function <span class="apidocSignatureSpan">ml.Math.Distance.</span>kulczynski
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.Distance.kullbackLeibler">
            function <span class="apidocSignatureSpan">ml.Math.Distance.</span>kullbackLeibler
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.Distance.kumarHassebrook">
            function <span class="apidocSignatureSpan">ml.Math.Distance.</span>kumarHassebrook
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.Distance.kumarJohnson">
            function <span class="apidocSignatureSpan">ml.Math.Distance.</span>kumarJohnson
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.Distance.lorentzian">
            function <span class="apidocSignatureSpan">ml.Math.Distance.</span>lorentzian
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.Distance.manhattan">
            function <span class="apidocSignatureSpan">ml.Math.Distance.</span>manhattan
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.Distance.matusita">
            function <span class="apidocSignatureSpan">ml.Math.Distance.</span>matusita
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.Distance.minkowski">
            function <span class="apidocSignatureSpan">ml.Math.Distance.</span>minkowski
            <span class="apidocSignatureSpan">(a, b, p)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.Distance.motyka">
            function <span class="apidocSignatureSpan">ml.Math.Distance.</span>motyka
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.Distance.neyman">
            function <span class="apidocSignatureSpan">ml.Math.Distance.</span>neyman
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.Distance.pearson">
            function <span class="apidocSignatureSpan">ml.Math.Distance.</span>pearson
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.Distance.probabilisticSymmetric">
            function <span class="apidocSignatureSpan">ml.Math.Distance.</span>probabilisticSymmetric
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.Distance.ruzicka">
            function <span class="apidocSignatureSpan">ml.Math.Distance.</span>ruzicka
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.Distance.soergel">
            function <span class="apidocSignatureSpan">ml.Math.Distance.</span>soergel
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.Distance.sorensen">
            function <span class="apidocSignatureSpan">ml.Math.Distance.</span>sorensen
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.Distance.squared">
            function <span class="apidocSignatureSpan">ml.Math.Distance.</span>squared
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.Distance.squaredChord">
            function <span class="apidocSignatureSpan">ml.Math.Distance.</span>squaredChord
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.Distance.squaredEuclidean">
            function <span class="apidocSignatureSpan">ml.Math.Distance.</span>squaredEuclidean
            <span class="apidocSignatureSpan">(p, q)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.Distance.taneja">
            function <span class="apidocSignatureSpan">ml.Math.Distance.</span>taneja
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.Distance.tanimoto">
            function <span class="apidocSignatureSpan">ml.Math.Distance.</span>tanimoto
            <span class="apidocSignatureSpan">(a, b, bitvector)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.Distance.topsoe">
            function <span class="apidocSignatureSpan">ml.Math.Distance.</span>topsoe
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.Distance.waveHedges">
            function <span class="apidocSignatureSpan">ml.Math.Distance.</span>waveHedges
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ml.Math.Distance.</span>tree</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ml.Math.Similarity">module ml.Math.Similarity</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.Similarity.cosine">
            function <span class="apidocSignatureSpan">ml.Math.Similarity.</span>cosine
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.Similarity.czekanowski">
            function <span class="apidocSignatureSpan">ml.Math.Similarity.</span>czekanowski
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.Similarity.dice">
            function <span class="apidocSignatureSpan">ml.Math.Similarity.</span>dice
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.Similarity.intersection">
            function <span class="apidocSignatureSpan">ml.Math.Similarity.</span>intersection
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.Similarity.jaccard">
            function <span class="apidocSignatureSpan">ml.Math.Similarity.</span>jaccard
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.Similarity.kulczynski">
            function <span class="apidocSignatureSpan">ml.Math.Similarity.</span>kulczynski
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.Similarity.motyka">
            function <span class="apidocSignatureSpan">ml.Math.Similarity.</span>motyka
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.Similarity.pearson">
            function <span class="apidocSignatureSpan">ml.Math.Similarity.</span>pearson
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.Similarity.squaredChord">
            function <span class="apidocSignatureSpan">ml.Math.Similarity.</span>squaredChord
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.Similarity.tanimoto">
            function <span class="apidocSignatureSpan">ml.Math.Similarity.</span>tanimoto
            <span class="apidocSignatureSpan">(a, b, bitvector)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ml.Math.SparseMatrix">module ml.Math.SparseMatrix</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.SparseMatrix">
            function <span class="apidocSignatureSpan">ml.Math.</span>SparseMatrix
            <span class="apidocSignatureSpan">(rows, columns, options = {})</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.abs">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>abs
            <span class="apidocSignatureSpan">(matrix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.acos">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>acos
            <span class="apidocSignatureSpan">(matrix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.acosh">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>acosh
            <span class="apidocSignatureSpan">(matrix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.add">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>add
            <span class="apidocSignatureSpan">(matrix, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.and">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>and
            <span class="apidocSignatureSpan">(matrix, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.asin">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>asin
            <span class="apidocSignatureSpan">(matrix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.asinh">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>asinh
            <span class="apidocSignatureSpan">(matrix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.atan">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>atan
            <span class="apidocSignatureSpan">(matrix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.atanh">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>atanh
            <span class="apidocSignatureSpan">(matrix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.cbrt">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>cbrt
            <span class="apidocSignatureSpan">(matrix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.ceil">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>ceil
            <span class="apidocSignatureSpan">(matrix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.clz32">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>clz32
            <span class="apidocSignatureSpan">(matrix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.cos">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>cos
            <span class="apidocSignatureSpan">(matrix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.cosh">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>cosh
            <span class="apidocSignatureSpan">(matrix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.div">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>div
            <span class="apidocSignatureSpan">(matrix, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.divide">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>divide
            <span class="apidocSignatureSpan">(matrix, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.exp">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>exp
            <span class="apidocSignatureSpan">(matrix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.expm1">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>expm1
            <span class="apidocSignatureSpan">(matrix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.floor">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>floor
            <span class="apidocSignatureSpan">(matrix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.fround">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>fround
            <span class="apidocSignatureSpan">(matrix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.identity">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>identity
            <span class="apidocSignatureSpan">(rows = 1, columns = rows)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.leftShift">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>leftShift
            <span class="apidocSignatureSpan">(matrix, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.log">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>log
            <span class="apidocSignatureSpan">(matrix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.log10">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>log10
            <span class="apidocSignatureSpan">(matrix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.log1p">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>log1p
            <span class="apidocSignatureSpan">(matrix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.log2">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>log2
            <span class="apidocSignatureSpan">(matrix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.mod">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>mod
            <span class="apidocSignatureSpan">(matrix, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.modulus">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>modulus
            <span class="apidocSignatureSpan">(matrix, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.mul">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>mul
            <span class="apidocSignatureSpan">(matrix, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.multiply">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>multiply
            <span class="apidocSignatureSpan">(matrix, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.not">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>not
            <span class="apidocSignatureSpan">(matrix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.or">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>or
            <span class="apidocSignatureSpan">(matrix, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.rightShift">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>rightShift
            <span class="apidocSignatureSpan">(matrix, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.round">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>round
            <span class="apidocSignatureSpan">(matrix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.sign">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>sign
            <span class="apidocSignatureSpan">(matrix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.signPropagatingRightShift">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>signPropagatingRightShift
            <span class="apidocSignatureSpan">(matrix, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.sin">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>sin
            <span class="apidocSignatureSpan">(matrix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.sinh">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>sinh
            <span class="apidocSignatureSpan">(matrix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.sqrt">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>sqrt
            <span class="apidocSignatureSpan">(matrix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.sub">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>sub
            <span class="apidocSignatureSpan">(matrix, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.subtract">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>subtract
            <span class="apidocSignatureSpan">(matrix, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.tan">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>tan
            <span class="apidocSignatureSpan">(matrix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.tanh">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>tanh
            <span class="apidocSignatureSpan">(matrix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.trunc">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>trunc
            <span class="apidocSignatureSpan">(matrix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.xor">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>xor
            <span class="apidocSignatureSpan">(matrix, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.zeroFillRightShift">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>zeroFillRightShift
            <span class="apidocSignatureSpan">(matrix, value)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ml.Math.SparseMatrix.prototype">module ml.Math.SparseMatrix.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.abs">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>abs
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.acos">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>acos
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.acosh">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>acosh
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.add">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>add
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.addM">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>addM
            <span class="apidocSignatureSpan">(matrix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.addS">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>addS
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.and">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>and
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.andM">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>andM
            <span class="apidocSignatureSpan">(matrix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.andS">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>andS
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.asin">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>asin
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.asinh">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>asinh
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.atan">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>atan
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.atanh">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>atanh
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.cbrt">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>cbrt
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.ceil">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>ceil
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.clz32">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>clz32
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.cos">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>cos
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.cosh">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>cosh
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.div">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>div
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.divM">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>divM
            <span class="apidocSignatureSpan">(matrix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.divS">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>divS
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.divide">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>divide
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.divideM">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>divideM
            <span class="apidocSignatureSpan">(matrix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.divideS">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>divideS
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.exp">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>exp
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.expm1">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>expm1
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.floor">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>floor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.fround">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>fround
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.leftShift">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>leftShift
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.leftShiftM">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>leftShiftM
            <span class="apidocSignatureSpan">(matrix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.leftShiftS">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>leftShiftS
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.log">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>log
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.log10">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>log10
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.log1p">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>log1p
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.log2">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>log2
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.mod">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>mod
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.modM">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>modM
            <span class="apidocSignatureSpan">(matrix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.modS">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>modS
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.modulus">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>modulus
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.modulusM">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>modulusM
            <span class="apidocSignatureSpan">(matrix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.modulusS">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>modulusS
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.mul">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>mul
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.mulM">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>mulM
            <span class="apidocSignatureSpan">(matrix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.mulS">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>mulS
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.multiply">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>multiply
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.multiplyM">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>multiplyM
            <span class="apidocSignatureSpan">(matrix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.multiplyS">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>multiplyS
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.not">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>not
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.or">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>or
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.orM">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>orM
            <span class="apidocSignatureSpan">(matrix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.orS">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>orS
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.rightShift">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>rightShift
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.rightShiftM">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>rightShiftM
            <span class="apidocSignatureSpan">(matrix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.rightShiftS">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>rightShiftS
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.round">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>round
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.sign">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>sign
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.signPropagatingRightShift">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>signPropagatingRightShift
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.signPropagatingRightShiftM">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>signPropagatingRightShiftM
            <span class="apidocSignatureSpan">(matrix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.signPropagatingRightShiftS">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>signPropagatingRightShiftS
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.sin">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>sin
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.sinh">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>sinh
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.sqrt">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>sqrt
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.sub">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>sub
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.subM">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>subM
            <span class="apidocSignatureSpan">(matrix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.subS">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>subS
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.subtract">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>subtract
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.subtractM">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>subtractM
            <span class="apidocSignatureSpan">(matrix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.subtractS">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>subtractS
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.tan">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>tan
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.tanh">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>tanh
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.tensorProduct">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>tensorProduct
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.trunc">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>trunc
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.xor">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>xor
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.xorM">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>xorM
            <span class="apidocSignatureSpan">(matrix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.xorS">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>xorS
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.zeroFillRightShift">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>zeroFillRightShift
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.zeroFillRightShiftM">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>zeroFillRightShiftM
            <span class="apidocSignatureSpan">(matrix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Math.SparseMatrix.prototype.zeroFillRightShiftS">
            function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>zeroFillRightShiftS
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>klass</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ml.Matrix">module ml.Matrix</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Matrix.Matrix">
            function <span class="apidocSignatureSpan">ml.</span>Matrix
            <span class="apidocSignatureSpan">(Array)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Matrix.abstractMatrix">
            function <span class="apidocSignatureSpan">ml.Matrix.</span>abstractMatrix
            <span class="apidocSignatureSpan">(superCtor)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Matrix.inv">
            function <span class="apidocSignatureSpan">ml.Matrix.</span>inv
            <span class="apidocSignatureSpan">(matrix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Matrix.inverse">
            function <span class="apidocSignatureSpan">ml.Matrix.</span>inverse
            <span class="apidocSignatureSpan">(matrix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Matrix.solve">
            function <span class="apidocSignatureSpan">ml.Matrix.</span>solve
            <span class="apidocSignatureSpan">(leftHandSide, rightHandSide)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ml.Matrix.</span>DC</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ml.Matrix.</span>Decompositions</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ml.Matrix.</span>algebra</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ml.Matrix.DC">module ml.Matrix.DC</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Matrix.DC.CHO">
            function <span class="apidocSignatureSpan">ml.Matrix.DC.</span>CHO
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Matrix.DC.CholeskyDecomposition">
            function <span class="apidocSignatureSpan">ml.Matrix.DC.</span>CholeskyDecomposition
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Matrix.DC.EVD">
            function <span class="apidocSignatureSpan">ml.Matrix.DC.</span>EVD
            <span class="apidocSignatureSpan">(matrix, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Matrix.DC.EigenvalueDecomposition">
            function <span class="apidocSignatureSpan">ml.Matrix.DC.</span>EigenvalueDecomposition
            <span class="apidocSignatureSpan">(matrix, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Matrix.DC.LU">
            function <span class="apidocSignatureSpan">ml.Matrix.DC.</span>LU
            <span class="apidocSignatureSpan">(matrix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Matrix.DC.LuDecomposition">
            function <span class="apidocSignatureSpan">ml.Matrix.DC.</span>LuDecomposition
            <span class="apidocSignatureSpan">(matrix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Matrix.DC.QR">
            function <span class="apidocSignatureSpan">ml.Matrix.DC.</span>QR
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Matrix.DC.QrDecomposition">
            function <span class="apidocSignatureSpan">ml.Matrix.DC.</span>QrDecomposition
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Matrix.DC.SVD">
            function <span class="apidocSignatureSpan">ml.Matrix.DC.</span>SVD
            <span class="apidocSignatureSpan">(value, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Matrix.DC.SingularValueDecomposition">
            function <span class="apidocSignatureSpan">ml.Matrix.DC.</span>SingularValueDecomposition
            <span class="apidocSignatureSpan">(value, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Matrix.DC.inverse">
            function <span class="apidocSignatureSpan">ml.Matrix.DC.</span>inverse
            <span class="apidocSignatureSpan">(matrix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Matrix.DC.solve">
            function <span class="apidocSignatureSpan">ml.Matrix.DC.</span>solve
            <span class="apidocSignatureSpan">(leftHandSide, rightHandSide)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ml.Matrix.DC.CholeskyDecomposition.prototype">module ml.Matrix.DC.CholeskyDecomposition.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Matrix.DC.CholeskyDecomposition.prototype.solve">
            function <span class="apidocSignatureSpan">ml.Matrix.DC.CholeskyDecomposition.prototype.</span>solve
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ml.Matrix.DC.LuDecomposition.prototype">module ml.Matrix.DC.LuDecomposition.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Matrix.DC.LuDecomposition.prototype.isSingular">
            function <span class="apidocSignatureSpan">ml.Matrix.DC.LuDecomposition.prototype.</span>isSingular
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Matrix.DC.LuDecomposition.prototype.solve">
            function <span class="apidocSignatureSpan">ml.Matrix.DC.LuDecomposition.prototype.</span>solve
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ml.Matrix.DC.QrDecomposition.prototype">module ml.Matrix.DC.QrDecomposition.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Matrix.DC.QrDecomposition.prototype.isFullRank">
            function <span class="apidocSignatureSpan">ml.Matrix.DC.QrDecomposition.prototype.</span>isFullRank
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Matrix.DC.QrDecomposition.prototype.solve">
            function <span class="apidocSignatureSpan">ml.Matrix.DC.QrDecomposition.prototype.</span>solve
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ml.Matrix.DC.SingularValueDecomposition.prototype">module ml.Matrix.DC.SingularValueDecomposition.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Matrix.DC.SingularValueDecomposition.prototype.inverse">
            function <span class="apidocSignatureSpan">ml.Matrix.DC.SingularValueDecomposition.prototype.</span>inverse
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Matrix.DC.SingularValueDecomposition.prototype.solve">
            function <span class="apidocSignatureSpan">ml.Matrix.DC.SingularValueDecomposition.prototype.</span>solve
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Matrix.DC.SingularValueDecomposition.prototype.solveForDiagonal">
            function <span class="apidocSignatureSpan">ml.Matrix.DC.SingularValueDecomposition.prototype.</span>solveForDiagonal
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ml.Matrix.algebra">module ml.Matrix.algebra</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Matrix.algebra.abs">
            function <span class="apidocSignatureSpan">ml.Matrix.algebra.</span>abs
            <span class="apidocSignatureSpan">(A)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Matrix.algebra.add">
            function <span class="apidocSignatureSpan">ml.Matrix.algebra.</span>add
            <span class="apidocSignatureSpan">(A, B)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Matrix.algebra.diag">
            function <span class="apidocSignatureSpan">ml.Matrix.algebra.</span>diag
            <span class="apidocSignatureSpan">(A)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Matrix.algebra.dotDivide">
            function <span class="apidocSignatureSpan">ml.Matrix.algebra.</span>dotDivide
            <span class="apidocSignatureSpan">(A, B)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Matrix.algebra.dotMultiply">
            function <span class="apidocSignatureSpan">ml.Matrix.algebra.</span>dotMultiply
            <span class="apidocSignatureSpan">(A, B)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Matrix.algebra.dotPow">
            function <span class="apidocSignatureSpan">ml.Matrix.algebra.</span>dotPow
            <span class="apidocSignatureSpan">(A, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Matrix.algebra.exp">
            function <span class="apidocSignatureSpan">ml.Matrix.algebra.</span>exp
            <span class="apidocSignatureSpan">(A)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Matrix.algebra.eye">
            function <span class="apidocSignatureSpan">ml.Matrix.algebra.</span>eye
            <span class="apidocSignatureSpan">(rows, cols)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Matrix.algebra.inv">
            function <span class="apidocSignatureSpan">ml.Matrix.algebra.</span>inv
            <span class="apidocSignatureSpan">(A)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Matrix.algebra.matrix">
            function <span class="apidocSignatureSpan">ml.Matrix.algebra.</span>matrix
            <span class="apidocSignatureSpan">(A, B)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Matrix.algebra.max">
            function <span class="apidocSignatureSpan">ml.Matrix.algebra.</span>max
            <span class="apidocSignatureSpan">(A, B)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Matrix.algebra.min">
            function <span class="apidocSignatureSpan">ml.Matrix.algebra.</span>min
            <span class="apidocSignatureSpan">(A, B)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Matrix.algebra.multiply">
            function <span class="apidocSignatureSpan">ml.Matrix.algebra.</span>multiply
            <span class="apidocSignatureSpan">(A, B)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Matrix.algebra.ones">
            function <span class="apidocSignatureSpan">ml.Matrix.algebra.</span>ones
            <span class="apidocSignatureSpan">(rows, cols)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Matrix.algebra.random">
            function <span class="apidocSignatureSpan">ml.Matrix.algebra.</span>random
            <span class="apidocSignatureSpan">(rows, cols)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Matrix.algebra.solve">
            function <span class="apidocSignatureSpan">ml.Matrix.algebra.</span>solve
            <span class="apidocSignatureSpan">(A, B)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Matrix.algebra.sqrt">
            function <span class="apidocSignatureSpan">ml.Matrix.algebra.</span>sqrt
            <span class="apidocSignatureSpan">(A)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Matrix.algebra.subtract">
            function <span class="apidocSignatureSpan">ml.Matrix.algebra.</span>subtract
            <span class="apidocSignatureSpan">(A, B)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Matrix.algebra.transpose">
            function <span class="apidocSignatureSpan">ml.Matrix.algebra.</span>transpose
            <span class="apidocSignatureSpan">(A)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Matrix.algebra.zeros">
            function <span class="apidocSignatureSpan">ml.Matrix.algebra.</span>zeros
            <span class="apidocSignatureSpan">(rows, cols)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ml.Matrix.prototype">module ml.Matrix.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Matrix.prototype.inv">
            function <span class="apidocSignatureSpan">ml.Matrix.prototype.</span>inv
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Matrix.prototype.inverse">
            function <span class="apidocSignatureSpan">ml.Matrix.prototype.</span>inverse
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Matrix.prototype.solve">
            function <span class="apidocSignatureSpan">ml.Matrix.prototype.</span>solve
            <span class="apidocSignatureSpan">(other)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ml.RNG">module ml.RNG</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.RNG.XSadd">
            function <span class="apidocSignatureSpan">ml.RNG.</span>XSadd
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ml.Regression">module ml.Regression</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Regression.KRR">
            function <span class="apidocSignatureSpan">ml.Regression.</span>KRR
            <span class="apidocSignatureSpan">(inputs, outputs, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Regression.KernelRidgeRegression">
            function <span class="apidocSignatureSpan">ml.Regression.</span>KernelRidgeRegression
            <span class="apidocSignatureSpan">(inputs, outputs, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Regression.PolinomialFitting2D">
            function <span class="apidocSignatureSpan">ml.Regression.</span>PolinomialFitting2D
            <span class="apidocSignatureSpan">(inputs, outputs, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Regression.SLR">
            function <span class="apidocSignatureSpan">ml.Regression.</span>SLR
            <span class="apidocSignatureSpan">(x, y, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Regression.SimpleLinearRegression">
            function <span class="apidocSignatureSpan">ml.Regression.</span>SimpleLinearRegression
            <span class="apidocSignatureSpan">(x, y, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Regression.TheilSenRegression">
            function <span class="apidocSignatureSpan">ml.Regression.</span>TheilSenRegression
            <span class="apidocSignatureSpan">(x, y, options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ml.Regression.</span>NLR</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ml.Regression.</span>NonLinearRegression</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ml.Regression.NLR">module ml.Regression.NLR</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Regression.NLR.ExpRegression">
            function <span class="apidocSignatureSpan">ml.Regression.NLR.</span>ExpRegression
            <span class="apidocSignatureSpan">(x, y, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Regression.NLR.PolynomialRegression">
            function <span class="apidocSignatureSpan">ml.Regression.NLR.</span>PolynomialRegression
            <span class="apidocSignatureSpan">(x, y, M, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Regression.NLR.PotentialRegression">
            function <span class="apidocSignatureSpan">ml.Regression.NLR.</span>PotentialRegression
            <span class="apidocSignatureSpan">(x, y, M, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Regression.NLR.PowerRegression">
            function <span class="apidocSignatureSpan">ml.Regression.NLR.</span>PowerRegression
            <span class="apidocSignatureSpan">(x, y, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ml.SL">module ml.SL</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.SL.KNN">
            function <span class="apidocSignatureSpan">ml.SL.</span>KNN
            <span class="apidocSignatureSpan">(reload, model)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.SL.NaiveBayes">
            function <span class="apidocSignatureSpan">ml.SL.</span>NaiveBayes
            <span class="apidocSignatureSpan">(reload, model)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.SL.PLS">
            function <span class="apidocSignatureSpan">ml.SL.</span>PLS
            <span class="apidocSignatureSpan">(X, Y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.SL.SVM">
            function <span class="apidocSignatureSpan">ml.SL.</span>SVM
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ml.SL.</span>CV</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ml.SL.</span>CrossValidation</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ml.SL.CV">module ml.SL.CV</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.SL.CV.kFold">
            function <span class="apidocSignatureSpan">ml.SL.CV.</span>kFold
            <span class="apidocSignatureSpan">(Classifier, features, labels, classifierOptions, k)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.SL.CV.leaveOneOut">
            function <span class="apidocSignatureSpan">ml.SL.CV.</span>leaveOneOut
            <span class="apidocSignatureSpan">(Classifier, features, labels, classifierOptions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.SL.CV.leavePOut">
            function <span class="apidocSignatureSpan">ml.SL.CV.</span>leavePOut
            <span class="apidocSignatureSpan">(Classifier, features, labels, classifierOptions, p)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ml.SL.KNN">module ml.SL.KNN</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.SL.KNN.KNN">
            function <span class="apidocSignatureSpan">ml.SL.</span>KNN
            <span class="apidocSignatureSpan">(reload, model)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.SL.KNN.load">
            function <span class="apidocSignatureSpan">ml.SL.KNN.</span>load
            <span class="apidocSignatureSpan">(model)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ml.SL.KNN.prototype">module ml.SL.KNN.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.SL.KNN.prototype.export">
            function <span class="apidocSignatureSpan">ml.SL.KNN.prototype.</span>export
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.SL.KNN.prototype.getSinglePrediction">
            function <span class="apidocSignatureSpan">ml.SL.KNN.prototype.</span>getSinglePrediction
            <span class="apidocSignatureSpan">(currentCase)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.SL.KNN.prototype.predict">
            function <span class="apidocSignatureSpan">ml.SL.KNN.prototype.</span>predict
            <span class="apidocSignatureSpan">(dataset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.SL.KNN.prototype.train">
            function <span class="apidocSignatureSpan">ml.SL.KNN.prototype.</span>train
            <span class="apidocSignatureSpan">(trainingSet, trainingLabels, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ml.SL.NaiveBayes">module ml.SL.NaiveBayes</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.SL.NaiveBayes.NaiveBayes">
            function <span class="apidocSignatureSpan">ml.SL.</span>NaiveBayes
            <span class="apidocSignatureSpan">(reload, model)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.SL.NaiveBayes.load">
            function <span class="apidocSignatureSpan">ml.SL.NaiveBayes.</span>load
            <span class="apidocSignatureSpan">(model)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.SL.NaiveBayes.separateClasses">
            function <span class="apidocSignatureSpan">ml.SL.NaiveBayes.</span>separateClasses
            <span class="apidocSignatureSpan">(X, y)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ml.SL.NaiveBayes.prototype">module ml.SL.NaiveBayes.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.SL.NaiveBayes.prototype.export">
            function <span class="apidocSignatureSpan">ml.SL.NaiveBayes.prototype.</span>export
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.SL.NaiveBayes.prototype.predict">
            function <span class="apidocSignatureSpan">ml.SL.NaiveBayes.prototype.</span>predict
            <span class="apidocSignatureSpan">(dataset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.SL.NaiveBayes.prototype.train">
            function <span class="apidocSignatureSpan">ml.SL.NaiveBayes.prototype.</span>train
            <span class="apidocSignatureSpan">(trainingSet, trainingLabels)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ml.SL.PLS">module ml.SL.PLS</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.SL.PLS.PLS">
            function <span class="apidocSignatureSpan">ml.SL.</span>PLS
            <span class="apidocSignatureSpan">(X, Y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.SL.PLS.OPLS">
            function <span class="apidocSignatureSpan">ml.SL.PLS.</span>OPLS
            <span class="apidocSignatureSpan">(dataset, predictions, numberOSC)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ml.SL.PLS.</span>Utils</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ml.SL.PLS.OPLS.prototype">module ml.SL.PLS.OPLS.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.SL.PLS.OPLS.prototype.correctDataset">
            function <span class="apidocSignatureSpan">ml.SL.PLS.OPLS.prototype.</span>correctDataset
            <span class="apidocSignatureSpan">(dataset)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ml.SL.SVM">module ml.SL.SVM</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.SL.SVM.SVM">
            function <span class="apidocSignatureSpan">ml.SL.</span>SVM
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.SL.SVM.load">
            function <span class="apidocSignatureSpan">ml.SL.SVM.</span>load
            <span class="apidocSignatureSpan">(model)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ml.SL.SVM.prototype">module ml.SL.SVM.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.SL.SVM.prototype._applyWhitening">
            function <span class="apidocSignatureSpan">ml.SL.SVM.prototype.</span>_applyWhitening
            <span class="apidocSignatureSpan">(features)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.SL.SVM.prototype._marginOnePrecomputed">
            function <span class="apidocSignatureSpan">ml.SL.SVM.prototype.</span>_marginOnePrecomputed
            <span class="apidocSignatureSpan">(index, kernel)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.SL.SVM.prototype.margin">
            function <span class="apidocSignatureSpan">ml.SL.SVM.prototype.</span>margin
            <span class="apidocSignatureSpan">(features)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.SL.SVM.prototype.marginOne">
            function <span class="apidocSignatureSpan">ml.SL.SVM.prototype.</span>marginOne
            <span class="apidocSignatureSpan">(features, noWhitening)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.SL.SVM.prototype.predict">
            function <span class="apidocSignatureSpan">ml.SL.SVM.prototype.</span>predict
            <span class="apidocSignatureSpan">(features)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.SL.SVM.prototype.predictOne">
            function <span class="apidocSignatureSpan">ml.SL.SVM.prototype.</span>predictOne
            <span class="apidocSignatureSpan">(p)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.SL.SVM.prototype.supportVectors">
            function <span class="apidocSignatureSpan">ml.SL.SVM.prototype.</span>supportVectors
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.SL.SVM.prototype.toJSON">
            function <span class="apidocSignatureSpan">ml.SL.SVM.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.SL.SVM.prototype.train">
            function <span class="apidocSignatureSpan">ml.SL.SVM.prototype.</span>train
            <span class="apidocSignatureSpan">(features, labels)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ml.Stat">module ml.Stat</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Stat.PCA">
            function <span class="apidocSignatureSpan">ml.Stat.</span>PCA
            <span class="apidocSignatureSpan">(dataset, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Stat.Performance">
            function <span class="apidocSignatureSpan">ml.Stat.</span>Performance
            <span class="apidocSignatureSpan">(values: truthy for same class, falsy for different class)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ml.Stat.</span>array</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">ml.Stat.</span>matrix</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ml.Stat.array">module ml.Stat.array</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Stat.array.arithmeticMean">
            function <span class="apidocSignatureSpan">ml.Stat.array.</span>arithmeticMean
            <span class="apidocSignatureSpan">(values)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Stat.array.center">
            function <span class="apidocSignatureSpan">ml.Stat.array.</span>center
            <span class="apidocSignatureSpan">(values, inPlace)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Stat.array.contraHarmonicMean">
            function <span class="apidocSignatureSpan">ml.Stat.array.</span>contraHarmonicMean
            <span class="apidocSignatureSpan">(values)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Stat.array.covariance">
            function <span class="apidocSignatureSpan">ml.Stat.array.</span>covariance
            <span class="apidocSignatureSpan">(vector1, vector2, unbiased)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Stat.array.cumulativeSum">
            function <span class="apidocSignatureSpan">ml.Stat.array.</span>cumulativeSum
            <span class="apidocSignatureSpan">(array)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Stat.array.entropy">
            function <span class="apidocSignatureSpan">ml.Stat.array.</span>entropy
            <span class="apidocSignatureSpan">(values, eps)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Stat.array.geometricMean">
            function <span class="apidocSignatureSpan">ml.Stat.array.</span>geometricMean
            <span class="apidocSignatureSpan">(values)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Stat.array.grandMean">
            function <span class="apidocSignatureSpan">ml.Stat.array.</span>grandMean
            <span class="apidocSignatureSpan">(means, samples)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Stat.array.harmonicMean">
            function <span class="apidocSignatureSpan">ml.Stat.array.</span>harmonicMean
            <span class="apidocSignatureSpan">(values)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Stat.array.kurtosis">
            function <span class="apidocSignatureSpan">ml.Stat.array.</span>kurtosis
            <span class="apidocSignatureSpan">(values, unbiased)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Stat.array.logMean">
            function <span class="apidocSignatureSpan">ml.Stat.array.</span>logMean
            <span class="apidocSignatureSpan">(values)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Stat.array.max">
            function <span class="apidocSignatureSpan">ml.Stat.array.</span>max
            <span class="apidocSignatureSpan">(values)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Stat.array.mean">
            function <span class="apidocSignatureSpan">ml.Stat.array.</span>mean
            <span class="apidocSignatureSpan">(values)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Stat.array.median">
            function <span class="apidocSignatureSpan">ml.Stat.array.</span>median
            <span class="apidocSignatureSpan">(values, alreadySorted)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Stat.array.min">
            function <span class="apidocSignatureSpan">ml.Stat.array.</span>min
            <span class="apidocSignatureSpan">(values)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Stat.array.minMax">
            function <span class="apidocSignatureSpan">ml.Stat.array.</span>minMax
            <span class="apidocSignatureSpan">(values)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Stat.array.mode">
            function <span class="apidocSignatureSpan">ml.Stat.array.</span>mode
            <span class="apidocSignatureSpan">(values)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Stat.array.pooledStandardDeviation">
            function <span class="apidocSignatureSpan">ml.Stat.array.</span>pooledStandardDeviation
            <span class="apidocSignatureSpan">(samples, unbiased)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Stat.array.pooledVariance">
            function <span class="apidocSignatureSpan">ml.Stat.array.</span>pooledVariance
            <span class="apidocSignatureSpan">(samples, unbiased)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Stat.array.quartiles">
            function <span class="apidocSignatureSpan">ml.Stat.array.</span>quartiles
            <span class="apidocSignatureSpan">(values, alreadySorted)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Stat.array.robustMeanAndStdev">
            function <span class="apidocSignatureSpan">ml.Stat.array.</span>robustMeanAndStdev
            <span class="apidocSignatureSpan">(y)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Stat.array.skewness">
            function <span class="apidocSignatureSpan">ml.Stat.array.</span>skewness
            <span class="apidocSignatureSpan">(values, unbiased)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Stat.array.standardDeviation">
            function <span class="apidocSignatureSpan">ml.Stat.array.</span>standardDeviation
            <span class="apidocSignatureSpan">(values, unbiased)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Stat.array.standardError">
            function <span class="apidocSignatureSpan">ml.Stat.array.</span>standardError
            <span class="apidocSignatureSpan">(values)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Stat.array.standardize">
            function <span class="apidocSignatureSpan">ml.Stat.array.</span>standardize
            <span class="apidocSignatureSpan">(values, standardDev, inPlace)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Stat.array.sum">
            function <span class="apidocSignatureSpan">ml.Stat.array.</span>sum
            <span class="apidocSignatureSpan">(values)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Stat.array.truncatedMean">
            function <span class="apidocSignatureSpan">ml.Stat.array.</span>truncatedMean
            <span class="apidocSignatureSpan">(values, percent, alreadySorted)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Stat.array.variance">
            function <span class="apidocSignatureSpan">ml.Stat.array.</span>variance
            <span class="apidocSignatureSpan">(values, unbiased)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Stat.array.weightedMean">
            function <span class="apidocSignatureSpan">ml.Stat.array.</span>weightedMean
            <span class="apidocSignatureSpan">(values, weights)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Stat.array.weightedStandardDeviation">
            function <span class="apidocSignatureSpan">ml.Stat.array.</span>weightedStandardDeviation
            <span class="apidocSignatureSpan">(values, weights)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Stat.array.weightedVariance">
            function <span class="apidocSignatureSpan">ml.Stat.array.</span>weightedVariance
            <span class="apidocSignatureSpan">(values, weights)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ml.Stat.matrix">module ml.Stat.matrix</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Stat.matrix.center">
            function <span class="apidocSignatureSpan">ml.Stat.matrix.</span>center
            <span class="apidocSignatureSpan">(matrix, means, inPlace)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Stat.matrix.correlation">
            function <span class="apidocSignatureSpan">ml.Stat.matrix.</span>correlation
            <span class="apidocSignatureSpan">(matrix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Stat.matrix.covariance">
            function <span class="apidocSignatureSpan">ml.Stat.matrix.</span>covariance
            <span class="apidocSignatureSpan">(matrix, dimension)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Stat.matrix.entropy">
            function <span class="apidocSignatureSpan">ml.Stat.matrix.</span>entropy
            <span class="apidocSignatureSpan">(matrix, eps)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Stat.matrix.kurtosis">
            function <span class="apidocSignatureSpan">ml.Stat.matrix.</span>kurtosis
            <span class="apidocSignatureSpan">(matrix, unbiased)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Stat.matrix.max">
            function <span class="apidocSignatureSpan">ml.Stat.matrix.</span>max
            <span class="apidocSignatureSpan">(matrix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Stat.matrix.mean">
            function <span class="apidocSignatureSpan">ml.Stat.matrix.</span>mean
            <span class="apidocSignatureSpan">(matrix, dimension)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Stat.matrix.median">
            function <span class="apidocSignatureSpan">ml.Stat.matrix.</span>median
            <span class="apidocSignatureSpan">(matrix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Stat.matrix.min">
            function <span class="apidocSignatureSpan">ml.Stat.matrix.</span>min
            <span class="apidocSignatureSpan">(matrix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Stat.matrix.minMax">
            function <span class="apidocSignatureSpan">ml.Stat.matrix.</span>minMax
            <span class="apidocSignatureSpan">(matrix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Stat.matrix.mode">
            function <span class="apidocSignatureSpan">ml.Stat.matrix.</span>mode
            <span class="apidocSignatureSpan">(matrix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Stat.matrix.product">
            function <span class="apidocSignatureSpan">ml.Stat.matrix.</span>product
            <span class="apidocSignatureSpan">(matrix, dimension)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Stat.matrix.scatter">
            function <span class="apidocSignatureSpan">ml.Stat.matrix.</span>scatter
            <span class="apidocSignatureSpan">(matrix, divisor, dimension)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Stat.matrix.skewness">
            function <span class="apidocSignatureSpan">ml.Stat.matrix.</span>skewness
            <span class="apidocSignatureSpan">(matrix, unbiased)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Stat.matrix.standardDeviation">
            function <span class="apidocSignatureSpan">ml.Stat.matrix.</span>standardDeviation
            <span class="apidocSignatureSpan">(matrix, means, unbiased)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Stat.matrix.standardError">
            function <span class="apidocSignatureSpan">ml.Stat.matrix.</span>standardError
            <span class="apidocSignatureSpan">(matrix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Stat.matrix.standardize">
            function <span class="apidocSignatureSpan">ml.Stat.matrix.</span>standardize
            <span class="apidocSignatureSpan">(matrix, standardDeviations, inPlace)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Stat.matrix.sum">
            function <span class="apidocSignatureSpan">ml.Stat.matrix.</span>sum
            <span class="apidocSignatureSpan">(matrix, dimension)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Stat.matrix.variance">
            function <span class="apidocSignatureSpan">ml.Stat.matrix.</span>variance
            <span class="apidocSignatureSpan">(matrix, means, unbiased)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Stat.matrix.weightedCovariance">
            function <span class="apidocSignatureSpan">ml.Stat.matrix.</span>weightedCovariance
            <span class="apidocSignatureSpan">(matrix, weights, means, dimension)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Stat.matrix.weightedMean">
            function <span class="apidocSignatureSpan">ml.Stat.matrix.</span>weightedMean
            <span class="apidocSignatureSpan">(matrix, weights, dimension)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Stat.matrix.weightedScatter">
            function <span class="apidocSignatureSpan">ml.Stat.matrix.</span>weightedScatter
            <span class="apidocSignatureSpan">(matrix, weights, means, factor, dimension)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Stat.matrix.weightedVariance">
            function <span class="apidocSignatureSpan">ml.Stat.matrix.</span>weightedVariance
            <span class="apidocSignatureSpan">(matrix, weights)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.Stat.matrix.zScores">
            function <span class="apidocSignatureSpan">ml.Stat.matrix.</span>zScores
            <span class="apidocSignatureSpan">(matrix, means, standardDeviations)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ml.nn">module ml.nn</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.nn.FNN">
            function <span class="apidocSignatureSpan">ml.nn.</span>FNN
            <span class="apidocSignatureSpan">(also known as epsilon)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.nn.SOM">
            function <span class="apidocSignatureSpan">ml.nn.</span>SOM
            <span class="apidocSignatureSpan">(x, y, options, reload)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ml.nn.SOM">module ml.nn.SOM</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.nn.SOM.SOM">
            function <span class="apidocSignatureSpan">ml.nn.</span>SOM
            <span class="apidocSignatureSpan">(x, y, options, reload)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.nn.SOM.load">
            function <span class="apidocSignatureSpan">ml.nn.SOM.</span>load
            <span class="apidocSignatureSpan">(model, distance)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ml.nn.SOM.prototype">module ml.nn.SOM.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.nn.SOM.prototype._adjust">
            function <span class="apidocSignatureSpan">ml.nn.SOM.prototype.</span>_adjust
            <span class="apidocSignatureSpan">(trainingValue, neighbourhoodRadius)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.nn.SOM.prototype._findBestMatchingUnit">
            function <span class="apidocSignatureSpan">ml.nn.SOM.prototype.</span>_findBestMatchingUnit
            <span class="apidocSignatureSpan">(candidate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.nn.SOM.prototype._initNodes">
            function <span class="apidocSignatureSpan">ml.nn.SOM.prototype.</span>_initNodes
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.nn.SOM.prototype._predict">
            function <span class="apidocSignatureSpan">ml.nn.SOM.prototype.</span>_predict
            <span class="apidocSignatureSpan">(element, computePosition)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.nn.SOM.prototype.export">
            function <span class="apidocSignatureSpan">ml.nn.SOM.prototype.</span>export
            <span class="apidocSignatureSpan">(includeDistance)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.nn.SOM.prototype.getConvertedNodes">
            function <span class="apidocSignatureSpan">ml.nn.SOM.prototype.</span>getConvertedNodes
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.nn.SOM.prototype.getFit">
            function <span class="apidocSignatureSpan">ml.nn.SOM.prototype.</span>getFit
            <span class="apidocSignatureSpan">(dataset)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.nn.SOM.prototype.getQuantizationError">
            function <span class="apidocSignatureSpan">ml.nn.SOM.prototype.</span>getQuantizationError
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.nn.SOM.prototype.predict">
            function <span class="apidocSignatureSpan">ml.nn.SOM.prototype.</span>predict
            <span class="apidocSignatureSpan">(data, computePosition)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.nn.SOM.prototype.setTraining">
            function <span class="apidocSignatureSpan">ml.nn.SOM.prototype.</span>setTraining
            <span class="apidocSignatureSpan">(trainingSet)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.nn.SOM.prototype.train">
            function <span class="apidocSignatureSpan">ml.nn.SOM.prototype.</span>train
            <span class="apidocSignatureSpan">(trainingSet)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.nn.SOM.prototype.trainOne">
            function <span class="apidocSignatureSpan">ml.nn.SOM.prototype.</span>trainOne
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.ml.numSort">module ml.numSort</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.numSort.asc">
            function <span class="apidocSignatureSpan">ml.numSort.</span>asc
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.ml.numSort.desc">
            function <span class="apidocSignatureSpan">ml.numSort.</span>desc
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ml" id="apidoc.module.ml">module ml</a></h1>


    <h2>
        <a href="#apidoc.element.ml.HashTable" id="apidoc.element.ml.HashTable">
        function <span class="apidocSignatureSpan">ml.</span>HashTable
        <span class="apidocSignatureSpan">(options = {})</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class HashTable {
    constructor(options = {}) {
        if (options instanceof HashTable) {
            this.table = options.table.slice();
            this.values = options.values.slice();
            this.state = options.state.slice();
            this.minLoadFactor = options.minLoadFactor;
            this.maxLoadFactor = options.maxLoadFactor;
            this.distinct = options.distinct;
            this.freeEntries = options.freeEntries;
            this.lowWaterMark = options.lowWaterMark;
            this.highWaterMark = options.maxLoadFactor;
            return;
        }

        const initialCapacity = options.initialCapacity === undefined ? defaultInitialCapacity : options.initialCapacity;
        if (initialCapacity &#x3c; 0) {
            throw new RangeError(`initial capacity must not be less than zero: ${initialCapacity}`);
        }

        const minLoadFactor = options.minLoadFactor === undefined ? defaultMinLoadFactor : options.minLoadFactor;
        const maxLoadFactor = options.maxLoadFactor === undefined ? defaultMaxLoadFactor : options.maxLoadFactor;
        if (minLoadFactor &#x3c; 0 || minLoadFactor &#x3e;= 1) {
            throw new RangeError(`invalid minLoadFactor: ${minLoadFactor}`);
        }
        if (maxLoadFactor &#x3c;= 0 || maxLoadFactor &#x3e;= 1) {
            throw new RangeError(`invalid maxLoadFactor: ${maxLoadFactor}`);
        }
        if (minLoadFactor &#x3e;= maxLoadFactor) {
            throw new RangeError(`minLoadFactor (${minLoadFactor}) must be smaller than maxLoadFactor (${maxLoadFactor})`);
        }

        let capacity = initialCapacity;
        // User wants to put at least capacity elements. We need to choose the size based on the maxLoadFactor to
        // avoid the need to rehash before this capacity is reached.
        // actualCapacity * maxLoadFactor &#x3e;= capacity
        capacity = (capacity / maxLoadFactor) | 0;
        capacity = nextPrime(capacity);
        if (capacity === 0) capacity = 1;

        this.table = newArray(capacity, 0);
        this.values = newArray(capacity, 0);
        this.state = newArray(capacity, 0);

        this.minLoadFactor = minLoadFactor;
        if (capacity === largestPrime) {
            this.maxLoadFactor = 1;
        } else {
            this.maxLoadFactor = maxLoadFactor;
        }

        this.distinct = 0;
        this.freeEntries = capacity;

        this.lowWaterMark = 0;
        this.highWaterMark = chooseHighWaterMark(capacity, this.maxLoadFactor);
    }

    clone() {
        return new HashTable(this);
    }

    get size() {
        return this.distinct;
    }

    get(key) {
        const i = this.indexOfKey(key);
        if (i &#x3c; 0) return 0;
        return this.values[i];
    }

    set(key, value) {
        let i = this.indexOfInsertion(key);
        if (i &#x3c; 0) {
            i = -i - 1;
            this.values[i] = value;
            return false;
        }

        if (this.distinct &#x3e; this.highWaterMark) {
            const newCapacity = chooseGrowCapacity(this.distinct + 1, this.minLoadFactor, this.maxLoadFactor);
            this.rehash(newCapacity);
            return this.set(key, value);
        }

        this.table[i] = key;
        this.values[i] = value;
        if (this.state[i] === FREE) this.freeEntries--;
        this.state[i] = FULL;
        this.distinct++;

        if (this.freeEntries &#x3c; 1) {
            const newCapacity = chooseGrowCapacity(this.distinct + 1, this.minLoadFactor, this.maxLoadFactor);
            this.rehash(newCapacity);
        }

        return true;
    }

    remove(key, noRehash) {
        const i = this.indexOfKey(key);
        if (i &#x3c; 0) return false;

        this.state[i] = REMOVED;
        this.distinct--;

        if (!noRehash) this.maybeShrinkCapacity();

        return true;
    }

    delete(key, noRehash) {
        const i = this.indexOfKey(key);
        if (i &#x3c; 0) return false;

        this.state[i] = FREE;
        this.distinct--;

        if (!noRehash) this.maybeShrinkCapacity();

        return true;
    }

    maybeShrinkCapacity() {
        if (this.distinct &#x3c; this.lowWater ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix" id="apidoc.element.ml.Math.SparseMatrix">
        function <span class="apidocSignatureSpan">ml.</span>Math.SparseMatrix
        <span class="apidocSignatureSpan">(rows, columns, options = {})</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class SparseMatrix {
    constructor(rows, columns, options = {}) {
        if (rows instanceof SparseMatrix) { // clone
            const other = rows;
            this._init(other.rows, other.columns, other.elements.clone(), other.threshold);
            return;
        }

        if (Array.isArray(rows)) {
            const matrix = rows;
            rows = matrix.length;
            options = columns || {};
            columns = matrix[0].length;
            this._init(rows, columns, new HashTable(options), options.threshold);
            for (var i = 0; i &#x3c; rows; i++) {
                for (var j = 0; j &#x3c; columns; j++) {
                    var value = matrix[i][j];
                    if (this.threshold &#x26;&#x26; Math.abs(value) &#x3c; this.threshold) value = 0;
                    if (value !== 0) {
                        this.elements.set(i * columns + j, matrix[i][j]);
                    }
                }
            }
        } else {
            this._init(rows, columns, new HashTable(options), options.threshold);
        }
    }

    _init(rows, columns, elements, threshold) {
        this.rows = rows;
        this.columns = columns;
        this.elements = elements;
        this.threshold = threshold || 0;
    }

    static eye(rows = 1, columns = rows) {
        const min = Math.min(rows, columns);
        const matrix = new SparseMatrix(rows, columns, {initialCapacity: min});
        for (var i = 0; i &#x3c; min; i++) {
            matrix.set(i, i, 1);
        }
        return matrix;
    }

    clone() {
        return new SparseMatrix(this);
    }

    to2DArray() {
        const copy = new Array(this.rows);
        for (var i = 0; i &#x3c; this.rows; i++) {
            copy[i] = new Array(this.columns);
            for (var j = 0; j &#x3c; this.columns; j++) {
                copy[i][j] = this.get(i, j);
            }
        }
        return copy;
    }

    isSquare() {
        return this.rows === this.columns;
    }

    isSymmetric() {
        if (!this.isSquare()) return false;

        var symmetric = true;
        this.forEachNonZero((i, j, v) =&#x3e; {
            if (this.get(j, i) !== v) {
                symmetric = false;
                return false;
            }
            return v;
        });
        return symmetric;
    }

    get cardinality() {
        return this.elements.size;
    }

    get size() {
        return this.rows * this.columns;
    }

    get(row, column) {
        return this.elements.get(row * this.columns + column);
    }

    set(row, column, value) {
        if (this.threshold &#x26;&#x26; Math.abs(value) &#x3c; this.threshold) value = 0;
        if (value === 0) {
            this.elements.remove(row * this.columns + column);
        } else {
            this.elements.set(row * this.columns + column, value);
        }
        return this;
    }

    mmul(other) {
        if (this.columns !== other.rows)
            console.warn(&#x27;Number of columns of left matrix are not equal to number of rows of right matrix.&#x27;);

        const m = this.rows;
        const p = other.columns;

        const result = new SparseMatrix(m, p);
        this.forEachNonZero((i, j, v1) =&#x3e; {
            other.forEachNonZero((k, l, v2) =&#x3e; {
                if (j === k) {
                    result.set(i, l, result.get(i, l) + v1 * v2);
                }
                return v2;
            });
            return v1;
        });
        return result;
    }

    kroneckerProduct(other) {
        const m = this.rows;
        const n = this.columns;
        const p = other.rows;
        const q = other.columns;

        const result = new SparseMatrix(m * p, n * q, {
            initialCapacity: this.cardinality * other.cardinality
        });
        this.forEachNonZero((i, j, v1) =&#x3e; {
            other.forEachNonZero((k, l, v2) =&#x3e; {
                result.set(p * i + k, q * j + l, v1 * v2);
                return v2;
            });
            return v1;
        });
        return result;
    }

    forEachNonZero(callback) {
        this.elements.forEachPair((key, value) =&#x3e; {
            const i = (k ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Matrix" id="apidoc.element.ml.Matrix">
        function <span class="apidocSignatureSpan">ml.</span>Matrix
        <span class="apidocSignatureSpan">(Array)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Matrix extends abstractMatrix(Array) {
    constructor(nRows, nColumns) {
        var i;
        if (arguments.length === 1 &#x26;&#x26; typeof nRows === &#x27;number&#x27;) {
            return new Array(nRows);
        }
        if (Matrix.isMatrix(nRows)) {
            return nRows.clone();
        } else if (Number.isInteger(nRows) &#x26;&#x26; nRows &#x3e; 0) { // Create an empty matrix
            super(nRows);
            if (Number.isInteger(nColumns) &#x26;&#x26; nColumns &#x3e; 0) {
                for (i = 0; i &#x3c; nRows; i++) {
                    this[i] = new Array(nColumns);
                }
            } else {
                throw new TypeError(&#x27;nColumns must be a positive integer&#x27;);
            }
        } else if (Array.isArray(nRows)) { // Copy the values from the 2D array
            const matrix = nRows;
            nRows = matrix.length;
            nColumns = matrix[0].length;
            if (typeof nColumns !== &#x27;number&#x27; || nColumns === 0) {
                throw new TypeError(&#x27;Data must be a 2D array with at least one element&#x27;);
            }
            super(nRows);
            for (i = 0; i &#x3c; nRows; i++) {
                if (matrix[i].length !== nColumns) {
                    throw new RangeError(&#x27;Inconsistent array dimensions&#x27;);
                }
                this[i] = [].concat(matrix[i]);
            }
        } else {
            throw new TypeError(&#x27;First argument must be a positive number or an array&#x27;);
        }
        this.rows = nRows;
        this.columns = nColumns;
        return this;
    }

    set(rowIndex, columnIndex, value) {
        this[rowIndex][columnIndex] = value;
        return this;
    }

    get(rowIndex, columnIndex) {
        return this[rowIndex][columnIndex];
    }

<span class="apidocCodeCommentSpan">    /**
     * Creates an exact and independent copy of the matrix
     * @return {Matrix}
     */
</span>    clone() {
        var newMatrix = new this.constructor[Symbol.species](this.rows, this.columns);
        for (var row = 0; row &#x3c; this.rows; row++) {
            for (var column = 0; column &#x3c; this.columns; column++) {
                newMatrix.set(row, column, this.get(row, column));
            }
        }
        return newMatrix;
    }

    /**
     * Removes a row from the given index
     * @param {number} index - Row index
     * @return {Matrix} this
     */
    removeRow(index) {
        util.checkRowIndex(this, index);
        if (this.rows === 1) {
            throw new RangeError(&#x27;A matrix cannot have less than one row&#x27;);
        }
        this.splice(index, 1);
        this.rows -= 1;
        return this;
    }

    /**
     * Adds a row at the given index
     * @param {number} [index = this.rows] - Row index
     * @param {Array|Matrix} array - Array or vector
     * @return {Matrix} this
     */
    addRow(index, array) {
        if (array === undefined) {
            array = index;
            index = this.rows;
        }
        util.checkRowIndex(this, index, true);
        array = util.checkRowVector(this, array, true);
        this.splice(index, 0, array);
        this.rows += 1;
        return this;
    }

    /**
     * Removes a column from the given index
     * @param {number} index - Column index
     * @return {Matrix} this
     */
    removeColumn(index) {
        util.checkColumnIndex(this, index);
        if (this.columns === 1) {
            throw new RangeError(&#x27;A matrix cannot have less than one column&#x27;);
        }
        for (var i = 0; i &#x3c; this.rows; i++) {
            this[i].splice(index, 1);
        }
        this.columns -= 1;
        return this;
    }

    /**
     * Adds a column at the given index
     * @param {number} [index = this.columns] - Column index
     * @param {Array|Matrix} array - Array or vector
     * @return {Matrix} this
     */
    addColumn(index, array) {
        if (typeof array === &#x27;undefined&#x27;) {
            array = index;
            index = this.columns;
        }
        util.checkColumnIndex(this, index, true);
        array = util.checkColumnVector(this, array);
        for (var i = 0; i &#x3c; this.rows; i++) {
            this[i].splice(index, 0, array[i]);
        } ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.PadArray" id="apidoc.element.ml.PadArray">
        function <span class="apidocSignatureSpan">ml.</span>PadArray
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function padArray(data, options) {
    options = extend({}, defaultOptions, options);

    if (Array.isArray(data)) {
        if (Array.isArray(data[0]))
            return matrixCase(data, options);
        else
            return arrayCase(data, options);
    }
    else
        throw new TypeError(&#x27;data should be an array&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.SL.KNN" id="apidoc.element.ml.SL.KNN">
        function <span class="apidocSignatureSpan">ml.</span>SL.KNN
        <span class="apidocSignatureSpan">(reload, model)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function KNN(reload, model) {
    if(reload) {
        this.kdtree = model.kdtree;
        this.k = model.k;
        this.classes = model.classes;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.SL.NaiveBayes" id="apidoc.element.ml.SL.NaiveBayes">
        function <span class="apidocSignatureSpan">ml.</span>SL.NaiveBayes
        <span class="apidocSignatureSpan">(reload, model)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function NaiveBayes(reload, model) {
    if(reload) {
        this.means = model.means;
        this.calculateProbabilities = model.calculateProbabilities;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.SL.PLS" id="apidoc.element.ml.SL.PLS">
        function <span class="apidocSignatureSpan">ml.</span>SL.PLS
        <span class="apidocSignatureSpan">(X, Y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class PLS {
    constructor(X, Y) {
        if (X === true) {
            const model = Y;
            this.meanX = model.meanX;
            this.stdDevX = model.stdDevX;
            this.meanY = model.meanY;
            this.stdDevY = model.stdDevY;
            this.PBQ = Matrix.checkMatrix(model.PBQ);
            this.R2X = model.R2X;
        } else {
            if (X.length !== Y.length)
                throw new RangeError(&#x27;The number of X rows must be equal to the number of Y rows&#x27;);

            const resultX = Utils.featureNormalize(X);
            this.X = resultX.result;
            this.meanX = resultX.means;
            this.stdDevX = resultX.std;

            const resultY = Utils.featureNormalize(Y);
            this.Y = resultY.result;
            this.meanY = resultY.means;
            this.stdDevY = resultY.std;
        }
    }

<span class="apidocCodeCommentSpan">    /**
     * Fits the model with the given data and predictions, in this function is calculated the
     * following outputs:
     *
     * T - Score matrix of X
     * P - Loading matrix of X
     * U - Score matrix of Y
     * Q - Loading matrix of Y
     * B - Matrix of regression coefficient
     * W - Weight matrix of X
     *
     * @param {Object} options - recieves the latentVectors and the tolerance of each step of the PLS
     */
</span>    train(options) {
        if(options === undefined) options = {};

        var latentVectors = options.latentVectors;
        if (latentVectors === undefined) {
            latentVectors = Math.min(this.X.length - 1, this.X[0].length);
        }

        var tolerance = options.tolerance;
        if (tolerance === undefined) {
            tolerance = 1e-5;
        }

        var X = this.X;
        var Y = this.Y;

        var rx = X.rows;
        var cx = X.columns;
        var ry = Y.rows;
        var cy = Y.columns;

        var ssqXcal = X.clone().mul(X).sum(); // for the r²
        var sumOfSquaresY = Y.clone().mul(Y).sum();

        var n = latentVectors; //Math.max(cx, cy); // components of the pls
        var T = Matrix.zeros(rx, n);
        var P = Matrix.zeros(cx, n);
        var U = Matrix.zeros(ry, n);
        var Q = Matrix.zeros(cy, n);
        var B = Matrix.zeros(n, n);
        var W = P.clone();
        var k = 0;

        while(Utils.norm(Y) &#x3e; tolerance &#x26;&#x26; k &#x3c; n) {
            var transposeX = X.transpose();
            var transposeY = Y.transpose();

            var tIndex = maxSumColIndex(X.clone().mulM(X));
            var uIndex = maxSumColIndex(Y.clone().mulM(Y));

            var t1 = X.getColumnVector(tIndex);
            var u = Y.getColumnVector(uIndex);
            var t = Matrix.zeros(rx, 1);

            while(Utils.norm(t1.clone().sub(t)) &#x3e; tolerance) {
                var w = transposeX.mmul(u);
                w.div(Utils.norm(w));
                t = t1;
                t1 = X.mmul(w);
                var q = transposeY.mmul(t1);
                q.div(Utils.norm(q));
                u = Y.mmul(q);
            }

            t = t1;
            var num = transposeX.mmul(t);
            var den = (t.transpose().mmul(t))[0][0];
            var p = num.div(den);
            var pnorm = Utils.norm(p);
            p.div(pnorm);
            t.mul(pnorm);
            w.mul(pnorm);

            num = u.transpose().mmul(t);
            den = (t.transpose().mmul(t))[0][0];
            var b = (num.div(den))[0][0];
            X.sub(t.mmul(p.transpose()));
            Y.sub(t.clone().mul(b).mmul(q.transpose()));

            T.setColumn(k, t);
            P.setColumn(k, p);
            U.setColumn(k, u);
            Q.setColumn(k, q);
            W.setColumn(k, w);

            B[k][k] = b;
            k++;
        }

        k--;
        T = T.subMatrix(0, T.rows - 1, 0, k);
        P = P.subMatrix(0, P.rows - 1, 0, k);
        U = U.subMatrix(0, U.rows - 1, 0, k);
        Q = Q.subMatrix(0, Q.rows - 1, 0, k);
        W = W.subMatrix(0, W.rows - 1, 0, k);
        B = B.subMatrix(0, k, 0, k);

        // TODO: review of R2Y
        //this.R2Y = t.transpose().mmul(t).mul(q[k][0]*q[k][0]).divS(ssqYcal)[0][0]; ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.SL.SVM" id="apidoc.element.ml.SL.SVM">
        function <span class="apidocSignatureSpan">ml.</span>SL.SVM
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SVM(options) {
    this.options = Object.assign({}, defaultOptions, options);

    this.kernel = new Kernel(this.options.kernel, this.options.kernelOptions);
    this.b = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.binarySearch" id="apidoc.element.ml.binarySearch">
        function <span class="apidocSignatureSpan">ml.</span>binarySearch
        <span class="apidocSignatureSpan">(haystack, needle, comparator, low, high)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">binarySearch = function (haystack, needle, comparator, low, high) {
  var mid, cmp;

  if(low === undefined)
    low = 0;

  else {
    low = low|0;
    if(low &#x3c; 0 || low &#x3e;= haystack.length)
      throw new RangeError(&#x22;invalid lower bound&#x22;);
  }

  if(high === undefined)
    high = haystack.length - 1;

  else {
    high = high|0;
    if(high &#x3c; low || high &#x3e;= haystack.length)
      throw new RangeError(&#x22;invalid upper bound&#x22;);
  }

  while(low &#x3c;= high) {
<span class="apidocCodeCommentSpan">    /* Note that &#x22;(low + high) &#x3e;&#x3e;&#x3e; 1&#x22; may overflow, and results in a typecast
     * to double (which gives the wrong results). */
</span>    mid = low + (high - low &#x3e;&#x3e; 1);
    cmp = +comparator(haystack[mid], needle, mid, haystack);

    /* Too low. */
    if(cmp &#x3c; 0.0)
      low  = mid + 1;

    /* Too high. */
    else if(cmp &#x3e; 0.0)
      high = mid - 1;

    /* Key found. */
    else
      return mid;
  }

  /* Key not found. */
  return ~low;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.nn.SOM" id="apidoc.element.ml.nn.SOM">
        function <span class="apidocSignatureSpan">ml.</span>nn.SOM
        <span class="apidocSignatureSpan">(x, y, options, reload)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SOM(x, y, options, reload) {

    this.x = x;
    this.y = y;

    options = options || {};
    this.options = {};
    for (var i in defaultOptions) {
        if (options.hasOwnProperty(i)) {
            this.options[i] = options[i];
        } else {
            this.options[i] = defaultOptions[i];
        }
    }

    if (typeof this.options.fields === &#x27;number&#x27;) {
        this.numWeights = this.options.fields;
    } else if (Array.isArray(this.options.fields)) {
        this.numWeights = this.options.fields.length;
        var converters = getConverters(this.options.fields);
        this.extractor = converters.extractor;
        this.creator = converters.creator;
    } else {
        throw new Error(&#x27;Invalid fields definition&#x27;);
    }

    if (this.options.gridType === &#x27;rect&#x27;) {
        this.nodeType = NodeSquare;
        this.gridDim = {
            x: x,
            y: y
        };
    } else {
        this.nodeType = NodeHexagonal;
        var hx = this.x - Math.floor(this.y / 2);
        this.gridDim = {
            x: hx,
            y: this.y,
            z: -(0 - hx - this.y)
        };
    }

    this.torus = this.options.torus;
    this.distanceMethod = this.torus ? &#x27;getDistanceTorus&#x27; : &#x27;getDistance&#x27;;

    this.distance = this.options.distance;

    this.maxDistance = getMaxDistance(this.distance, this.numWeights);

    if (reload === true) { // For model loading
        this.done = true;
        return;
    }
    if (!(x &#x3e; 0 &#x26;&#x26; y &#x3e; 0)) {
        throw new Error(&#x27;x and y must be positive&#x27;);
    }

    this.times = {
        findBMU: 0,
        adjust: 0
    };

    this.randomizer = this.options.randomizer;

    this.iterationCount = 0;
    this.iterations = this.options.iterations;

    this.startLearningRate = this.learningRate = this.options.learningRate;

    this.mapRadius = Math.floor(Math.max(x, y) / 2);

    this.algorithmMethod = this.options.method;

    this._initNodes();

    this.done = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






































































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ml.AU" id="apidoc.module.ml.AU">module ml.AU</a></h1>


    <h2>
        <a href="#apidoc.element.ml.AU.SNV" id="apidoc.element.ml.AU.SNV">
        function <span class="apidocSignatureSpan">ml.AU.</span>SNV
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SNV(data) {
    var mean = Stat.mean(data);
    var std = Stat.standardDeviation(data);
    var result = data.slice();
    for (var i = 0; i &#x3c; data.length; i++) {
        result[i] = (result[i] - mean) / std;
    }
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.AU.applyDotProduct" id="apidoc.element.ml.AU.applyDotProduct">
        function <span class="apidocSignatureSpan">ml.AU.</span>applyDotProduct
        <span class="apidocSignatureSpan">(firstVector, secondVector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function applyDotProduct(firstVector, secondVector) {
    var largestVector, smallestVector;
    if(firstVector.length &#x3c;= secondVector.length) {
        smallestVector = firstVector;
        largestVector = secondVector;
    } else {
        smallestVector = secondVector;
        largestVector = firstVector;
    }

    var difference = largestVector.length - smallestVector.length + 1;
    var dotProductApplied = new Array(difference);

    for (var i = 0; i &#x3c; difference; ++i) {
        var sum = 0;
        for (var j = 0; j &#x3c; smallestVector.length; ++j) {
            sum += smallestVector[j] * largestVector[i + j];
        }
        dotProductApplied[i] = sum;
    }

    return dotProductApplied;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.AU.coordArrayToCoordMatrix" id="apidoc.element.ml.AU.coordArrayToCoordMatrix">
        function <span class="apidocSignatureSpan">ml.AU.</span>coordArrayToCoordMatrix
        <span class="apidocSignatureSpan">(array, dimensions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function coordArrayToCoordMatrix(array, dimensions) {
    if(array.length % dimensions !== 0) {
        throw new RangeError(&#x27;Dimensions number must be accordance with the size of the array.&#x27;);
    }

    var coordinatesArray = new Array(dimensions);
    var points = array.length / dimensions;
    for (var i = 0; i &#x3c; coordinatesArray.length; i++) {
        coordinatesArray[i] = new Array(points);
    }

    for(i = 0; i &#x3c; array.length; i += dimensions) {
        for(var j = 0; j &#x3c; dimensions; ++j) {
            var currentPoint = Math.floor(i / dimensions);
            coordinatesArray[j][currentPoint] = array[i + j];
        }
    }

    return coordinatesArray;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.AU.coordArrayToPoints" id="apidoc.element.ml.AU.coordArrayToPoints">
        function <span class="apidocSignatureSpan">ml.AU.</span>coordArrayToPoints
        <span class="apidocSignatureSpan">(array, dimensions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function coordArrayToPoints(array, dimensions) {
    if(array.length % dimensions !== 0) {
        throw new RangeError(&#x27;Dimensions number must be accordance with the size of the array.&#x27;);
    }

    var length = array.length / dimensions;
    var pointsArr = new Array(length);

    var k = 0;
    for(var i = 0; i &#x3c; array.length; i += dimensions) {
        var point = new Array(dimensions);
        for(var j = 0; j &#x3c; dimensions; ++j) {
            point[j] = array[i + j];
        }

        pointsArr[k] = point;
        k++;
    }

    return pointsArr;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.AU.coordMatrixToCoordArray" id="apidoc.element.ml.AU.coordMatrixToCoordArray">
        function <span class="apidocSignatureSpan">ml.AU.</span>coordMatrixToCoordArray
        <span class="apidocSignatureSpan">(coordMatrix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function coordMatrixToCoordArray(coordMatrix) {
    var coodinatesArray = new Array(coordMatrix.length * coordMatrix[0].length);
    var k = 0;
    for(var i = 0; i &#x3c; coordMatrix[0].length; ++i) {
        for(var j = 0; j &#x3c; coordMatrix.length; ++j) {
            coodinatesArray[k] = coordMatrix[j][i];
            ++k;
        }
    }

    return coodinatesArray;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.AU.coordMatrixToPoints" id="apidoc.element.ml.AU.coordMatrixToPoints">
        function <span class="apidocSignatureSpan">ml.AU.</span>coordMatrixToPoints
        <span class="apidocSignatureSpan">(matrix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function transpose(matrix) {
    var resultMatrix = new Array(matrix[0].length);
    for(var i = 0; i &#x3c; resultMatrix.length; ++i) {
        resultMatrix[i] = new Array(matrix.length);
    }

    for (i = 0; i &#x3c; matrix.length; ++i) {
        for(var j = 0; j &#x3c; matrix[0].length; ++j) {
            resultMatrix[j][i] = matrix[i][j];
        }
    }

    return resultMatrix;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.AU.getEquallySpacedData" id="apidoc.element.ml.AU.getEquallySpacedData">
        function <span class="apidocSignatureSpan">ml.AU.</span>getEquallySpacedData
        <span class="apidocSignatureSpan">(x, y, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getEquallySpacedData(x, y, options) {
    if (x.length&#x3e;1 &#x26;&#x26; x[0]&#x3e;x[1]) {
        x=x.slice().reverse();
        y=y.slice().reverse();
    }

    var xLength = x.length;
    if(xLength !== y.length)
        throw new RangeError(&#x22;the x and y vector doesn&#x27;t have the same size.&#x22;);

    if (options === undefined) options = {};

    var from = options.from === undefined ? x[0] : options.from
    if (isNaN(from) || !isFinite(from)) {
        throw new RangeError(&#x22;&#x27;From&#x27; value must be a number&#x22;);
    }
    var to = options.to === undefined ? x[x.length - 1] : options.to;
    if (isNaN(to) || !isFinite(to)) {
        throw new RangeError(&#x22;&#x27;To&#x27; value must be a number&#x22;);
    }

    var reverse = from &#x3e; to;
    if(reverse) {
        var temp = from;
        from = to;
        to = temp;
    }

    var numberOfPoints = options.numberOfPoints === undefined ? 100 : options.numberOfPoints;
    if (isNaN(numberOfPoints) || !isFinite(numberOfPoints)) {
        throw new RangeError(&#x22;&#x27;Number of points&#x27; value must be a number&#x22;);
    }
    if(numberOfPoints &#x3c; 1)
        throw new RangeError(&#x22;the number of point must be higher than 1&#x22;);

    var algorithm = options.variant === &#x22;slot&#x22; ? &#x22;slot&#x22; : &#x22;smooth&#x22;; // default value: smooth

    var output = algorithm === &#x22;slot&#x22; ? getEquallySpacedSlot(x, y, from, to, numberOfPoints) : getEquallySpacedSmooth(x, y, from
, to, numberOfPoints);

    return reverse ? output.reverse() : output;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.AU.pointsToCoordArray" id="apidoc.element.ml.AU.pointsToCoordArray">
        function <span class="apidocSignatureSpan">ml.AU.</span>pointsToCoordArray
        <span class="apidocSignatureSpan">(points)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function pointsToCoordArray(points) {
    var coodinatesArray = new Array(points.length * points[0].length);
    var k = 0;
    for(var i = 0; i &#x3c; points.length; ++i) {
        for(var j = 0; j &#x3c; points[0].length; ++j) {
            coodinatesArray[k] = points[i][j];
            ++k;
        }
    }

    return coodinatesArray;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.AU.pointsToCoordMatrix" id="apidoc.element.ml.AU.pointsToCoordMatrix">
        function <span class="apidocSignatureSpan">ml.AU.</span>pointsToCoordMatrix
        <span class="apidocSignatureSpan">(matrix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function transpose(matrix) {
    var resultMatrix = new Array(matrix[0].length);
    for(var i = 0; i &#x3c; resultMatrix.length; ++i) {
        resultMatrix[i] = new Array(matrix.length);
    }

    for (i = 0; i &#x3c; matrix.length; ++i) {
        for(var j = 0; j &#x3c; matrix[0].length; ++j) {
            resultMatrix[j][i] = matrix[i][j];
        }
    }

    return resultMatrix;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.AU.scale" id="apidoc.element.ml.AU.scale">
        function <span class="apidocSignatureSpan">ml.AU.</span>scale
        <span class="apidocSignatureSpan">(input, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function scale(input, options){
    var y;
    if(options.inPlace){
        y = input;
    }
    else{
        y = new Array(input.length);
    }
    const max = options.max;
    const min = options.min;
    if(typeof max === &#x22;number&#x22;){
        if(typeof min === &#x22;number&#x22;){
            var minMax = Stat.minMax(input);
            var factor = (max - min)/(minMax.max-minMax.min);
            for(var i=0;i&#x3c; y.length;i++){
                y[i]=(input[i]-minMax.min)*factor+min;
            }
        }
        else{
            var currentMin = Stat.max(input);
            var factor = max/currentMin;
            for(var i=0;i&#x3c; y.length;i++){
                y[i] = input[i]*factor;
            }
        }
    }
    else{
        if(typeof min === &#x22;number&#x22;){
            var currentMin = Stat.min(input);
            var factor = min/currentMin;
            for(var i=0;i&#x3c; y.length;i++){
                y[i] = input[i]*factor;
            }
        }
    }
    return y;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ml.BitArray" id="apidoc.module.ml.BitArray">module ml.BitArray</a></h1>


    <h2>
        <a href="#apidoc.element.ml.BitArray.and" id="apidoc.element.ml.BitArray.and">
        function <span class="apidocSignatureSpan">ml.BitArray.</span>and
        <span class="apidocSignatureSpan">(arr1, arr2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function and(arr1, arr2) {
    var ans = new Array(arr1.length);
    for (var i = 0; i &#x3c; arr1.length; i++)
        ans[i] = arr1[i] &#x26; arr2[i];
    return ans;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.BitArray.count" id="apidoc.element.ml.BitArray.count">
        function <span class="apidocSignatureSpan">ml.BitArray.</span>count
        <span class="apidocSignatureSpan">(arr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function count(arr) {
    var c = 0;
    for (var i = 0; i &#x3c; arr.length; i++) {
        c += eightBits[arr[i] &#x26; 0xff] + eightBits[(arr[i] &#x3e;&#x3e; 8) &#x26; 0xff] + eightBits[(arr[i] &#x3e;&#x3e; 16) &#x26; 0xff] + eightBits[(arr[i] &#x3e;&#x3e;
24) &#x26; 0xff];
    }
    return c;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.BitArray.getBit" id="apidoc.element.ml.BitArray.getBit">
        function <span class="apidocSignatureSpan">ml.BitArray.</span>getBit
        <span class="apidocSignatureSpan">(arr, n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getBit(arr, n) {
    var index = n &#x3e;&#x3e; 5; // Same as Math.floor(n/32)
    var mask = 1 &#x3c;&#x3c; (31 - n % 32);
    return Boolean(arr[index] &#x26; mask);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.BitArray.not" id="apidoc.element.ml.BitArray.not">
        function <span class="apidocSignatureSpan">ml.BitArray.</span>not
        <span class="apidocSignatureSpan">(arr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function not(arr) {
    var ans = new Array(arr.length);
    for (var i = 0; i &#x3c; ans.length; i++)
        ans[i] = ~arr[i];
    return ans;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.BitArray.or" id="apidoc.element.ml.BitArray.or">
        function <span class="apidocSignatureSpan">ml.BitArray.</span>or
        <span class="apidocSignatureSpan">(arr1, arr2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function or(arr1, arr2) {
    var ans = new Array(arr1.length);
    for (var i = 0; i &#x3c; arr1.length; i++)
        ans[i] = arr1[i] | arr2[i];
    return ans;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.BitArray.parseBinaryString" id="apidoc.element.ml.BitArray.parseBinaryString">
        function <span class="apidocSignatureSpan">ml.BitArray.</span>parseBinaryString
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parseBinaryString(str) {
    var len = str.length / 32;
    var ans = new Array(len);
    for (var i = 0; i &#x3c; len; i++) {
        ans[i] = parseInt(str.substr(i*32, 32), 2) | 0;
    }
    return ans;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.BitArray.parseHexString" id="apidoc.element.ml.BitArray.parseHexString">
        function <span class="apidocSignatureSpan">ml.BitArray.</span>parseHexString
        <span class="apidocSignatureSpan">(str)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parseHexString(str) {
    var len = str.length / 8;
    var ans = new Array(len);
    for (var i = 0; i &#x3c; len; i++) {
        ans[i] = parseInt(str.substr(i*8, 8), 16) | 0;
    }
    return ans;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.BitArray.setBit" id="apidoc.element.ml.BitArray.setBit">
        function <span class="apidocSignatureSpan">ml.BitArray.</span>setBit
        <span class="apidocSignatureSpan">(arr, n, val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setBit(arr, n, val) {
    var index = n &#x3e;&#x3e; 5; // Same as Math.floor(n/32)
    var mask = 1 &#x3c;&#x3c; (31 - n % 32);
    if (val)
        arr[index] = mask | arr[index];
    else
        arr[index] = ~mask &#x26; arr[index];
    return arr;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.BitArray.toBinaryString" id="apidoc.element.ml.BitArray.toBinaryString">
        function <span class="apidocSignatureSpan">ml.BitArray.</span>toBinaryString
        <span class="apidocSignatureSpan">(arr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toBinaryString(arr) {
    var str = &#x27;&#x27;;
    for (var i = 0; i &#x3c; arr.length; i++) {
        var obj = (arr[i] &#x3e;&#x3e;&#x3e; 0).toString(2);
        str += &#x27;00000000000000000000000000000000&#x27;.substr(obj.length) + obj;
    }
    return str;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.BitArray.toDebug" id="apidoc.element.ml.BitArray.toDebug">
        function <span class="apidocSignatureSpan">ml.BitArray.</span>toDebug
        <span class="apidocSignatureSpan">(arr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toDebug(arr) {
    var binary = toBinaryString(arr);
    var str = &#x27;&#x27;;
    for (var i = 0; i &#x3c; arr.length; i++) {
        str += &#x27;0000&#x27;.substr((i * 32).toString(16).length) + (i * 32).toString(16) + &#x27;:&#x27;;
        for (var j = 0; j &#x3c; 32; j += 4) {
            str += &#x27; &#x27; + binary.substr(i * 32 + j, 4);
        }
        if (i &#x3c; arr.length - 1) str += &#x27;\n&#x27;;
    }
    return str
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.BitArray.toHexString" id="apidoc.element.ml.BitArray.toHexString">
        function <span class="apidocSignatureSpan">ml.BitArray.</span>toHexString
        <span class="apidocSignatureSpan">(arr)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toHexString(arr) {
    var str = &#x27;&#x27;;
    for (var i = 0; i &#x3c; arr.length; i++) {
        var obj = (arr[i] &#x3e;&#x3e;&#x3e; 0).toString(16);
        str += &#x27;00000000&#x27;.substr(obj.length) + obj;
    }
    return str;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.BitArray.xor" id="apidoc.element.ml.BitArray.xor">
        function <span class="apidocSignatureSpan">ml.BitArray.</span>xor
        <span class="apidocSignatureSpan">(arr1, arr2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function xor(arr1, arr2) {
    var ans = new Array(arr1.length);
    for (var i = 0; i &#x3c; arr1.length; i++)
        ans[i] = arr1[i] ^ arr2[i];
    return ans;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ml.Clust" id="apidoc.module.ml.Clust">module ml.Clust</a></h1>


    <h2>
        <a href="#apidoc.element.ml.Clust.kmeans" id="apidoc.element.ml.Clust.kmeans">
        function <span class="apidocSignatureSpan">ml.Clust.</span>kmeans
        <span class="apidocSignatureSpan">(data, K, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function kmeans(data, K, options) {
    options = Object.assign({}, defaultOptions, options);

    if (K &#x3c;= 0 || K &#x3e; data.length || !Number.isInteger(K)) {
        throw new Error(&#x27;K should be a positive integer bigger than the number of points&#x27;);
    }

    var centers;
    if (Array.isArray(options.initialization)) {
        if (options.initialization.length !== K) {
            throw new Error(&#x27;The initial centers should have the same length as K&#x27;);
        } else {
            centers = options.initialization;
        }
    } else {
        switch (options.initialization) {
            case &#x27;random&#x27;:
                centers = init.random(data, K);
                break;
            case &#x27;mostDistant&#x27;:
                centers = init.mostDistant(data, K, utils.calculateDistanceMatrix(data, options.distanceFunction));
                break;
            default:
                throw new Error(&#x27;Unknown initialization method: &#x22;&#x27; + options.initialization + &#x27;&#x22;&#x27;);
        }
    }

    // infinite loop until convergence
    if (options.maxIterations === 0) {
        options.maxIterations = Number.MAX_VALUE;
    }

    var clusterID = new Array(data.length);
    if (options.withIterations) {
        return kmeansGenerator(centers, data, clusterID, K, options);
    } else {
        var converged = false;
        var stepNumber = 0;
        var stepResult;
        while (!converged &#x26;&#x26; (stepNumber &#x3c; options.maxIterations)) {
            stepResult = step(centers, data, clusterID, K, options, ++stepNumber);
            converged = stepResult.converged;
            centers = stepResult.centroids;
        }
        return stepResult.computeInformation(data);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ml.Clust.hclust" id="apidoc.module.ml.Clust.hclust">module ml.Clust.hclust</a></h1>


    <h2>
        <a href="#apidoc.element.ml.Clust.hclust.agnes" id="apidoc.element.ml.Clust.hclust.agnes">
        function <span class="apidocSignatureSpan">ml.Clust.hclust.</span>agnes
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function agnes(data, options) {
    options = Object.assign({}, defaultOptions, options);
    var len = data.length;
    var distance = data;//If source
    if (!options.isDistanceMatrix) {
        distance = distanceMatrix(data, options.disFunc);
    }


    // allows to use a string or a given function
    if (typeof options.kind === &#x27;string&#x27;) {
        switch (options.kind) {
            case &#x27;single&#x27;:
                options.kind = simpleLink;
                break;
            case &#x27;complete&#x27;:
                options.kind = completeLink;
                break;
            case &#x27;average&#x27;:
                options.kind = averageLink;
                break;
            case &#x27;centroid&#x27;:
                options.kind = centroidLink;
                break;
            case &#x27;ward&#x27;:
                options.kind = wardLink;
                break;
            default:
                throw new RangeError(&#x27;Unknown kind of similarity&#x27;);
        }
    } else if (typeof options.kind !== &#x27;function&#x27;) {
        throw new TypeError(&#x27;Undefined kind of similarity&#x27;);
    }

    var list = new Array(len);
    for (var i = 0; i &#x3c; distance.length; i++) {
        list[i] = new ClusterLeaf(i);
    }
    var min = 10e5,
        d = {},
        dis = 0;

    while (list.length &#x3e; 1) {
        // calculates the minimum distance
        d = {};
        min = 10e5;
        for (var j = 0; j &#x3c; list.length; j++) {
            for (var k = j + 1; k &#x3c; list.length; k++) {
                var fdistance, sdistance;
                if (list[j] instanceof ClusterLeaf) {
                    fdistance = [list[j].index];
                } else {
                    fdistance = new Array(list[j].index.length);
                    for (var e = 0; e &#x3c; fdistance.length; e++) {
                        fdistance[e] = list[j].index[e].index;
                    }
                }
                if (list[k] instanceof ClusterLeaf) {
                    sdistance = [list[k].index];
                } else {
                    sdistance = new Array(list[k].index.length);
                    for (var f = 0; f &#x3c; sdistance.length; f++) {
                        sdistance[f] = list[k].index[f].index;
                    }
                }
                dis = options.kind(fdistance, sdistance, distance).toFixed(4);
                if (dis in d) {
                    d[dis].push([list[j], list[k]]);
                } else {
                    d[dis] = [[list[j], list[k]]];
                }
                min = Math.min(dis, min);
            }
        }
        // cluster dots
        var dmin = d[min.toFixed(4)];
        var clustered = new Array(dmin.length);
        var aux,
            count = 0;
        while (dmin.length &#x3e; 0) {
            aux = dmin.shift();
            for (var q = 0; q &#x3c; dmin.length; q++) {
                var int = dmin[q].filter(function (n) {
                    //noinspection JSReferencingMutableVariableFromClosure
                    return aux.indexOf(n) !== -1;
                });
                if (int.length &#x3e; 0) {
                    var diff = dmin[q].filter(function (n) {
                        //noinspection JSReferencingMutableVariableFromClosure
                        return aux.indexOf(n) === -1;
                    });
                    aux = aux.concat(diff);
                    dmin.splice(q--, 1);
                }
            }
            clustered[count++] = aux;
        }
        clustered.length = count;

        for (var ii = 0; ii &#x3c; clustered.length; ii++) {
            var obj = new Cluster();
            obj.children = clustered[ii].concat();
            obj.distance = min;
            obj.index = new Array(len);
            var indCount = 0;
            for (var jj = 0; jj &#x3c; clustered[ii].length; jj++) {
                if (clustered[ii][jj] instanceof ClusterLeaf) {
                    obj.index[indCount++] = clustered[ii][jj];
                } else {
                    indCount += clustered[ii][jj].index.length;
                    obj.index = clustered[ii][jj].index.concat(obj.index);
                } ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Clust.hclust.diana" id="apidoc.element.ml.Clust.hclust.diana">
        function <span class="apidocSignatureSpan">ml.Clust.hclust.</span>diana
        <span class="apidocSignatureSpan">(data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function diana(data, options) {
    options = Object.assign({}, defaultOptions, options);
    if (typeof options.kind === &#x27;string&#x27;) {
        switch (options.kind) {
            case &#x27;single&#x27;:
                options.kind = simpleLink;
                break;
            case &#x27;complete&#x27;:
                options.kind = completeLink;
                break;
            case &#x27;average&#x27;:
                options.kind = averageLink;
                break;
            case &#x27;centroid&#x27;:
                options.kind = centroidLink;
                break;
            case &#x27;ward&#x27;:
                options.kind = wardLink;
                break;
            default:
                throw new RangeError(&#x27;Unknown kind of similarity&#x27;);
        }
    } else if (typeof options.kind !== &#x27;function&#x27;) {
        throw new TypeError(&#x27;Undefined kind of similarity&#x27;);
    }
    var tree = new Cluster();
    tree.children = new Array(data.length);
    tree.index = new Array(data.length);
    for (var ind = 0; ind &#x3c; data.length; ind++) {
        tree.children[ind] = new ClusterLeaf(ind);
        tree.index[ind] = new ClusterLeaf(ind);
    }

    tree.distance = intrDist(tree.index, data, options.dist);
    var m, M, clId,
        dist, rebel;
    var list = [tree];
    while (list.length &#x3e; 0) {
        M = 0;
        clId = 0;
        for (var i = 0; i &#x3c; list.length; i++) {
            m = 0;
            for (var j = 0; j &#x3c; list[i].length; j++) {
                for (var l = (j + 1); l &#x3c; list[i].length; l++) {
                    m = Math.max(options.dist(data[list[i].index[j].index], data[list[i].index[l].index]), m);
                }
            }
            if (m &#x3e; M) {
                M = m;
                clId = i;
            }
        }
        M = 0;
        if (list[clId].index.length === 2) {
            list[clId].children = [list[clId].index[0], list[clId].index[1]];
            list[clId].distance = options.dist(data[list[clId].index[0].index], data[list[clId].index[1].index]);
        } else if (list[clId].index.length === 3) {
            list[clId].children = [list[clId].index[0], list[clId].index[1], list[clId].index[2]];
            var d = [
                options.dist(data[list[clId].index[0].index], data[list[clId].index[1].index]),
                options.dist(data[list[clId].index[1].index], data[list[clId].index[2].index])
            ];
            list[clId].distance = (d[0] + d[1]) / 2;
        } else {
            var C = new Cluster();
            var sG = new Cluster();
            var splitting = [new Array(list[clId].index.length), []];
            for (var spl = 0; spl &#x3c; splitting[0].length; spl++) {
                splitting[0][spl] = spl;
            }
            for (var ii = 0; ii &#x3c; splitting[0].length; ii++) {
                dist = 0;
                for (var jj = 0; jj &#x3c; splitting[0].length; jj++) {
                    if (ii !== jj) {
                        dist += options.dist(data[list[clId].index[splitting[0][jj]].index], data[list[clId].index[splitting[0][
ii]].index]);
                    }
                }
                dist /= (splitting[0].length - 1);
                if (dist &#x3e; M) {
                    M = dist;
                    rebel = ii;
                }
            }
            splitting[1] = [rebel];
            splitting[0].splice(rebel, 1);
            dist = diff(splitting, data, options.dist);
            while (dist.d &#x3e; 0) {
                splitting[1].push(splitting[0][dist.p]);
                splitting[0].splice(dist.p, 1);
                dist = diff(splitting, data, options.dist);
            }
            var fData = new Array(splitting[0].length);
            C.index = new Array(splitting[0].length);
            for (var e = 0; e &#x3c; fData.length; e++) {
                fData[e] = data[list[clId].index[splitting[0][e]].index];
                C.index[e] = list[clId].index[splitting[0][e]];
                C.children[e] = list[clId].index[splitting[0][e]];
            }
            var sData = new Array(splitting[1].length);
            sG.index = new Array(splitting[1].lengt ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ml.Math" id="apidoc.module.ml.Math">module ml.Math</a></h1>


    <h2>
        <a href="#apidoc.element.ml.Math.DistanceMatrix" id="apidoc.element.ml.Math.DistanceMatrix">
        function <span class="apidocSignatureSpan">ml.Math.</span>DistanceMatrix
        <span class="apidocSignatureSpan">(data, distanceFn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function distanceMatrix(data, distanceFn) {
    const length = data.length;
    let result = Array.from({length}).map(() =&#x3e; Array.from({length}));

    // Compute upper distance matrix
    for (let i = 0; i &#x3c; length; i++) {
        for (let j = 0; j &#x3c;= i; j++) {
            result[i][j] = distanceFn(data[i], data[j]);
        }
    }

    // Copy to lower distance matrix
    for (let i = 0; i &#x3c; length; i++) {
        for (let j = i + 1; j &#x3c; length; j++) {
            result[i][j] = result[j][i];
        }
    }

    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.Kernel" id="apidoc.element.ml.Math.Kernel">
        function <span class="apidocSignatureSpan">ml.Math.</span>Kernel
        <span class="apidocSignatureSpan">(type, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Kernel {
    constructor(type, options) {
        this.kernelType = type;
        if (type === &#x27;linear&#x27;) return;

        if (typeof type === &#x27;string&#x27;) {
            type = type.toLowerCase();

            var KernelConstructor = kernelType[type];
            if (KernelConstructor) {
                this.kernelFunction = new KernelConstructor(options);
            } else {
                throw new Error(&#x27;unsupported kernel type: &#x27; + type);
            }
        } else if (typeof type === &#x27;object&#x27; &#x26;&#x26; typeof type.compute === &#x27;function&#x27;) {
            this.kernelFunction = type;
        } else {
            throw new TypeError(&#x27;first argument must be a valid kernel type or instance&#x27;);
        }
    }

    compute(inputs, landmarks) {
        if (landmarks === undefined) {
            landmarks = inputs;
        }

        if (this.kernelType === &#x27;linear&#x27;) {
            var matrix = new Matrix(inputs);
            return matrix.mmul(new Matrix(landmarks).transpose());
        }

        const kernelMatrix = new Matrix(inputs.length, landmarks.length);
        var i, j;
        if (inputs === landmarks) { // fast path, matrix is symmetric
            for (i = 0; i &#x3c; inputs.length; i++) {
                for (j = i; j &#x3c; inputs.length; j++) {
                    kernelMatrix[i][j] = kernelMatrix[j][i] = this.kernelFunction.compute(inputs[i], inputs[j]);
                }
            }
        } else {
            for (i = 0; i &#x3c; inputs.length; i++) {
                for (j = 0; j &#x3c; landmarks.length; j++) {
                    kernelMatrix[i][j] = this.kernelFunction.compute(inputs[i], landmarks[j]);
                }
            }
        }
        return kernelMatrix;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.Matrix" id="apidoc.element.ml.Math.Matrix">
        function <span class="apidocSignatureSpan">ml.Math.</span>Matrix
        <span class="apidocSignatureSpan">(Array)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Matrix extends abstractMatrix(Array) {
    constructor(nRows, nColumns) {
        var i;
        if (arguments.length === 1 &#x26;&#x26; typeof nRows === &#x27;number&#x27;) {
            return new Array(nRows);
        }
        if (Matrix.isMatrix(nRows)) {
            return nRows.clone();
        } else if (Number.isInteger(nRows) &#x26;&#x26; nRows &#x3e; 0) { // Create an empty matrix
            super(nRows);
            if (Number.isInteger(nColumns) &#x26;&#x26; nColumns &#x3e; 0) {
                for (i = 0; i &#x3c; nRows; i++) {
                    this[i] = new Array(nColumns);
                }
            } else {
                throw new TypeError(&#x27;nColumns must be a positive integer&#x27;);
            }
        } else if (Array.isArray(nRows)) { // Copy the values from the 2D array
            const matrix = nRows;
            nRows = matrix.length;
            nColumns = matrix[0].length;
            if (typeof nColumns !== &#x27;number&#x27; || nColumns === 0) {
                throw new TypeError(&#x27;Data must be a 2D array with at least one element&#x27;);
            }
            super(nRows);
            for (i = 0; i &#x3c; nRows; i++) {
                if (matrix[i].length !== nColumns) {
                    throw new RangeError(&#x27;Inconsistent array dimensions&#x27;);
                }
                this[i] = [].concat(matrix[i]);
            }
        } else {
            throw new TypeError(&#x27;First argument must be a positive number or an array&#x27;);
        }
        this.rows = nRows;
        this.columns = nColumns;
        return this;
    }

    set(rowIndex, columnIndex, value) {
        this[rowIndex][columnIndex] = value;
        return this;
    }

    get(rowIndex, columnIndex) {
        return this[rowIndex][columnIndex];
    }

<span class="apidocCodeCommentSpan">    /**
     * Creates an exact and independent copy of the matrix
     * @return {Matrix}
     */
</span>    clone() {
        var newMatrix = new this.constructor[Symbol.species](this.rows, this.columns);
        for (var row = 0; row &#x3c; this.rows; row++) {
            for (var column = 0; column &#x3c; this.columns; column++) {
                newMatrix.set(row, column, this.get(row, column));
            }
        }
        return newMatrix;
    }

    /**
     * Removes a row from the given index
     * @param {number} index - Row index
     * @return {Matrix} this
     */
    removeRow(index) {
        util.checkRowIndex(this, index);
        if (this.rows === 1) {
            throw new RangeError(&#x27;A matrix cannot have less than one row&#x27;);
        }
        this.splice(index, 1);
        this.rows -= 1;
        return this;
    }

    /**
     * Adds a row at the given index
     * @param {number} [index = this.rows] - Row index
     * @param {Array|Matrix} array - Array or vector
     * @return {Matrix} this
     */
    addRow(index, array) {
        if (array === undefined) {
            array = index;
            index = this.rows;
        }
        util.checkRowIndex(this, index, true);
        array = util.checkRowVector(this, array, true);
        this.splice(index, 0, array);
        this.rows += 1;
        return this;
    }

    /**
     * Removes a column from the given index
     * @param {number} index - Column index
     * @return {Matrix} this
     */
    removeColumn(index) {
        util.checkColumnIndex(this, index);
        if (this.columns === 1) {
            throw new RangeError(&#x27;A matrix cannot have less than one column&#x27;);
        }
        for (var i = 0; i &#x3c; this.rows; i++) {
            this[i].splice(index, 1);
        }
        this.columns -= 1;
        return this;
    }

    /**
     * Adds a column at the given index
     * @param {number} [index = this.columns] - Column index
     * @param {Array|Matrix} array - Array or vector
     * @return {Matrix} this
     */
    addColumn(index, array) {
        if (typeof array === &#x27;undefined&#x27;) {
            array = index;
            index = this.columns;
        }
        util.checkColumnIndex(this, index, true);
        array = util.checkColumnVector(this, array);
        for (var i = 0; i &#x3c; this.rows; i++) {
            this[i].splice(index, 0, array[i]);
        } ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SG" id="apidoc.element.ml.Math.SG">
        function <span class="apidocSignatureSpan">ml.Math.</span>SG
        <span class="apidocSignatureSpan">(data, h, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SavitzkyGolay(data, h, options) {
    options = extend({}, defaultOptions, options);
    if ((options.windowSize % 2 === 0) || (options.windowSize &#x3c; 5) || !(Number.isInteger(options.windowSize)))
        throw new RangeError(&#x27;Invalid window size (should be odd and at least 5 integer number)&#x27;);
    if ((options.derivative &#x3c; 0) || !(Number.isInteger(options.derivative)))
        throw new RangeError(&#x27;Derivative should be a positive integer&#x27;);
    if ((options.polynomial &#x3c; 1) || !(Number.isInteger(options.polynomial)))
        throw new RangeError(&#x27;Polynomial should be a positive integer&#x27;);

    var C, norm;
    var step = Math.floor(options.windowSize / 2);

    if (options.pad === &#x27;pre&#x27;) {
        data = padArray(data, {size: step, value: options.padValue});
    }

    var ans =  new Array(data.length - 2*step);

    if ((options.windowSize === 5) &#x26;&#x26; (options.polynomial === 2) &#x26;&#x26; ((options.derivative === 1) || (options.derivative === 2))) {
        if (options.derivative === 1) {
            C = [-2,-1,0,1,2];
            norm = 10;
        }
        else {
            C = [2, -1, -2, -1, 2];
            norm = 7;
        }
    }
    else {
        var J = Matrix.ones(options.windowSize, options.polynomial + 1);
        var inic = -(options.windowSize - 1) / 2;
        for (var i = 0; i &#x3c; J.length; i++) {
            for (var j = 0; j &#x3c; J[i].length; j++) {
                if ((inic + 1 !== 0) || (j !== 0))
                    J[i][j] = Math.pow((inic + i), j);
            }
        }
        var Jtranspose = J.transposeView();
        var Jinv = (Jtranspose.mmul(J)).inverse();
        C = Jinv.mmul(Jtranspose);
        C = C[options.derivative];
        norm = 1;
    }
    var det = norm * Math.pow(h, options.derivative);
    for (var k = step; k &#x3c; (data.length - step); k++) {
        var d = 0;
        for (var l = 0; l &#x3c; C.length; l++)
            d += C[l] * data[l + k - step] / det;
        ans[k - step] = d;
    }

    if (options.pad === &#x27;post&#x27;) {
        ans = padArray(ans, {size: step, value: options.padValue});
    }

    return ans;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SGG" id="apidoc.element.ml.Math.SGG">
        function <span class="apidocSignatureSpan">ml.Math.</span>SGG
        <span class="apidocSignatureSpan">(data, h, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SavitzkyGolay(data, h, options) {
    options = extend({}, defaultOptions, options);

    if ((options.windowSize % 2 === 0) || (options.windowSize &#x3c; 5) || !(Number.isInteger(options.windowSize)))
            throw new RangeError(&#x27;Invalid window size (should be odd and at least 5 integer number)&#x27;)


    if (options.windowSize&#x3e;data.length)
        throw new RangeError(&#x27;Window size is higher than the data length &#x27;+options.windowSize+&#x22;&#x3e;&#x22;+data.length);
    if ((options.derivative &#x3c; 0) || !(Number.isInteger(options.derivative)))
        throw new RangeError(&#x27;Derivative should be a positive integer&#x27;);
    if ((options.polynomial &#x3c; 1) || !(Number.isInteger(options.polynomial)))
        throw new RangeError(&#x27;Polynomial should be a positive integer&#x27;);
    if (options.polynomial &#x3e;= 6)
        console.warn(&#x27;You should not use polynomial grade higher than 5 if you are&#x27; +
            &#x27; not sure that your data arises from such a model. Possible polynomial oscillation problems&#x27;);

    var windowSize = options.windowSize;

    var half = Math.floor(windowSize/2);
    var np = data.length;
    var ans = new Array(np);
    var weights = fullWeights(windowSize,options.polynomial,options.derivative);
    var hs = 0;
    var constantH = true;
    if( Object.prototype.toString.call( h ) === &#x27;[object Array]&#x27; ) {
        constantH = false;
    }
    else{
        hs = Math.pow(h, options.derivative);
    }
    //console.log(&#x22;Constant h: &#x22;+constantH);
    //For the borders
    for(var i=0;i&#x3c;half;i++){
        var wg1=weights[half-i-1];
        var wg2=weights[half+i+1];
        var d1 = 0,d2=0;
        for (var l = 0; l &#x3c; windowSize; l++){
            d1 += wg1[l] * data[l];
            d2 += wg2[l] * data[np-windowSize+l-1];
        }
        if(constantH){
            ans[half-i-1] = d1/hs;
            ans[np-half+i] = d2/hs;
        }
        else{
            hs = getHs(h,half-i-1,half, options.derivative);
            ans[half-i-1] = d1/hs;
            hs = getHs(h,np-half+i,half, options.derivative);
            ans[np-half+i] = d2/hs;
        }
    }
    //For the internal points
    var wg = weights[half];
    for(var i=windowSize;i&#x3c;np+1;i++){
        var d = 0;
        for (var l = 0; l &#x3c; windowSize; l++)
            d += wg[l] * data[l+i-windowSize];
        if(!constantH)
            hs = getHs(h,i-half-1,half, options.derivative);
        ans[i-half-1] = d/hs;
    }
    return ans;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix" id="apidoc.element.ml.Math.SparseMatrix">
        function <span class="apidocSignatureSpan">ml.Math.</span>SparseMatrix
        <span class="apidocSignatureSpan">(rows, columns, options = {})</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class SparseMatrix {
    constructor(rows, columns, options = {}) {
        if (rows instanceof SparseMatrix) { // clone
            const other = rows;
            this._init(other.rows, other.columns, other.elements.clone(), other.threshold);
            return;
        }

        if (Array.isArray(rows)) {
            const matrix = rows;
            rows = matrix.length;
            options = columns || {};
            columns = matrix[0].length;
            this._init(rows, columns, new HashTable(options), options.threshold);
            for (var i = 0; i &#x3c; rows; i++) {
                for (var j = 0; j &#x3c; columns; j++) {
                    var value = matrix[i][j];
                    if (this.threshold &#x26;&#x26; Math.abs(value) &#x3c; this.threshold) value = 0;
                    if (value !== 0) {
                        this.elements.set(i * columns + j, matrix[i][j]);
                    }
                }
            }
        } else {
            this._init(rows, columns, new HashTable(options), options.threshold);
        }
    }

    _init(rows, columns, elements, threshold) {
        this.rows = rows;
        this.columns = columns;
        this.elements = elements;
        this.threshold = threshold || 0;
    }

    static eye(rows = 1, columns = rows) {
        const min = Math.min(rows, columns);
        const matrix = new SparseMatrix(rows, columns, {initialCapacity: min});
        for (var i = 0; i &#x3c; min; i++) {
            matrix.set(i, i, 1);
        }
        return matrix;
    }

    clone() {
        return new SparseMatrix(this);
    }

    to2DArray() {
        const copy = new Array(this.rows);
        for (var i = 0; i &#x3c; this.rows; i++) {
            copy[i] = new Array(this.columns);
            for (var j = 0; j &#x3c; this.columns; j++) {
                copy[i][j] = this.get(i, j);
            }
        }
        return copy;
    }

    isSquare() {
        return this.rows === this.columns;
    }

    isSymmetric() {
        if (!this.isSquare()) return false;

        var symmetric = true;
        this.forEachNonZero((i, j, v) =&#x3e; {
            if (this.get(j, i) !== v) {
                symmetric = false;
                return false;
            }
            return v;
        });
        return symmetric;
    }

    get cardinality() {
        return this.elements.size;
    }

    get size() {
        return this.rows * this.columns;
    }

    get(row, column) {
        return this.elements.get(row * this.columns + column);
    }

    set(row, column, value) {
        if (this.threshold &#x26;&#x26; Math.abs(value) &#x3c; this.threshold) value = 0;
        if (value === 0) {
            this.elements.remove(row * this.columns + column);
        } else {
            this.elements.set(row * this.columns + column, value);
        }
        return this;
    }

    mmul(other) {
        if (this.columns !== other.rows)
            console.warn(&#x27;Number of columns of left matrix are not equal to number of rows of right matrix.&#x27;);

        const m = this.rows;
        const p = other.columns;

        const result = new SparseMatrix(m, p);
        this.forEachNonZero((i, j, v1) =&#x3e; {
            other.forEachNonZero((k, l, v2) =&#x3e; {
                if (j === k) {
                    result.set(i, l, result.get(i, l) + v1 * v2);
                }
                return v2;
            });
            return v1;
        });
        return result;
    }

    kroneckerProduct(other) {
        const m = this.rows;
        const n = this.columns;
        const p = other.rows;
        const q = other.columns;

        const result = new SparseMatrix(m * p, n * q, {
            initialCapacity: this.cardinality * other.cardinality
        });
        this.forEachNonZero((i, j, v1) =&#x3e; {
            other.forEachNonZero((k, l, v2) =&#x3e; {
                result.set(p * i + k, q * j + l, v1 * v2);
                return v2;
            });
            return v1;
        });
        return result;
    }

    forEachNonZero(callback) {
        this.elements.forEachPair((key, value) =&#x3e; {
            const i = (k ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>










</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ml.Math.BellOptimizer" id="apidoc.module.ml.Math.BellOptimizer">module ml.Math.BellOptimizer</a></h1>


    <h2>
        <a href="#apidoc.element.ml.Math.BellOptimizer.optimizeGaussianSum" id="apidoc.element.ml.Math.BellOptimizer.optimizeGaussianSum">
        function <span class="apidocSignatureSpan">ml.Math.BellOptimizer.</span>optimizeGaussianSum
        <span class="apidocSignatureSpan">(xy, group, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function optimizeGaussianSum(xy, group, opts){
    var xy2 = parseData(xy);

    if(xy2===null||xy2[0].rows&#x3c;3){
        return null; //Cannot run an optimization with less than 3 points
    }

    var t = xy2[0];
    var y_data = xy2[1];
    var maxY = xy2[2];
    var nbPoints = t.rows,i;

    var weight = new Matrix(nbPoints,1);//[nbPoints / math.sqrt(y_data.dot(y_data))];
    var k = nbPoints / math.sqrt(y_data.dot(y_data));
    for(i=0;i&#x3c;nbPoints;i++){
        weight[i][0]=k;///(y_data[i][0]);
        //weight[i][0]=k*(2-y_data[i][0]);
    }

    var opts=Object.create(opts || [  3,    100, 1e-3, 1e-3, 1e-3, 1e-2, 1e-2,    11,    9,        2 ]);
    //var opts=[  3,    100, 1e-5, 1e-6, 1e-6, 1e-6, 1e-6,    11,    9,        1 ];
    var consts = [ ];// optional vector of constants

    var nL = group.length;
    var p_init = new Matrix(nL*3,1);
    var p_min =  new Matrix(nL*3,1);
    var p_max =  new Matrix(nL*3,1);
    var dx = new Matrix(nL*3,1);
    var dt = Math.abs(t[0][0]-t[1][0]);
    for( i=0;i&#x3c;nL;i++){
        p_init[i][0] = group[i].x;
        p_init[i+nL][0] = group[i].y/maxY;
        p_init[i+2*nL][0] = group[i].width;

        p_min[i][0] = group[i].x-dt;
        p_min[i+nL][0] = group[i].y*0.8/maxY;
        p_min[i+2*nL][0] = group[i].width/2;

        p_max[i][0] = group[i].x+dt;
        p_max[i+nL][0] = group[i].y*1.2/maxY;
        p_max[i+2*nL][0] = group[i].width*2;

        dx[i][0] = -dt/1000;
        dx[i+nL][0] = -1e-3;
        dx[i+2*nL][0] = -dt/1000;
    }
    //console.log(t);
    var p_fit = LM.optimize(sumOfLorentzians,p_init,t,y_data,weight,dx,p_min,p_max,consts,opts);
    p_fit = p_fit.p;
    //Put back the result in the correct format
    var result = new Array(nL);
    for( i=0;i&#x3c;nL;i++){
        result[i]=[p_fit[i],[p_fit[i+nL][0]*maxY],p_fit[i+2*nL]];
    }

    return result;

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.BellOptimizer.optimizeGaussianTrain" id="apidoc.element.ml.Math.BellOptimizer.optimizeGaussianTrain">
        function <span class="apidocSignatureSpan">ml.Math.BellOptimizer.</span>optimizeGaussianTrain
        <span class="apidocSignatureSpan">(xy, group, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function optimizeGaussianTrain(xy, group, opts){
    var xy2 = parseData(xy);
    //console.log(xy2[0].rows);
    if(xy2===null||xy2[0].rows&#x3c;3){
        return null; //Cannot run an optimization with less than 3 points
    }

    var t = xy2[0];
    var y_data = xy2[1];
    var maxY = xy2[2];
    var currentIndex = 0;
    var nbPoints = t.length;
    var nextX;
    var tI, yI, maxY;
    var result=[], current;
    for(var i=0; i&#x3c;group.length;i++){
        nextX = group[i].x-group[i].width*1.5;
        //console.log(group[i]);
        while(t[currentIndex++]&#x3c;nextX&#x26;&#x26;currentIndex&#x3c;nbPoints);
        nextX = group[i].x+group[i].width*1.5;
        tI = [];
        yI = [];
        while(t[currentIndex]&#x3c;=nextX&#x26;&#x26;currentIndex&#x3c;nbPoints){
            tI.push(t[currentIndex][0]);
            yI.push(y_data[currentIndex][0]*maxY);
            currentIndex++;
        }

        current=optimizeSingleGaussian([tI, yI], group[i], opts);
        if(current){
            result.push({&#x22;x&#x22;:current[0][0],&#x22;y&#x22;:current[1][0],&#x22;width&#x22;:current[2][0],&#x22;opt&#x22;:true});
        }
        else{
            result.push({&#x22;x&#x22;:group[i].x,&#x22;y&#x22;:group[i].y,&#x22;width&#x22;:group[i].width,&#x22;opt&#x22;:false});
        }
    }

    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.BellOptimizer.optimizeLorentzianSum" id="apidoc.element.ml.Math.BellOptimizer.optimizeLorentzianSum">
        function <span class="apidocSignatureSpan">ml.Math.BellOptimizer.</span>optimizeLorentzianSum
        <span class="apidocSignatureSpan">(xy, group, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function optimizeLorentzianSum(xy, group, opts){
    var xy2 = parseData(xy);

    if(xy2===null||xy2[0].rows&#x3c;3){
        return null; //Cannot run an optimization with less than 3 points
    }

    var t = xy2[0];
    var y_data = xy2[1];
    var maxY = xy2[2];
    var nbPoints = t.rows, i;

    var weight = [nbPoints / math.sqrt(y_data.dot(y_data))];
    var opts=Object.create(opts || [  3,    100, 1e-3, 1e-3, 1e-3, 1e-2, 1e-2, 11, 9, 1 ]);
    var consts = [ ];// optional vector of constants

    var nL = group.length;
    var p_init = new Matrix(nL*3,1);
    var p_min =  new Matrix(nL*3,1);
    var p_max =  new Matrix(nL*3,1);
    var dx = new Matrix(nL*3,1);
    var dt = Math.abs(t[0][0]-t[1][0]);
    for( i=0;i&#x3c;nL;i++){
        p_init[i][0] = group[i].x;
        p_init[i+nL][0] = 1;
        p_init[i+2*nL][0] = group[i].width;

        p_min[i][0] = group[i].x-dt;//-group[i].width/4;
        p_min[i+nL][0] = 0;
        p_min[i+2*nL][0] = group[i].width/4;

        p_max[i][0] = group[i].x+dt;//+group[i].width/4;
        p_max[i+nL][0] = 1.5;
        p_max[i+2*nL][0] = group[i].width*4;

        dx[i][0] = -dt/1000;
        dx[i+nL][0] = -1e-3;
        dx[i+2*nL][0] = -dt/1000;
    }

    var dx = -Math.abs(t[0][0]-t[1][0])/10000;
    var p_fit = LM.optimize(sumOfLorentzians, p_init, t, y_data, weight, dx, p_min, p_max, consts, opts);
    p_fit=p_fit.p;
    //Put back the result in the correct format
    var result = new Array(nL);
    for( i=0;i&#x3c;nL;i++){
        result[i]=[p_fit[i],[p_fit[i+nL][0]*maxY],p_fit[i+2*nL]];
    }

    return result;

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.BellOptimizer.optimizeLorentzianTrain" id="apidoc.element.ml.Math.BellOptimizer.optimizeLorentzianTrain">
        function <span class="apidocSignatureSpan">ml.Math.BellOptimizer.</span>optimizeLorentzianTrain
        <span class="apidocSignatureSpan">(xy, group, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function optimizeLorentzianTrain(xy, group, opts){
    var xy2 = parseData(xy);
    //console.log(xy2[0].rows);
    if(xy2===null||xy2[0].rows&#x3c;3){
        return null; //Cannot run an optimization with less than 3 points
    }

    var t = xy2[0];
    var y_data = xy2[1];
    var maxY = xy2[2];
    var currentIndex = 0;
    var nbPoints = t.length;
    var nextX;
    var tI, yI, maxY;
    var result=[], current;
    for(var i=0; i&#x3c;group.length;i++){
        nextX = group[i].x-group[i].width*1.5;
        //console.log(group[i]);
        while(t[currentIndex++]&#x3c;nextX&#x26;&#x26;currentIndex&#x3c;nbPoints);
        nextX = group[i].x+group[i].width*1.5;
        tI = [];
        yI = [];
        while(t[currentIndex]&#x3c;=nextX&#x26;&#x26;currentIndex&#x3c;nbPoints){
            tI.push(t[currentIndex][0]);
            yI.push(y_data[currentIndex][0]*maxY);
            currentIndex++;
        }

        current=optimizeSingleLorentzian([tI, yI], group[i], opts);
        if(current){
            result.push({&#x22;x&#x22;:current[0][0],&#x22;y&#x22;:current[1][0],&#x22;width&#x22;:current[2][0],&#x22;opt&#x22;:true});
        }
        else{
            result.push({&#x22;x&#x22;:group[i].x,&#x22;y&#x22;:group[i].y,&#x22;width&#x22;:group[i].width,&#x22;opt&#x22;:false});
        }
    }

    return result;

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.BellOptimizer.optimizeSingleGaussian" id="apidoc.element.ml.Math.BellOptimizer.optimizeSingleGaussian">
        function <span class="apidocSignatureSpan">ml.Math.BellOptimizer.</span>optimizeSingleGaussian
        <span class="apidocSignatureSpan">(xy, peak, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function optimizeSingleGaussian(xy, peak, opts) {
    opts = opts || {};
    var xy2 = parseData(xy, opts.percentage||0);

    if(xy2===null||xy2[0].rows&#x3c;3){
        return null; //Cannot run an optimization with less than 3 points
    }

    var t = xy2[0];
    var y_data = xy2[1];
    var maxY = xy2[2];

    var nbPoints = t.rows, i;



    var weight = [nbPoints / Math.sqrt(y_data.dot(y_data))];

    var opts=Object.create(opts.LMOptions || [  3,    100, 1e-3, 1e-3, 1e-3, 1e-2, 1e-2,    11,    9,        1 ]);
    //var opts = [  3,    100, 1e-3, 1e-3, 1e-3, 1e-2, 1e-2,    11,    9,        1 ];
    var consts = [ ];                         // optional vector of constants
    var dt = Math.abs(t[0][0]-t[1][0]);
    var dx = new Matrix([[-dt/10000],[-1e-3],[-dt/10000]]);//-Math.abs(t[0][0]-t[1][0])/100;

    var dx = new Matrix([[-Math.abs(t[0][0]-t[1][0])/1000],[-1e-3],[-peak.width/1000]]);
    var p_init = new Matrix([[peak.x],[1],[peak.width]]);
    var p_min = new Matrix([[peak.x-dt],[0.75],[peak.width/4]]);
    var p_max = new Matrix([[peak.x+dt],[1.25],[peak.width*4]]);
    //var p_min = new Matrix([[peak.x-peak.width/4],[0.75],[peak.width/3]]);
    //var p_max = new Matrix([[peak.x+peak.width/4],[1.25],[peak.width*3]]);

    var p_fit = LM.optimize(singleGaussian,p_init,t,y_data,weight,dx,p_min,p_max,consts,opts);
    p_fit = p_fit.p;
    return [p_fit[0],[p_fit[1][0]*maxY],p_fit[2]];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.BellOptimizer.optimizeSingleLorentzian" id="apidoc.element.ml.Math.BellOptimizer.optimizeSingleLorentzian">
        function <span class="apidocSignatureSpan">ml.Math.BellOptimizer.</span>optimizeSingleLorentzian
        <span class="apidocSignatureSpan">(xy, peak, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function optimizeSingleLorentzian(xy, peak, opts) {
    opts = opts || {};
    var xy2 = parseData(xy, opts.percentage||0);

    if(xy2===null||xy2[0].rows&#x3c;3){
        return null; //Cannot run an optimization with less than 3 points
    }

    var t = xy2[0];
    var y_data = xy2[1];
    var maxY = xy2[2];
    var nbPoints = t.rows, i;

    var weight = [nbPoints / Math.sqrt(y_data.dot(y_data))];

    var opts=Object.create(opts.LMOptions || [  3,    100, 1e-3, 1e-3, 1e-3, 1e-2, 1e-2,    11,    9,        1 ]);
    //var opts = [  3,    100, 1e-3, 1e-3, 1e-3, 1e-2, 1e-2,    11,    9,        1 ];
    var consts = [ ];
    var dt = Math.abs(t[0][0]-t[1][0]);// optional vector of constants
    var dx = new Matrix([[-dt/10000],[-1e-3],[-dt/10000]]);//-Math.abs(t[0][0]-t[1][0])/100;
    var p_init = new Matrix([[peak.x],[1],[peak.width]]);
    var p_min = new Matrix([[peak.x-dt],[0.75],[peak.width/4]]);
    var p_max = new Matrix([[peak.x+dt],[1.25],[peak.width*4]]);

    var p_fit = LM.optimize(singleLorentzian,p_init,t,y_data,weight,dx,p_min,p_max,consts,opts);


    p_fit = p_fit.p;
    return [p_fit[0],[p_fit[1][0]*maxY],p_fit[2]];

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.BellOptimizer.singleGaussian" id="apidoc.element.ml.Math.BellOptimizer.singleGaussian">
        function <span class="apidocSignatureSpan">ml.Math.BellOptimizer.</span>singleGaussian
        <span class="apidocSignatureSpan">(t, p, c)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function singleGaussian(t, p, c){
    var factor2 = p[2][0]*p[2][0]/2;
    var rows = t.rows;
    var result = new Matrix(t.rows, t.columns);
    for(var i=0;i&#x3c;rows;i++){
        result[i][0]=p[1][0]*Math.exp(-(t[i][0]-p[0][0])*(t[i][0]-p[0][0])/factor2);
    }
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.BellOptimizer.singleLorentzian" id="apidoc.element.ml.Math.BellOptimizer.singleLorentzian">
        function <span class="apidocSignatureSpan">ml.Math.BellOptimizer.</span>singleLorentzian
        <span class="apidocSignatureSpan">(t, p, c)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function singleLorentzian(t, p, c){
    var factor = p[1][0]*Math.pow(p[2][0]/2,2);
    var rows = t.rows;
    var result = new Matrix(t.rows, t.columns);
    for(var i=0;i&#x3c;rows;i++){
        result[i][0]=factor/(Math.pow(t[i][0]-p[0][0],2)+Math.pow(p[2][0]/2,2));
    }
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ml.Math.CurveFitting" id="apidoc.module.ml.Math.CurveFitting">module ml.Math.CurveFitting</a></h1>


    <h2>
        <a href="#apidoc.element.ml.Math.CurveFitting.Matrix" id="apidoc.element.ml.Math.CurveFitting.Matrix">
        function <span class="apidocSignatureSpan">ml.Math.CurveFitting.</span>Matrix
        <span class="apidocSignatureSpan">(Array)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Matrix extends abstractMatrix(Array) {
    constructor(nRows, nColumns) {
        var i;
        if (arguments.length === 1 &#x26;&#x26; typeof nRows === &#x27;number&#x27;) {
            return new Array(nRows);
        }
        if (Matrix.isMatrix(nRows)) {
            return nRows.clone();
        } else if (Number.isInteger(nRows) &#x26;&#x26; nRows &#x3e; 0) { // Create an empty matrix
            super(nRows);
            if (Number.isInteger(nColumns) &#x26;&#x26; nColumns &#x3e; 0) {
                for (i = 0; i &#x3c; nRows; i++) {
                    this[i] = new Array(nColumns);
                }
            } else {
                throw new TypeError(&#x27;nColumns must be a positive integer&#x27;);
            }
        } else if (Array.isArray(nRows)) { // Copy the values from the 2D array
            const matrix = nRows;
            nRows = matrix.length;
            nColumns = matrix[0].length;
            if (typeof nColumns !== &#x27;number&#x27; || nColumns === 0) {
                throw new TypeError(&#x27;Data must be a 2D array with at least one element&#x27;);
            }
            super(nRows);
            for (i = 0; i &#x3c; nRows; i++) {
                if (matrix[i].length !== nColumns) {
                    throw new RangeError(&#x27;Inconsistent array dimensions&#x27;);
                }
                this[i] = [].concat(matrix[i]);
            }
        } else {
            throw new TypeError(&#x27;First argument must be a positive number or an array&#x27;);
        }
        this.rows = nRows;
        this.columns = nColumns;
        return this;
    }

    set(rowIndex, columnIndex, value) {
        this[rowIndex][columnIndex] = value;
        return this;
    }

    get(rowIndex, columnIndex) {
        return this[rowIndex][columnIndex];
    }

<span class="apidocCodeCommentSpan">    /**
     * Creates an exact and independent copy of the matrix
     * @return {Matrix}
     */
</span>    clone() {
        var newMatrix = new this.constructor[Symbol.species](this.rows, this.columns);
        for (var row = 0; row &#x3c; this.rows; row++) {
            for (var column = 0; column &#x3c; this.columns; column++) {
                newMatrix.set(row, column, this.get(row, column));
            }
        }
        return newMatrix;
    }

    /**
     * Removes a row from the given index
     * @param {number} index - Row index
     * @return {Matrix} this
     */
    removeRow(index) {
        util.checkRowIndex(this, index);
        if (this.rows === 1) {
            throw new RangeError(&#x27;A matrix cannot have less than one row&#x27;);
        }
        this.splice(index, 1);
        this.rows -= 1;
        return this;
    }

    /**
     * Adds a row at the given index
     * @param {number} [index = this.rows] - Row index
     * @param {Array|Matrix} array - Array or vector
     * @return {Matrix} this
     */
    addRow(index, array) {
        if (array === undefined) {
            array = index;
            index = this.rows;
        }
        util.checkRowIndex(this, index, true);
        array = util.checkRowVector(this, array, true);
        this.splice(index, 0, array);
        this.rows += 1;
        return this;
    }

    /**
     * Removes a column from the given index
     * @param {number} index - Column index
     * @return {Matrix} this
     */
    removeColumn(index) {
        util.checkColumnIndex(this, index);
        if (this.columns === 1) {
            throw new RangeError(&#x27;A matrix cannot have less than one column&#x27;);
        }
        for (var i = 0; i &#x3c; this.rows; i++) {
            this[i].splice(index, 1);
        }
        this.columns -= 1;
        return this;
    }

    /**
     * Adds a column at the given index
     * @param {number} [index = this.columns] - Column index
     * @param {Array|Matrix} array - Array or vector
     * @return {Matrix} this
     */
    addColumn(index, array) {
        if (typeof array === &#x27;undefined&#x27;) {
            array = index;
            index = this.columns;
        }
        util.checkColumnIndex(this, index, true);
        array = util.checkColumnVector(this, array);
        for (var i = 0; i &#x3c; this.rows; i++) {
            this[i].splice(index, 0, array[i]);
        } ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.CurveFitting.lm_Broyden_J" id="apidoc.element.ml.Math.CurveFitting.lm_Broyden_J">
        function <span class="apidocSignatureSpan">ml.Math.CurveFitting.</span>lm_Broyden_J
        <span class="apidocSignatureSpan">(p_old, y_old, J, p, y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lm_Broyden_J = function (p_old, y_old, J, p, y){
    // J = lm_Broyden_J(p_old,y_old,J,p,y)
    // carry out a rank-1 update to the Jacobian matrix using Broyden&#x27;s equation
    //---------- INPUT VARIABLES -------
    // p_old = previous set of parameters
    // y_old = model evaluation at previous set of parameters, y_hat(t;p_old)
    // J  = current version of the Jacobian matrix
    // p     = current  set of parameters
    // y     = model evaluation at current  set of parameters, y_hat(t;p)
    //---------- OUTPUT VARIABLES -------
    // J = rank-1 update to Jacobian Matrix J(i,j)=dy(i)/dp(j)	i=1:n; j=1:m
    //console.log(p+&#x22; X &#x22;+ p_old)
    var h  = math.subtract(p, p_old);

    //console.log(&#x22;hhh &#x22;+h);
    var h_t = math.transpose(h);
    h_t.div(math.multiply(h_t,h));

    //console.log(h_t);
    //J = J + ( y - y_old - J*h )*h&#x27; / (h&#x27;*h);	// Broyden rank-1 update eq&#x27;n
    J = math.add(J, math.multiply(math.subtract(y, math.add(y_old,math.multiply(J,h))),h_t));
    return J;
    // endfunction # ---------------------------------------------- LM_Broyden_J
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.CurveFitting.lm_FD_J" id="apidoc.element.ml.Math.CurveFitting.lm_FD_J">
        function <span class="apidocSignatureSpan">ml.Math.CurveFitting.</span>lm_FD_J
        <span class="apidocSignatureSpan">(func, t, p, y, dp, c)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lm_FD_J = function (func, t, p, y, dp, c) {
    // J = lm_FD_J(func,t,p,y,{dp},{c})
    //
    // partial derivatives (Jacobian) dy/dp for use with lm.m
    // computed via Finite Differences
    // Requires n or 2n function evaluations, n = number of nonzero values of dp
    // -------- INPUT VARIABLES ---------
    // func = function of independent variables, &#x27;t&#x27;, and parameters, &#x27;p&#x27;,
    //        returning the simulated model: y_hat = func(t,p,c)
    // t  = m-vector of independent variables (used as arg to func)
    // p  = n-vector of current parameter values
    // y  = func(t,p,c) n-vector initialised by user before each call to lm_FD_J
    // dp = fractional increment of p for numerical derivatives
    //      dp(j)&#x3e;0 central differences calculated
    //      dp(j)&#x3c;0 one sided differences calculated
    //      dp(j)=0 sets corresponding partials to zero; i.e. holds p(j) fixed
    //      Default:  0.001;
    // c  = optional vector of constants passed to y_hat = func(t,p,c)
    //---------- OUTPUT VARIABLES -------
    // J  = Jacobian Matrix J(i,j)=dy(i)/dp(j)	i=1:n; j=1:m

    //   Henri Gavin, Dept. Civil &#x26; Environ. Engineering, Duke Univ. November 2005
    //   modified from: ftp://fly.cnuce.cnr.it/pub/software/octave/leasqr/
    //   Press, et al., Numerical Recipes, Cambridge Univ. Press, 1992, Chapter 15.

    var m = y.length;			// number of data points
    var n = p.length;			// number of parameters

    dp = dp || math.multiply( Matrix.ones(n, 1), 0.001);

    var ps = p.clone();//JSON.parse(JSON.stringify(p));
    //var ps = $.extend(true, [], p);
    var J = new Matrix(m,n), del =new Array(n);         // initialize Jacobian to Zero

    for (var j = 0;j &#x3c; n; j++) {
        //console.log(j+&#x22; &#x22;+dp[j]+&#x22; &#x22;+p[j]+&#x22; &#x22;+ps[j]+&#x22; &#x22;+del[j]);
        del[j] = dp[j]*(1+Math.abs(p[j][0]));  // parameter perturbation
        p[j] = [ps[j][0]+del[j]];	      // perturb parameter p(j)
        //console.log(j+&#x22; &#x22;+dp[j]+&#x22; &#x22;+p[j]+&#x22; &#x22;+ps[j]+&#x22; &#x22;+del[j]);

        if (del[j] != 0){
            y1 = func(t, p, c);
            //func_calls = func_calls + 1;
            if (dp[j][0] &#x3c; 0) {		// backwards difference
                //J(:,j) = math.dotDivide(math.subtract(y1, y),del[j]);//. / del[j];
                //console.log(del[j]);
                //console.log(y);
                var column = math.dotDivide(math.subtract(y1, y),del[j]);
                for(var k=0;k&#x3c; m;k++){
                    J[k][j]=column[k][0];
                }
                //console.log(column);
            }
            else{
                p[j][0] = ps[j][0] - del[j];
                //J(:,j) = (y1 - feval(func, t, p, c)). / (2. * del[j]);
                var column = math.dotDivide(math.subtract(y1,func(t,p,c)),2*del[j]);
                for(var k=0;k&#x3c; m;k++){
                    J[k][j]=column[k][0];
                }

            }			// central difference, additional func call
        }

        p[j] = ps[j];		// restore p(j)

    }
    //console.log(&#x22;lm_FD_J: &#x22;+ JSON.stringify(J));
    return J;

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.CurveFitting.lm_matx" id="apidoc.element.ml.Math.CurveFitting.lm_matx">
        function <span class="apidocSignatureSpan">ml.Math.CurveFitting.</span>lm_matx
        <span class="apidocSignatureSpan">(func, t, p_old, y_old, dX2, J, p, y_dat, weight_sq, dp, c, iteration)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lm_matx = function (func, t, p_old, y_old, dX2, J, p, y_dat, weight_sq, dp, c, iteration){
    // [JtWJ,JtWdy,Chi_sq,y_hat,J] = this.lm_matx(func,t,p_old,y_old,dX2,J,p,y_dat,weight_sq,{da},{c})
    //
    // Evaluate the linearized fitting matrix, JtWJ, and vector JtWdy,
    // and calculate the Chi-squared error function, Chi_sq
    // Used by Levenberg-Marquard algorithm, lm.m
    // -------- INPUT VARIABLES ---------
    // func   = function ofpn independent variables, p, and m parameters, p,
    //         returning the simulated model: y_hat = func(t,p,c)
    // t      = m-vectors or matrix of independent variables (used as arg to func)
    // p_old  = n-vector of previous parameter values
    // y_old  = m-vector of previous model ... y_old = y_hat(t;p_old);
    // dX2    = previous change in Chi-squared criteria
    // J   = m-by-n Jacobian of model, y_hat, with respect to parameters, p
    // p      = n-vector of current  parameter values
    // y_dat  = n-vector of data to be fit by func(t,p,c)
    // weight_sq = square of the weighting vector for least squares fit ...
    //	    inverse of the standard measurement errors
    // dp     = fractional increment of &#x27;p&#x27; for numerical derivatives
    //          dp(j)&#x3e;0 central differences calculated
    //          dp(j)&#x3c;0 one sided differences calculated
    //          dp(j)=0 sets corresponding partials to zero; i.e. holds p(j) fixed
    //          Default:  0.001;
    // c      = optional vector of constants passed to y_hat = func(t,p,c)
    //---------- OUTPUT VARIABLES -------
    // JtWJ	 = linearized Hessian matrix (inverse of covariance matrix)
    // JtWdy   = linearized fitting vector
    // Chi_sq = Chi-squared criteria: weighted sum of the squared residuals WSSR
    // y_hat  = model evaluated with parameters &#x27;p&#x27;
    // J   = m-by-n Jacobian of model, y_hat, with respect to parameters, p

    //   Henri Gavin, Dept. Civil &#x26; Environ. Engineering, Duke Univ. November 2005
    //   modified from: ftp://fly.cnuce.cnr.it/pub/software/octave/leasqr/
    //   Press, et al., Numerical Recipes, Cambridge Univ. Press, 1992, Chapter 15.


    var Npnt = y_dat.length;		// number of data points
    var Npar = p.length;		// number of parameters

    dp = dp || 0.001;


    //var JtWJ = new Matrix.zeros(Npar);
    //var JtWdy  = new Matrix.zeros(Npar,1);

    var y_hat = func(t,p,c);	// evaluate model using parameters &#x27;p&#x27;
    //func_calls = func_calls + 1;
    //console.log(J);
    if ( (iteration%(2*Npar))==0 || dX2 &#x3e; 0 ) {
        //console.log(&#x22;Par&#x22;);
        J = this.lm_FD_J(func, t, p, y_hat, dp, c);		// finite difference
    }
    else{
        //console.log(&#x22;ImPar&#x22;);
        J = this.lm_Broyden_J(p_old, y_old, J, p, y_hat); // rank-1 update
    }
    //console.log(y_dat);
    //console.log(y_hat);
    var delta_y = math.subtract(y_dat, y_hat);	// residual error between model and data
    //console.log(delta_y[0][0]);
    //console.log(delta_y.rows+&#x22; &#x22;+delta_y.columns+&#x22; &#x22;+JSON.stringify(weight_sq));
    //var Chi_sq = delta_y&#x27; * ( delta_y .* weight_sq ); 	// Chi-squared error criteria
    var Chi_sq = math.multiply(math.transpose(delta_y),math.dotMultiply(delta_y,weight_sq));
    //JtWJ  = J&#x27; * ( J .* ( weight_sq * ones(1,Npar) ) );
    var Jt = math.transpose(J);

    //console.log(weight_sq);

    var JtWJ = math.multiply(Jt, math.dotMultiply(J,math.multiply(weight_sq, Matrix.ones(1,Npar))));

    //JtWdy = J&#x27; * ( weight_sq .* delta_y );
    var JtWdy = math.multiply(Jt, math.dotMultiply(weight_sq,delta_y));


    return {JtWJ:JtWJ,JtWdy:JtWdy,Chi_sq:Chi_sq,y_hat:y_hat,J:J};
    // endfunction  # ------------------------------------------------------ LM_MATX
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.CurveFitting.optimize" id="apidoc.element.ml.Math.CurveFitting.optimize">
        function <span class="apidocSignatureSpan">ml.Math.CurveFitting.</span>optimize
        <span class="apidocSignatureSpan">(func, p, t, y_dat, weight, dp, p_min, p_max, c, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">optimize = function (func, p, t, y_dat, weight, dp, p_min, p_max, c, opts){

    var tensor_parameter = 0;			// set to 1 of parameter is a tensor

    var iteration  = 0;			// iteration counter
    //func_calls = 0;			// running count of function evaluations

    if((typeof p[0])!=&#x22;object&#x22;){
        for(var i=0;i&#x3c; p.length;i++){
            p[i]=[p[i]];
        }

    }
    //p = p(:); y_dat = y_dat(:); 		// make column vectors
    var i,k;
    var eps = 2^-52;
    var Npar   = p.length;//length(p); 			// number of parameters
    var Npnt   = y_dat.length;//length(y_dat);		// number of data points
    var p_old  = Matrix.zeros(Npar,1);		// previous set of parameters
    var y_old  = Matrix.zeros(Npnt,1);		// previous model, y_old = y_hat(t;p_old)
    var X2     = 1e-2/eps;			// a really big initial Chi-sq value
    var X2_old = 1e-2/eps;			// a really big initial Chi-sq value
    var J =  Matrix.zeros(Npnt,Npar);


    if (t.length != y_dat.length) {
        console.log(&#x27;lm.m error: the length of t must equal the length of y_dat&#x27;);

        length_t = t.length;
        length_y_dat = y_dat.length;
        var X2 = 0, corr = 0, sigma_p = 0, sigma_y = 0, R_sq = 0, cvg_hist = 0;
        if (!tensor_parameter) {
            return;
        }
    }

    weight = weight||Math.sqrt((Npnt-Npar+1)/(math.multiply(math.transpose(y_dat),y_dat)));
    dp = dp || 0.001;
    p_min   = p_min || math.multiply(Math.abs(p),-100);
    p_max   = p_max || math.multiply(Math.abs(p),100);
    c = c || 1;
    // Algorithmic Paramters
    //prnt MaxIter  eps1  eps2  epx3  eps4  lam0  lamUP lamDN UpdateType
    opts = opts ||[  3,10*Npar, 1e-3, 1e-3, 1e-3, 1e-2, 1e-2, 11, 9, 1 ];

    var prnt          = opts[0];	// &#x3e;1 intermediate results; &#x3e;2 plots
    var MaxIter       = opts[1];	// maximum number of iterations
    var epsilon_1     = opts[2];	// convergence tolerance for gradient
    var epsilon_2     = opts[3];	// convergence tolerance for parameter
    var epsilon_3     = opts[4];	// convergence tolerance for Chi-square
    var epsilon_4     = opts[5];	// determines acceptance of a L-M step
    var lambda_0      = opts[6];	// initial value of damping paramter, lambda
    var lambda_UP_fac = opts[7];	// factor for increasing lambda
    var lambda_DN_fac = opts[8];	// factor for decreasing lambda
    var Update_Type   = opts[9];	// 1: Levenberg-Marquardt lambda update
    // 2: Quadratic update
    // 3: Nielsen&#x27;s lambda update equations

    if ( tensor_parameter &#x26;&#x26; prnt == 3 ) prnt = 2;


    if(!dp.length || dp.length == 1){
        var dp_array = new Array(Npar);
        for(var i=0;i&#x3c;Npar;i++)
            dp_array[i]=[dp];
        dp=dp_array;
    }

    // indices of the parameters to be fit
    var idx   = [];
    for(i=0;i&#x3c;dp.length;i++){
        if(dp[i][0]!=0){
            idx.push(i);
        }
    }

    var Nfit = idx.length;			// number of parameters to fit
    var stop = false;				// termination flag

    var weight_sq = null;
    //console.log(weight);
    if ( !weight.length || weight.length &#x3c; Npnt )	{
        // squared weighting vector
        //weight_sq = ( weight(1)*ones(Npnt,1) ).^2;
        //console.log(&#x22;weight[0] &#x22;+typeof weight[0]);
        var tmp = math.multiply(Matrix.ones(Npnt,1),weight[0]);
        weight_sq = math.dotMultiply(tmp,tmp);
    }
    else{
        //weight_sq = (weight(:)).^2;
        weight_sq = math.dotMultiply(weight,weight);
    }


    // initialize Jacobian with finite difference calculation
    //console.log(&#x22;J &#x22;+weight_sq);
    var result = this.lm_matx(func,t,p_old,y_old,1,J,p,y_dat,weight_sq,dp,c);
    var JtWJ = result.JtWJ,JtWdy=result.JtWdy,X2=result.Chi_sq,y_hat=result.y_hat,J=result.J;
    //[JtWJ,JtWdy,X2,y_hat,J] = this.lm_matx(func,t,p_old,y_old,1,J,p,y_dat,weight_sq,dp,c);
    //console.log(JtWJ);

    if ( Math.max(Math.abs(JtWdy)) &#x3c; epsilon_1 ){
        console.log(&#x27; *** Your Initial Guess is Extremely Close to Optimal ***&#x27;)
        console.log(&#x27; *** epsilon_1 = &#x27;, epsilon_1);
        stop = true;
    }


    switch(Update_Type){
        case 1: // Marquardt: init&#x27;l lambda
            lambda  = lamb ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ml.Math.Distance" id="apidoc.module.ml.Math.Distance">module ml.Math.Distance</a></h1>


    <h2>
        <a href="#apidoc.element.ml.Math.Distance.additiveSymmetric" id="apidoc.element.ml.Math.Distance.additiveSymmetric">
        function <span class="apidocSignatureSpan">ml.Math.Distance.</span>additiveSymmetric
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function additiveSymmetric(a, b) {
    var i = 0,
        ii = a.length,
        d = 0;
    for (; i &#x3c; ii; i++) {
        d += ((a[i] - b[i]) * (a[i] - b[i]) * (a[i] + b[i])) / (a[i] * b[i]);
    }
    return 2 * d;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.Distance.avg" id="apidoc.element.ml.Math.Distance.avg">
        function <span class="apidocSignatureSpan">ml.Math.Distance.</span>avg
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function avg(a, b) {
    var ii = a.length,
        max = 0,
        ans = 0,
        aux = 0;
    for (var i = 0; i &#x3c; ii ; i++) {
        aux = Math.abs(a[i] - b[i]);
        ans += aux;
        if (max &#x3c; aux) {
            max = aux;
        }
    }
    return (max + ans) / 2;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.Distance.bhattacharyya" id="apidoc.element.ml.Math.Distance.bhattacharyya">
        function <span class="apidocSignatureSpan">ml.Math.Distance.</span>bhattacharyya
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function bhattacharyya(a, b) {
    var ii = a.length,
        ans = 0;
    for (var i = 0; i &#x3c; ii ; i++) {
        ans += Math.sqrt(a[i] * b[i]);
    }
    return - Math.log(ans);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.Distance.canberra" id="apidoc.element.ml.Math.Distance.canberra">
        function <span class="apidocSignatureSpan">ml.Math.Distance.</span>canberra
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function canberra(a, b) {
    var ii = a.length,
        ans = 0;
    for (var i = 0; i &#x3c; ii ; i++) {
        ans += Math.abs(a[i] - b[i]) / (a[i] + b[i]);
    }
    return ans;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.Distance.chebyshev" id="apidoc.element.ml.Math.Distance.chebyshev">
        function <span class="apidocSignatureSpan">ml.Math.Distance.</span>chebyshev
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function chebyshev(a, b) {
    var ii = a.length,
        max = 0,
        aux = 0;
    for (var i = 0; i &#x3c; ii ; i++) {
        aux = Math.abs(a[i] - b[i]);
        if (max &#x3c; aux) {
            max = aux;
        }
    }
    return max;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.Distance.clark" id="apidoc.element.ml.Math.Distance.clark">
        function <span class="apidocSignatureSpan">ml.Math.Distance.</span>clark
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function clark(a, b) {
    var i = 0,
        ii = a.length,
        d = 0;
    for (; i &#x3c; ii; i++) {
        d += Math.sqrt(((a[i] - b[i]) * (a[i] - b[i])) / ((a[i] + b[i]) * (a[i] + b[i])));
    }
    return 2 * d;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.Distance.czekanowski" id="apidoc.element.ml.Math.Distance.czekanowski">
        function <span class="apidocSignatureSpan">ml.Math.Distance.</span>czekanowski
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function czekanowskiDistance(a, b) {
    return 1 - czekanowskiSimilarity(a, b);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.Distance.dice" id="apidoc.element.ml.Math.Distance.dice">
        function <span class="apidocSignatureSpan">ml.Math.Distance.</span>dice
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dice(a, b) {
    var ii = a.length,
        p = 0,
        q1 = 0,
        q2 = 0;
    for (var i = 0; i &#x3c; ii ; i++) {
        p += a[i] * a[i];
        q1 += b[i] * b[i];
        q2 += (a[i] - b[i]) * (a[i] - b[i]);
    }
    return q2 / (p + q1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.Distance.divergence" id="apidoc.element.ml.Math.Distance.divergence">
        function <span class="apidocSignatureSpan">ml.Math.Distance.</span>divergence
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function divergence(a, b) {
    var i = 0,
        ii = a.length,
        d = 0;
    for (; i &#x3c; ii; i++) {
        d += ((a[i] - b[i]) * (a[i] - b[i])) / ((a[i] + b[i]) * (a[i] + b[i]));
    }
    return 2 * d;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.Distance.euclidean" id="apidoc.element.ml.Math.Distance.euclidean">
        function <span class="apidocSignatureSpan">ml.Math.Distance.</span>euclidean
        <span class="apidocSignatureSpan">(p, q)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function euclidean(p, q) {
    return Math.sqrt(squaredEuclidean(p, q));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.Distance.fidelity" id="apidoc.element.ml.Math.Distance.fidelity">
        function <span class="apidocSignatureSpan">ml.Math.Distance.</span>fidelity
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fidelity(a, b) {
    var ii = a.length,
        ans = 0;
    for (var i = 0; i &#x3c; ii ; i++) {
        ans += Math.sqrt(a[i] * b[i]);
    }
    return ans;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.Distance.gower" id="apidoc.element.ml.Math.Distance.gower">
        function <span class="apidocSignatureSpan">ml.Math.Distance.</span>gower
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function gower(a, b) {
    var ii = a.length,
        ans = 0;
    for (var i = 0; i &#x3c; ii ; i++) {
        ans += Math.abs(a[i] - b[i]);
    }
    return ans / ii;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.Distance.harmonicMean" id="apidoc.element.ml.Math.Distance.harmonicMean">
        function <span class="apidocSignatureSpan">ml.Math.Distance.</span>harmonicMean
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function harmonicMean(a, b) {
    var ii = a.length,
        ans = 0;
    for (var i = 0; i &#x3c; ii ; i++) {
        ans += (a[i] * b[i]) / (a[i] + b[i]);
    }
    return 2 * ans;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.Distance.hellinger" id="apidoc.element.ml.Math.Distance.hellinger">
        function <span class="apidocSignatureSpan">ml.Math.Distance.</span>hellinger
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function hellinger(a, b) {
    var ii = a.length,
        ans = 0;
    for (var i = 0; i &#x3c; ii ; i++) {
        ans += Math.sqrt(a[i] * b[i]);
    }
    return 2 * Math.sqrt(1 - ans);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.Distance.innerProduct" id="apidoc.element.ml.Math.Distance.innerProduct">
        function <span class="apidocSignatureSpan">ml.Math.Distance.</span>innerProduct
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function innerProduct(a, b) {
    var ii = a.length,
        ans = 0;
    for (var i = 0; i &#x3c; ii ; i++) {
        ans += a[i] * b[i];
    }
    return ans;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.Distance.intersection" id="apidoc.element.ml.Math.Distance.intersection">
        function <span class="apidocSignatureSpan">ml.Math.Distance.</span>intersection
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function intersection(a, b) {
    var ii = a.length,
        ans = 0;
    for (var i = 0; i &#x3c; ii ; i++) {
        ans += Math.min(a[i], b[i]);
    }
    return 1 - ans;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.Distance.jaccard" id="apidoc.element.ml.Math.Distance.jaccard">
        function <span class="apidocSignatureSpan">ml.Math.Distance.</span>jaccard
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function jaccard(a, b) {
    var ii = a.length,
        p1 = 0,
        p2 = 0,
        q1 = 0,
        q2 = 0;
    for (var i = 0; i &#x3c; ii ; i++) {
        p1 += a[i] * b[i];
        p2 += a[i] * a[i];
        q1 += b[i] * b[i];
        q2 += (a[i] - b[i]) * (a[i] - b[i]);
    }
    return q2 / (p2 + q1 - p1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.Distance.jeffreys" id="apidoc.element.ml.Math.Distance.jeffreys">
        function <span class="apidocSignatureSpan">ml.Math.Distance.</span>jeffreys
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function jeffreys(a, b) {
    var ii = a.length,
        ans = 0;
    for (var i = 0; i &#x3c; ii ; i++) {
        ans += (a[i] - b[i]) * Math.log(a[i] / b[i]);
    }
    return ans;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.Distance.jensenDifference" id="apidoc.element.ml.Math.Distance.jensenDifference">
        function <span class="apidocSignatureSpan">ml.Math.Distance.</span>jensenDifference
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function jensenDifference(a, b) {
    var ii = a.length,
        ans = 0;
    for (var i = 0; i &#x3c; ii ; i++) {
        ans += ((a[i] * Math.log(a[i]) + b[i] * Math.log(b[i])) / 2) - ((a[i] + b[i]) / 2) * Math.log((a[i] + b[i]) / 2);
    }
    return ans;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.Distance.jensenShannon" id="apidoc.element.ml.Math.Distance.jensenShannon">
        function <span class="apidocSignatureSpan">ml.Math.Distance.</span>jensenShannon
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function jensenShannon(a, b) {
    var ii = a.length,
        p = 0,
        q = 0;
    for (var i = 0; i &#x3c; ii ; i++) {
        p += a[i] * Math.log(2 * a[i] / (a[i] + b[i]));
        q += b[i] * Math.log(2 * b[i] / (a[i] + b[i]));
    }
    return (p + q) / 2;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.Distance.kdivergence" id="apidoc.element.ml.Math.Distance.kdivergence">
        function <span class="apidocSignatureSpan">ml.Math.Distance.</span>kdivergence
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function kdivergence(a, b) {
    var ii = a.length,
        ans = 0;
    for (var i = 0; i &#x3c; ii ; i++) {
        ans += a[i] * Math.log(2 * a[i] / (a[i] + b[i]));
    }
    return ans;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.Distance.kulczynski" id="apidoc.element.ml.Math.Distance.kulczynski">
        function <span class="apidocSignatureSpan">ml.Math.Distance.</span>kulczynski
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function kulczynski(a, b) {
    var ii = a.length,
        up = 0,
        down = 0;
    for (var i = 0; i &#x3c; ii ; i++) {
        up += Math.abs(a[i] - b[i]);
        down += Math.min(a[i],b[i]);
    }
    return up / down;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.Distance.kullbackLeibler" id="apidoc.element.ml.Math.Distance.kullbackLeibler">
        function <span class="apidocSignatureSpan">ml.Math.Distance.</span>kullbackLeibler
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function kullbackLeibler(a, b) {
    var ii = a.length,
        ans = 0;
    for (var i = 0; i &#x3c; ii ; i++) {
        ans += a[i] * Math.log(a[i] / b[i]);
    }
    return ans;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.Distance.kumarHassebrook" id="apidoc.element.ml.Math.Distance.kumarHassebrook">
        function <span class="apidocSignatureSpan">ml.Math.Distance.</span>kumarHassebrook
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function kumarHassebrook(a, b) {
    var ii = a.length,
        p = 0,
        p2 = 0,
        q2 = 0;
    for (var i = 0; i &#x3c; ii ; i++) {
        p += a[i] * b[i];
        p2 += a[i] * a[i];
        q2 += b[i] * b[i];
    }
    return p / (p2 + q2 - p);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.Distance.kumarJohnson" id="apidoc.element.ml.Math.Distance.kumarJohnson">
        function <span class="apidocSignatureSpan">ml.Math.Distance.</span>kumarJohnson
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function kumarJohnson(a, b) {
    var ii = a.length,
        ans = 0;
    for (var i = 0; i &#x3c; ii ; i++) {
        ans += Math.pow(a[i] * a[i] - b[i] * b[i],2) / (2 * Math.pow(a[i] * b[i],1.5));
    }
    return ans;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.Distance.lorentzian" id="apidoc.element.ml.Math.Distance.lorentzian">
        function <span class="apidocSignatureSpan">ml.Math.Distance.</span>lorentzian
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function lorentzian(a, b) {
    var ii = a.length,
        ans = 0;
    for (var i = 0; i &#x3c; ii ; i++) {
        ans += Math.log(Math.abs(a[i] - b[i]) + 1);
    }
    return ans;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.Distance.manhattan" id="apidoc.element.ml.Math.Distance.manhattan">
        function <span class="apidocSignatureSpan">ml.Math.Distance.</span>manhattan
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function manhattan(a, b) {
    var i = 0,
        ii = a.length,
        d = 0;
    for (; i &#x3c; ii; i++) {
        d += Math.abs(a[i] - b[i]);
    }
    return d;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.Distance.matusita" id="apidoc.element.ml.Math.Distance.matusita">
        function <span class="apidocSignatureSpan">ml.Math.Distance.</span>matusita
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function matusita(a, b) {
    var ii = a.length,
        ans = 0;
    for (var i = 0; i &#x3c; ii ; i++) {
        ans += Math.sqrt(a[i] * b[i]);
    }
    return Math.sqrt(2 - 2 * ans);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.Distance.minkowski" id="apidoc.element.ml.Math.Distance.minkowski">
        function <span class="apidocSignatureSpan">ml.Math.Distance.</span>minkowski
        <span class="apidocSignatureSpan">(a, b, p)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function minkowski(a, b, p) {
    var i = 0,
        ii = a.length,
        d = 0;
    for (; i &#x3c; ii; i++) {
        d += Math.pow(Math.abs(a[i] - b[i]),p);
    }
    return Math.pow(d,(1/p));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.Distance.motyka" id="apidoc.element.ml.Math.Distance.motyka">
        function <span class="apidocSignatureSpan">ml.Math.Distance.</span>motyka
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function motyka(a, b) {
    var ii = a.length,
        up = 0,
        down = 0;
    for (var i = 0; i &#x3c; ii ; i++) {
        up += Math.min(a[i], b[i]);
        down += a[i] + b[i];
    }
    return 1 - (up / down);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.Distance.neyman" id="apidoc.element.ml.Math.Distance.neyman">
        function <span class="apidocSignatureSpan">ml.Math.Distance.</span>neyman
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function neyman(a, b) {
    var i = 0,
        ii = a.length,
        d = 0;
    for (; i &#x3c; ii; i++) {
        d += ((a[i] - b[i]) * (a[i] - b[i])) / a[i];
    }
    return d;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.Distance.pearson" id="apidoc.element.ml.Math.Distance.pearson">
        function <span class="apidocSignatureSpan">ml.Math.Distance.</span>pearson
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function pearson(a, b) {
    var i = 0,
        ii = a.length,
        d = 0;
    for (; i &#x3c; ii; i++) {
        d += ((a[i] - b[i]) * (a[i] - b[i])) / b[i];
    }
    return d;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.Distance.probabilisticSymmetric" id="apidoc.element.ml.Math.Distance.probabilisticSymmetric">
        function <span class="apidocSignatureSpan">ml.Math.Distance.</span>probabilisticSymmetric
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function probabilisticSymmetric(a, b) {
    var i = 0,
        ii = a.length,
        d = 0;
    for (; i &#x3c; ii; i++) {
        d += ((a[i] - b[i]) * (a[i] - b[i])) / (a[i] + b[i]);
    }
    return 2 * d;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.Distance.ruzicka" id="apidoc.element.ml.Math.Distance.ruzicka">
        function <span class="apidocSignatureSpan">ml.Math.Distance.</span>ruzicka
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ruzicka(a, b) {
    var ii = a.length,
        up = 0,
        down = 0;
    for (var i = 0; i &#x3c; ii ; i++) {
        up += Math.min(a[i],b[i]);
        down += Math.max(a[i],b[i]);
    }
    return up / down;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.Distance.soergel" id="apidoc.element.ml.Math.Distance.soergel">
        function <span class="apidocSignatureSpan">ml.Math.Distance.</span>soergel
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function soergel(a, b) {
    var ii = a.length,
        up = 0,
        down = 0;
    for (var i = 0; i &#x3c; ii ; i++) {
        up += Math.abs(a[i] - b[i]);
        down += Math.max(a[i],b[i]);
    }
    return up / down;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.Distance.sorensen" id="apidoc.element.ml.Math.Distance.sorensen">
        function <span class="apidocSignatureSpan">ml.Math.Distance.</span>sorensen
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sorensen(a, b) {
    var ii = a.length,
        up = 0,
        down = 0;
    for (var i = 0; i &#x3c; ii ; i++) {
        up += Math.abs(a[i] - b[i]);
        down += a[i] + b[i];
    }
    return up / down;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.Distance.squared" id="apidoc.element.ml.Math.Distance.squared">
        function <span class="apidocSignatureSpan">ml.Math.Distance.</span>squared
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function squared(a, b) {
    var i = 0,
        ii = a.length,
        d = 0;
    for (; i &#x3c; ii; i++) {
        d += ((a[i] - b[i]) * (a[i] - b[i])) / (a[i] + b[i]);
    }
    return d;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.Distance.squaredChord" id="apidoc.element.ml.Math.Distance.squaredChord">
        function <span class="apidocSignatureSpan">ml.Math.Distance.</span>squaredChord
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function squaredChord(a, b) {
    var ii = a.length,
        ans = 0;
    for (var i = 0; i &#x3c; ii ; i++) {
        ans += (Math.sqrt(a[i]) - Math.sqrt(b[i])) * (Math.sqrt(a[i]) - Math.sqrt(b[i]));
    }
    return ans;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.Distance.squaredEuclidean" id="apidoc.element.ml.Math.Distance.squaredEuclidean">
        function <span class="apidocSignatureSpan">ml.Math.Distance.</span>squaredEuclidean
        <span class="apidocSignatureSpan">(p, q)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function squaredEuclidean(p, q) {
    var d = 0;
    for (var i = 0; i &#x3c; p.length; i++) {
        d += (p[i] - q[i]) * (p[i] - q[i]);
    }
    return d;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.Distance.taneja" id="apidoc.element.ml.Math.Distance.taneja">
        function <span class="apidocSignatureSpan">ml.Math.Distance.</span>taneja
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function taneja(a, b) {
    var ii = a.length,
        ans = 0;
    for (var i = 0; i &#x3c; ii ; i++) {
        ans += (a[i] + b[i]) / 2 * Math.log((a[i] + b[i]) / (2 * Math.sqrt(a[i] * b[i])));
    }
    return ans;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.Distance.tanimoto" id="apidoc.element.ml.Math.Distance.tanimoto">
        function <span class="apidocSignatureSpan">ml.Math.Distance.</span>tanimoto
        <span class="apidocSignatureSpan">(a, b, bitvector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function tanimoto(a, b, bitvector) {
    if (bitvector)
        return 1 - tanimotoS(a, b, bitvector);
    else {
        var ii = a.length,
            p = 0,
            q = 0,
            m = 0;
        for (var i = 0; i &#x3c; ii ; i++) {
            p += a[i];
            q += b[i];
            m += Math.min(a[i],b[i]);
        }
        return (p + q - 2 * m) / (p + q - m);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.Distance.topsoe" id="apidoc.element.ml.Math.Distance.topsoe">
        function <span class="apidocSignatureSpan">ml.Math.Distance.</span>topsoe
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function topsoe(a, b) {
    var ii = a.length,
        ans = 0;
    for (var i = 0; i &#x3c; ii ; i++) {
        ans += a[i] * Math.log(2 * a[i] / (a[i] + b[i])) + b[i] * Math.log(2 * b[i] / (a[i] + b[i]));
    }
    return ans;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.Distance.waveHedges" id="apidoc.element.ml.Math.Distance.waveHedges">
        function <span class="apidocSignatureSpan">ml.Math.Distance.</span>waveHedges
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function waveHedges(a, b) {
    var ii = a.length,
        ans = 0;
    for (var i = 0; i &#x3c; ii ; i++) {
        ans += 1 - (Math.min(a[i], b[i]) / Math.max(a[i], b[i]));
    }
    return ans;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ml.Math.Similarity" id="apidoc.module.ml.Math.Similarity">module ml.Math.Similarity</a></h1>


    <h2>
        <a href="#apidoc.element.ml.Math.Similarity.cosine" id="apidoc.element.ml.Math.Similarity.cosine">
        function <span class="apidocSignatureSpan">ml.Math.Similarity.</span>cosine
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cosine(a, b) {
    var ii = a.length,
        p = 0,
        p2 = 0,
        q2 = 0;
    for (var i = 0; i &#x3c; ii ; i++) {
        p += a[i] * b[i];
        p2 += a[i] * a[i];
        q2 += b[i] * b[i];
    }
    return p / (Math.sqrt(p2) * Math.sqrt(q2));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.Similarity.czekanowski" id="apidoc.element.ml.Math.Similarity.czekanowski">
        function <span class="apidocSignatureSpan">ml.Math.Similarity.</span>czekanowski
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function czekanowskiSimilarity(a, b) {
    var up = 0;
    var down = 0;
    for (var i = 0; i &#x3c; a.length; i++) {
        up += Math.min(a[i], b[i]);
        down += a[i] + b[i];
    }
    return 2 * up / down;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.Similarity.dice" id="apidoc.element.ml.Math.Similarity.dice">
        function <span class="apidocSignatureSpan">ml.Math.Similarity.</span>dice
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dice(a, b) {
    return 1 - diceD(a,b);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.Similarity.intersection" id="apidoc.element.ml.Math.Similarity.intersection">
        function <span class="apidocSignatureSpan">ml.Math.Similarity.</span>intersection
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function intersection(a, b) {
    return 1 - intersectionD(a,b);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.Similarity.jaccard" id="apidoc.element.ml.Math.Similarity.jaccard">
        function <span class="apidocSignatureSpan">ml.Math.Similarity.</span>jaccard
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function jaccard(a, b) {
    return 1 - jaccardD(a, b);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.Similarity.kulczynski" id="apidoc.element.ml.Math.Similarity.kulczynski">
        function <span class="apidocSignatureSpan">ml.Math.Similarity.</span>kulczynski
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function kulczynski(a, b) {
    return 1 / kulczynskiD(a, b);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.Similarity.motyka" id="apidoc.element.ml.Math.Similarity.motyka">
        function <span class="apidocSignatureSpan">ml.Math.Similarity.</span>motyka
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function motyka(a, b) {
    return 1 - motykaD(a,b);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.Similarity.pearson" id="apidoc.element.ml.Math.Similarity.pearson">
        function <span class="apidocSignatureSpan">ml.Math.Similarity.</span>pearson
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function pearson(a, b) {
    var avgA=stat.mean(a);
    var avgB=stat.mean(b);

    var newA=new Array(a.length);
    var newB=new Array(b.length);
    for (var i=0; i&#x3c;newA.length; i++) {
        newA[i]=a[i]-avgA;
        newB[i]=b[i]-avgB;
    }

    return cosine(newA, newB);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.Similarity.squaredChord" id="apidoc.element.ml.Math.Similarity.squaredChord">
        function <span class="apidocSignatureSpan">ml.Math.Similarity.</span>squaredChord
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function squaredChord(a, b) {
    return 1 - squaredChordD(a, b);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.Similarity.tanimoto" id="apidoc.element.ml.Math.Similarity.tanimoto">
        function <span class="apidocSignatureSpan">ml.Math.Similarity.</span>tanimoto
        <span class="apidocSignatureSpan">(a, b, bitvector)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function tanimoto(a, b, bitvector) {
    if (bitvector) {
        var inter = 0,
            union = 0;
        for (var j = 0; j &#x3c; a.length; j++) {
            inter += a[j] &#x26;&#x26; b[j];
            union += a[j] || b[j];
        }
        if (union === 0)
            return 1;
        return inter / union;
    }
    else {
        var ii = a.length,
            p = 0,
            q = 0,
            m = 0;
        for (var i = 0; i &#x3c; ii ; i++) {
            p += a[i];
            q += b[i];
            m += Math.min(a[i],b[i]);
        }
        return 1 - (p + q - 2 * m) / (p + q - m);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ml.Math.SparseMatrix" id="apidoc.module.ml.Math.SparseMatrix">module ml.Math.SparseMatrix</a></h1>


    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.SparseMatrix" id="apidoc.element.ml.Math.SparseMatrix.SparseMatrix">
        function <span class="apidocSignatureSpan">ml.Math.</span>SparseMatrix
        <span class="apidocSignatureSpan">(rows, columns, options = {})</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class SparseMatrix {
    constructor(rows, columns, options = {}) {
        if (rows instanceof SparseMatrix) { // clone
            const other = rows;
            this._init(other.rows, other.columns, other.elements.clone(), other.threshold);
            return;
        }

        if (Array.isArray(rows)) {
            const matrix = rows;
            rows = matrix.length;
            options = columns || {};
            columns = matrix[0].length;
            this._init(rows, columns, new HashTable(options), options.threshold);
            for (var i = 0; i &#x3c; rows; i++) {
                for (var j = 0; j &#x3c; columns; j++) {
                    var value = matrix[i][j];
                    if (this.threshold &#x26;&#x26; Math.abs(value) &#x3c; this.threshold) value = 0;
                    if (value !== 0) {
                        this.elements.set(i * columns + j, matrix[i][j]);
                    }
                }
            }
        } else {
            this._init(rows, columns, new HashTable(options), options.threshold);
        }
    }

    _init(rows, columns, elements, threshold) {
        this.rows = rows;
        this.columns = columns;
        this.elements = elements;
        this.threshold = threshold || 0;
    }

    static eye(rows = 1, columns = rows) {
        const min = Math.min(rows, columns);
        const matrix = new SparseMatrix(rows, columns, {initialCapacity: min});
        for (var i = 0; i &#x3c; min; i++) {
            matrix.set(i, i, 1);
        }
        return matrix;
    }

    clone() {
        return new SparseMatrix(this);
    }

    to2DArray() {
        const copy = new Array(this.rows);
        for (var i = 0; i &#x3c; this.rows; i++) {
            copy[i] = new Array(this.columns);
            for (var j = 0; j &#x3c; this.columns; j++) {
                copy[i][j] = this.get(i, j);
            }
        }
        return copy;
    }

    isSquare() {
        return this.rows === this.columns;
    }

    isSymmetric() {
        if (!this.isSquare()) return false;

        var symmetric = true;
        this.forEachNonZero((i, j, v) =&#x3e; {
            if (this.get(j, i) !== v) {
                symmetric = false;
                return false;
            }
            return v;
        });
        return symmetric;
    }

    get cardinality() {
        return this.elements.size;
    }

    get size() {
        return this.rows * this.columns;
    }

    get(row, column) {
        return this.elements.get(row * this.columns + column);
    }

    set(row, column, value) {
        if (this.threshold &#x26;&#x26; Math.abs(value) &#x3c; this.threshold) value = 0;
        if (value === 0) {
            this.elements.remove(row * this.columns + column);
        } else {
            this.elements.set(row * this.columns + column, value);
        }
        return this;
    }

    mmul(other) {
        if (this.columns !== other.rows)
            console.warn(&#x27;Number of columns of left matrix are not equal to number of rows of right matrix.&#x27;);

        const m = this.rows;
        const p = other.columns;

        const result = new SparseMatrix(m, p);
        this.forEachNonZero((i, j, v1) =&#x3e; {
            other.forEachNonZero((k, l, v2) =&#x3e; {
                if (j === k) {
                    result.set(i, l, result.get(i, l) + v1 * v2);
                }
                return v2;
            });
            return v1;
        });
        return result;
    }

    kroneckerProduct(other) {
        const m = this.rows;
        const n = this.columns;
        const p = other.rows;
        const q = other.columns;

        const result = new SparseMatrix(m * p, n * q, {
            initialCapacity: this.cardinality * other.cardinality
        });
        this.forEachNonZero((i, j, v1) =&#x3e; {
            other.forEachNonZero((k, l, v2) =&#x3e; {
                result.set(p * i + k, q * j + l, v1 * v2);
                return v2;
            });
            return v1;
        });
        return result;
    }

    forEachNonZero(callback) {
        this.elements.forEachPair((key, value) =&#x3e; {
            const i = (k ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.abs" id="apidoc.element.ml.Math.SparseMatrix.abs">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>abs
        <span class="apidocSignatureSpan">(matrix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function abs(matrix) {
    var newMatrix = new SparseMatrix(matrix);
    return newMatrix.abs();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.acos" id="apidoc.element.ml.Math.SparseMatrix.acos">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>acos
        <span class="apidocSignatureSpan">(matrix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function acos(matrix) {
    var newMatrix = new SparseMatrix(matrix);
    return newMatrix.acos();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.acosh" id="apidoc.element.ml.Math.SparseMatrix.acosh">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>acosh
        <span class="apidocSignatureSpan">(matrix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function acosh(matrix) {
    var newMatrix = new SparseMatrix(matrix);
    return newMatrix.acosh();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.add" id="apidoc.element.ml.Math.SparseMatrix.add">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>add
        <span class="apidocSignatureSpan">(matrix, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function add(matrix, value) {
    var newMatrix = new SparseMatrix(matrix);
    return newMatrix.add(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.and" id="apidoc.element.ml.Math.SparseMatrix.and">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>and
        <span class="apidocSignatureSpan">(matrix, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function and(matrix, value) {
    var newMatrix = new SparseMatrix(matrix);
    return newMatrix.and(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.asin" id="apidoc.element.ml.Math.SparseMatrix.asin">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>asin
        <span class="apidocSignatureSpan">(matrix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function asin(matrix) {
    var newMatrix = new SparseMatrix(matrix);
    return newMatrix.asin();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.asinh" id="apidoc.element.ml.Math.SparseMatrix.asinh">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>asinh
        <span class="apidocSignatureSpan">(matrix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function asinh(matrix) {
    var newMatrix = new SparseMatrix(matrix);
    return newMatrix.asinh();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.atan" id="apidoc.element.ml.Math.SparseMatrix.atan">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>atan
        <span class="apidocSignatureSpan">(matrix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function atan(matrix) {
    var newMatrix = new SparseMatrix(matrix);
    return newMatrix.atan();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.atanh" id="apidoc.element.ml.Math.SparseMatrix.atanh">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>atanh
        <span class="apidocSignatureSpan">(matrix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function atanh(matrix) {
    var newMatrix = new SparseMatrix(matrix);
    return newMatrix.atanh();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.cbrt" id="apidoc.element.ml.Math.SparseMatrix.cbrt">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>cbrt
        <span class="apidocSignatureSpan">(matrix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cbrt(matrix) {
    var newMatrix = new SparseMatrix(matrix);
    return newMatrix.cbrt();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.ceil" id="apidoc.element.ml.Math.SparseMatrix.ceil">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>ceil
        <span class="apidocSignatureSpan">(matrix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ceil(matrix) {
    var newMatrix = new SparseMatrix(matrix);
    return newMatrix.ceil();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.clz32" id="apidoc.element.ml.Math.SparseMatrix.clz32">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>clz32
        <span class="apidocSignatureSpan">(matrix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function clz32(matrix) {
    var newMatrix = new SparseMatrix(matrix);
    return newMatrix.clz32();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.cos" id="apidoc.element.ml.Math.SparseMatrix.cos">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>cos
        <span class="apidocSignatureSpan">(matrix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cos(matrix) {
    var newMatrix = new SparseMatrix(matrix);
    return newMatrix.cos();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.cosh" id="apidoc.element.ml.Math.SparseMatrix.cosh">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>cosh
        <span class="apidocSignatureSpan">(matrix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cosh(matrix) {
    var newMatrix = new SparseMatrix(matrix);
    return newMatrix.cosh();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.div" id="apidoc.element.ml.Math.SparseMatrix.div">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>div
        <span class="apidocSignatureSpan">(matrix, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function div(matrix, value) {
    var newMatrix = new SparseMatrix(matrix);
    return newMatrix.div(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.divide" id="apidoc.element.ml.Math.SparseMatrix.divide">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>divide
        <span class="apidocSignatureSpan">(matrix, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function divide(matrix, value) {
    var newMatrix = new SparseMatrix(matrix);
    return newMatrix.divide(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.exp" id="apidoc.element.ml.Math.SparseMatrix.exp">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>exp
        <span class="apidocSignatureSpan">(matrix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function exp(matrix) {
    var newMatrix = new SparseMatrix(matrix);
    return newMatrix.exp();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.expm1" id="apidoc.element.ml.Math.SparseMatrix.expm1">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>expm1
        <span class="apidocSignatureSpan">(matrix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function expm1(matrix) {
    var newMatrix = new SparseMatrix(matrix);
    return newMatrix.expm1();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.floor" id="apidoc.element.ml.Math.SparseMatrix.floor">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>floor
        <span class="apidocSignatureSpan">(matrix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function floor(matrix) {
    var newMatrix = new SparseMatrix(matrix);
    return newMatrix.floor();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.fround" id="apidoc.element.ml.Math.SparseMatrix.fround">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>fround
        <span class="apidocSignatureSpan">(matrix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fround(matrix) {
    var newMatrix = new SparseMatrix(matrix);
    return newMatrix.fround();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.identity" id="apidoc.element.ml.Math.SparseMatrix.identity">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>identity
        <span class="apidocSignatureSpan">(rows = 1, columns = rows)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eye(rows = 1, columns = rows) {
    const min = Math.min(rows, columns);
    const matrix = new SparseMatrix(rows, columns, {initialCapacity: min});
    for (var i = 0; i &#x3c; min; i++) {
        matrix.set(i, i, 1);
    }
    return matrix;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.leftShift" id="apidoc.element.ml.Math.SparseMatrix.leftShift">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>leftShift
        <span class="apidocSignatureSpan">(matrix, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function leftShift(matrix, value) {
    var newMatrix = new SparseMatrix(matrix);
    return newMatrix.leftShift(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.log" id="apidoc.element.ml.Math.SparseMatrix.log">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>log
        <span class="apidocSignatureSpan">(matrix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function log(matrix) {
    var newMatrix = new SparseMatrix(matrix);
    return newMatrix.log();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.log10" id="apidoc.element.ml.Math.SparseMatrix.log10">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>log10
        <span class="apidocSignatureSpan">(matrix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function log10(matrix) {
    var newMatrix = new SparseMatrix(matrix);
    return newMatrix.log10();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.log1p" id="apidoc.element.ml.Math.SparseMatrix.log1p">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>log1p
        <span class="apidocSignatureSpan">(matrix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function log1p(matrix) {
    var newMatrix = new SparseMatrix(matrix);
    return newMatrix.log1p();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.log2" id="apidoc.element.ml.Math.SparseMatrix.log2">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>log2
        <span class="apidocSignatureSpan">(matrix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function log2(matrix) {
    var newMatrix = new SparseMatrix(matrix);
    return newMatrix.log2();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.mod" id="apidoc.element.ml.Math.SparseMatrix.mod">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>mod
        <span class="apidocSignatureSpan">(matrix, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mod(matrix, value) {
    var newMatrix = new SparseMatrix(matrix);
    return newMatrix.mod(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.modulus" id="apidoc.element.ml.Math.SparseMatrix.modulus">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>modulus
        <span class="apidocSignatureSpan">(matrix, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function modulus(matrix, value) {
    var newMatrix = new SparseMatrix(matrix);
    return newMatrix.modulus(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.mul" id="apidoc.element.ml.Math.SparseMatrix.mul">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>mul
        <span class="apidocSignatureSpan">(matrix, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mul(matrix, value) {
    var newMatrix = new SparseMatrix(matrix);
    return newMatrix.mul(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.multiply" id="apidoc.element.ml.Math.SparseMatrix.multiply">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>multiply
        <span class="apidocSignatureSpan">(matrix, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function multiply(matrix, value) {
    var newMatrix = new SparseMatrix(matrix);
    return newMatrix.multiply(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.not" id="apidoc.element.ml.Math.SparseMatrix.not">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>not
        <span class="apidocSignatureSpan">(matrix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function not(matrix) {
    var newMatrix = new SparseMatrix(matrix);
    return newMatrix.not();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.or" id="apidoc.element.ml.Math.SparseMatrix.or">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>or
        <span class="apidocSignatureSpan">(matrix, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function or(matrix, value) {
    var newMatrix = new SparseMatrix(matrix);
    return newMatrix.or(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.rightShift" id="apidoc.element.ml.Math.SparseMatrix.rightShift">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>rightShift
        <span class="apidocSignatureSpan">(matrix, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function rightShift(matrix, value) {
    var newMatrix = new SparseMatrix(matrix);
    return newMatrix.rightShift(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.round" id="apidoc.element.ml.Math.SparseMatrix.round">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>round
        <span class="apidocSignatureSpan">(matrix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function round(matrix) {
    var newMatrix = new SparseMatrix(matrix);
    return newMatrix.round();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.sign" id="apidoc.element.ml.Math.SparseMatrix.sign">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>sign
        <span class="apidocSignatureSpan">(matrix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sign(matrix) {
    var newMatrix = new SparseMatrix(matrix);
    return newMatrix.sign();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.signPropagatingRightShift" id="apidoc.element.ml.Math.SparseMatrix.signPropagatingRightShift">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>signPropagatingRightShift
        <span class="apidocSignatureSpan">(matrix, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function signPropagatingRightShift(matrix, value) {
    var newMatrix = new SparseMatrix(matrix);
    return newMatrix.signPropagatingRightShift(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.sin" id="apidoc.element.ml.Math.SparseMatrix.sin">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>sin
        <span class="apidocSignatureSpan">(matrix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sin(matrix) {
    var newMatrix = new SparseMatrix(matrix);
    return newMatrix.sin();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.sinh" id="apidoc.element.ml.Math.SparseMatrix.sinh">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>sinh
        <span class="apidocSignatureSpan">(matrix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sinh(matrix) {
    var newMatrix = new SparseMatrix(matrix);
    return newMatrix.sinh();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.sqrt" id="apidoc.element.ml.Math.SparseMatrix.sqrt">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>sqrt
        <span class="apidocSignatureSpan">(matrix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sqrt(matrix) {
    var newMatrix = new SparseMatrix(matrix);
    return newMatrix.sqrt();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.sub" id="apidoc.element.ml.Math.SparseMatrix.sub">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>sub
        <span class="apidocSignatureSpan">(matrix, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sub(matrix, value) {
    var newMatrix = new SparseMatrix(matrix);
    return newMatrix.sub(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.subtract" id="apidoc.element.ml.Math.SparseMatrix.subtract">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>subtract
        <span class="apidocSignatureSpan">(matrix, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function subtract(matrix, value) {
    var newMatrix = new SparseMatrix(matrix);
    return newMatrix.subtract(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.tan" id="apidoc.element.ml.Math.SparseMatrix.tan">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>tan
        <span class="apidocSignatureSpan">(matrix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function tan(matrix) {
    var newMatrix = new SparseMatrix(matrix);
    return newMatrix.tan();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.tanh" id="apidoc.element.ml.Math.SparseMatrix.tanh">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>tanh
        <span class="apidocSignatureSpan">(matrix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function tanh(matrix) {
    var newMatrix = new SparseMatrix(matrix);
    return newMatrix.tanh();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.trunc" id="apidoc.element.ml.Math.SparseMatrix.trunc">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>trunc
        <span class="apidocSignatureSpan">(matrix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function trunc(matrix) {
    var newMatrix = new SparseMatrix(matrix);
    return newMatrix.trunc();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.xor" id="apidoc.element.ml.Math.SparseMatrix.xor">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>xor
        <span class="apidocSignatureSpan">(matrix, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function xor(matrix, value) {
    var newMatrix = new SparseMatrix(matrix);
    return newMatrix.xor(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.zeroFillRightShift" id="apidoc.element.ml.Math.SparseMatrix.zeroFillRightShift">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.</span>zeroFillRightShift
        <span class="apidocSignatureSpan">(matrix, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function zeroFillRightShift(matrix, value) {
    var newMatrix = new SparseMatrix(matrix);
    return newMatrix.zeroFillRightShift(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ml.Math.SparseMatrix.prototype" id="apidoc.module.ml.Math.SparseMatrix.prototype">module ml.Math.SparseMatrix.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.abs" id="apidoc.element.ml.Math.SparseMatrix.prototype.abs">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>abs
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function abs() {
    this.forEachNonZero((i, j, v) =&#x3e; Math.abs(v));
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.acos" id="apidoc.element.ml.Math.SparseMatrix.prototype.acos">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>acos
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function acos() {
    this.forEachNonZero((i, j, v) =&#x3e; Math.acos(v));
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.acosh" id="apidoc.element.ml.Math.SparseMatrix.prototype.acosh">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>acosh
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function acosh() {
    this.forEachNonZero((i, j, v) =&#x3e; Math.acosh(v));
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.add" id="apidoc.element.ml.Math.SparseMatrix.prototype.add">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>add
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function add(value) {
    if (typeof value === &#x27;number&#x27;) return this.addS(value);
    return this.addM(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.addM" id="apidoc.element.ml.Math.SparseMatrix.prototype.addM">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>addM
        <span class="apidocSignatureSpan">(matrix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function addMM(matrix) {
    matrix.forEachNonZero((i, j, v) =&#x3e; {
        this.set(i, j, this.get(i, j) + v);
        return v;
    });
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.addS" id="apidoc.element.ml.Math.SparseMatrix.prototype.addS">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>addS
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function addSS(value) {
    this.forEachNonZero((i, j, v) =&#x3e; v + value);
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.and" id="apidoc.element.ml.Math.SparseMatrix.prototype.and">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>and
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function and(value) {
    if (typeof value === &#x27;number&#x27;) return this.andS(value);
    return this.andM(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.andM" id="apidoc.element.ml.Math.SparseMatrix.prototype.andM">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>andM
        <span class="apidocSignatureSpan">(matrix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function andMM(matrix) {
    matrix.forEachNonZero((i, j, v) =&#x3e; {
        this.set(i, j, this.get(i, j) &#x26; v);
        return v;
    });
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.andS" id="apidoc.element.ml.Math.SparseMatrix.prototype.andS">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>andS
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function andSS(value) {
    this.forEachNonZero((i, j, v) =&#x3e; v &#x26; value);
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.asin" id="apidoc.element.ml.Math.SparseMatrix.prototype.asin">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>asin
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function asin() {
    this.forEachNonZero((i, j, v) =&#x3e; Math.asin(v));
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.asinh" id="apidoc.element.ml.Math.SparseMatrix.prototype.asinh">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>asinh
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function asinh() {
    this.forEachNonZero((i, j, v) =&#x3e; Math.asinh(v));
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.atan" id="apidoc.element.ml.Math.SparseMatrix.prototype.atan">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>atan
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function atan() {
    this.forEachNonZero((i, j, v) =&#x3e; Math.atan(v));
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.atanh" id="apidoc.element.ml.Math.SparseMatrix.prototype.atanh">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>atanh
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function atanh() {
    this.forEachNonZero((i, j, v) =&#x3e; Math.atanh(v));
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.cbrt" id="apidoc.element.ml.Math.SparseMatrix.prototype.cbrt">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>cbrt
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cbrt() {
    this.forEachNonZero((i, j, v) =&#x3e; Math.cbrt(v));
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.ceil" id="apidoc.element.ml.Math.SparseMatrix.prototype.ceil">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>ceil
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ceil() {
    this.forEachNonZero((i, j, v) =&#x3e; Math.ceil(v));
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.clz32" id="apidoc.element.ml.Math.SparseMatrix.prototype.clz32">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>clz32
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function clz32() {
    this.forEachNonZero((i, j, v) =&#x3e; Math.clz32(v));
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.cos" id="apidoc.element.ml.Math.SparseMatrix.prototype.cos">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>cos
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cos() {
    this.forEachNonZero((i, j, v) =&#x3e; Math.cos(v));
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.cosh" id="apidoc.element.ml.Math.SparseMatrix.prototype.cosh">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>cosh
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cosh() {
    this.forEachNonZero((i, j, v) =&#x3e; Math.cosh(v));
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.div" id="apidoc.element.ml.Math.SparseMatrix.prototype.div">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>div
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function div(value) {
    if (typeof value === &#x27;number&#x27;) return this.divS(value);
    return this.divM(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.divM" id="apidoc.element.ml.Math.SparseMatrix.prototype.divM">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>divM
        <span class="apidocSignatureSpan">(matrix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function divMM(matrix) {
    matrix.forEachNonZero((i, j, v) =&#x3e; {
        this.set(i, j, this.get(i, j) / v);
        return v;
    });
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.divS" id="apidoc.element.ml.Math.SparseMatrix.prototype.divS">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>divS
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function divSS(value) {
    this.forEachNonZero((i, j, v) =&#x3e; v / value);
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.divide" id="apidoc.element.ml.Math.SparseMatrix.prototype.divide">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>divide
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function divide(value) {
    if (typeof value === &#x27;number&#x27;) return this.divideS(value);
    return this.divideM(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.divideM" id="apidoc.element.ml.Math.SparseMatrix.prototype.divideM">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>divideM
        <span class="apidocSignatureSpan">(matrix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function divideMM(matrix) {
    matrix.forEachNonZero((i, j, v) =&#x3e; {
        this.set(i, j, this.get(i, j) / v);
        return v;
    });
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.divideS" id="apidoc.element.ml.Math.SparseMatrix.prototype.divideS">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>divideS
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function divideSS(value) {
    this.forEachNonZero((i, j, v) =&#x3e; v / value);
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.exp" id="apidoc.element.ml.Math.SparseMatrix.prototype.exp">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>exp
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function exp() {
    this.forEachNonZero((i, j, v) =&#x3e; Math.exp(v));
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.expm1" id="apidoc.element.ml.Math.SparseMatrix.prototype.expm1">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>expm1
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function expm1() {
    this.forEachNonZero((i, j, v) =&#x3e; Math.expm1(v));
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.floor" id="apidoc.element.ml.Math.SparseMatrix.prototype.floor">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>floor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function floor() {
    this.forEachNonZero((i, j, v) =&#x3e; Math.floor(v));
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.fround" id="apidoc.element.ml.Math.SparseMatrix.prototype.fround">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>fround
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function fround() {
    this.forEachNonZero((i, j, v) =&#x3e; Math.fround(v));
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.leftShift" id="apidoc.element.ml.Math.SparseMatrix.prototype.leftShift">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>leftShift
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function leftShift(value) {
    if (typeof value === &#x27;number&#x27;) return this.leftShiftS(value);
    return this.leftShiftM(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.leftShiftM" id="apidoc.element.ml.Math.SparseMatrix.prototype.leftShiftM">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>leftShiftM
        <span class="apidocSignatureSpan">(matrix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function leftShiftMM(matrix) {
    matrix.forEachNonZero((i, j, v) =&#x3e; {
        this.set(i, j, this.get(i, j) &#x3c;&#x3c; v);
        return v;
    });
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.leftShiftS" id="apidoc.element.ml.Math.SparseMatrix.prototype.leftShiftS">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>leftShiftS
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function leftShiftSS(value) {
    this.forEachNonZero((i, j, v) =&#x3e; v &#x3c;&#x3c; value);
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.log" id="apidoc.element.ml.Math.SparseMatrix.prototype.log">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>log
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function log() {
    this.forEachNonZero((i, j, v) =&#x3e; Math.log(v));
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.log10" id="apidoc.element.ml.Math.SparseMatrix.prototype.log10">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>log10
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function log10() {
    this.forEachNonZero((i, j, v) =&#x3e; Math.log10(v));
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.log1p" id="apidoc.element.ml.Math.SparseMatrix.prototype.log1p">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>log1p
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function log1p() {
    this.forEachNonZero((i, j, v) =&#x3e; Math.log1p(v));
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.log2" id="apidoc.element.ml.Math.SparseMatrix.prototype.log2">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>log2
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function log2() {
    this.forEachNonZero((i, j, v) =&#x3e; Math.log2(v));
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.mod" id="apidoc.element.ml.Math.SparseMatrix.prototype.mod">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>mod
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mod(value) {
    if (typeof value === &#x27;number&#x27;) return this.modS(value);
    return this.modM(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.modM" id="apidoc.element.ml.Math.SparseMatrix.prototype.modM">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>modM
        <span class="apidocSignatureSpan">(matrix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function modMM(matrix) {
    matrix.forEachNonZero((i, j, v) =&#x3e; {
        this.set(i, j, this.get(i, j) % v);
        return v;
    });
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.modS" id="apidoc.element.ml.Math.SparseMatrix.prototype.modS">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>modS
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function modSS(value) {
    this.forEachNonZero((i, j, v) =&#x3e; v % value);
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.modulus" id="apidoc.element.ml.Math.SparseMatrix.prototype.modulus">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>modulus
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function modulus(value) {
    if (typeof value === &#x27;number&#x27;) return this.modulusS(value);
    return this.modulusM(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.modulusM" id="apidoc.element.ml.Math.SparseMatrix.prototype.modulusM">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>modulusM
        <span class="apidocSignatureSpan">(matrix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function modulusMM(matrix) {
    matrix.forEachNonZero((i, j, v) =&#x3e; {
        this.set(i, j, this.get(i, j) % v);
        return v;
    });
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.modulusS" id="apidoc.element.ml.Math.SparseMatrix.prototype.modulusS">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>modulusS
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function modulusSS(value) {
    this.forEachNonZero((i, j, v) =&#x3e; v % value);
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.mul" id="apidoc.element.ml.Math.SparseMatrix.prototype.mul">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>mul
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mul(value) {
    if (typeof value === &#x27;number&#x27;) return this.mulS(value);
    return this.mulM(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.mulM" id="apidoc.element.ml.Math.SparseMatrix.prototype.mulM">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>mulM
        <span class="apidocSignatureSpan">(matrix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mulMM(matrix) {
    matrix.forEachNonZero((i, j, v) =&#x3e; {
        this.set(i, j, this.get(i, j) * v);
        return v;
    });
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.mulS" id="apidoc.element.ml.Math.SparseMatrix.prototype.mulS">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>mulS
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mulSS(value) {
    this.forEachNonZero((i, j, v) =&#x3e; v * value);
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.multiply" id="apidoc.element.ml.Math.SparseMatrix.prototype.multiply">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>multiply
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function multiply(value) {
    if (typeof value === &#x27;number&#x27;) return this.multiplyS(value);
    return this.multiplyM(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.multiplyM" id="apidoc.element.ml.Math.SparseMatrix.prototype.multiplyM">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>multiplyM
        <span class="apidocSignatureSpan">(matrix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function multiplyMM(matrix) {
    matrix.forEachNonZero((i, j, v) =&#x3e; {
        this.set(i, j, this.get(i, j) * v);
        return v;
    });
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.multiplyS" id="apidoc.element.ml.Math.SparseMatrix.prototype.multiplyS">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>multiplyS
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function multiplySS(value) {
    this.forEachNonZero((i, j, v) =&#x3e; v * value);
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.not" id="apidoc.element.ml.Math.SparseMatrix.prototype.not">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>not
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function not() {
    this.forEachNonZero((i, j, v) =&#x3e; ~(v));
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.or" id="apidoc.element.ml.Math.SparseMatrix.prototype.or">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>or
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function or(value) {
    if (typeof value === &#x27;number&#x27;) return this.orS(value);
    return this.orM(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.orM" id="apidoc.element.ml.Math.SparseMatrix.prototype.orM">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>orM
        <span class="apidocSignatureSpan">(matrix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function orMM(matrix) {
    matrix.forEachNonZero((i, j, v) =&#x3e; {
        this.set(i, j, this.get(i, j) | v);
        return v;
    });
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.orS" id="apidoc.element.ml.Math.SparseMatrix.prototype.orS">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>orS
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function orSS(value) {
    this.forEachNonZero((i, j, v) =&#x3e; v | value);
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.rightShift" id="apidoc.element.ml.Math.SparseMatrix.prototype.rightShift">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>rightShift
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function rightShift(value) {
    if (typeof value === &#x27;number&#x27;) return this.rightShiftS(value);
    return this.rightShiftM(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.rightShiftM" id="apidoc.element.ml.Math.SparseMatrix.prototype.rightShiftM">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>rightShiftM
        <span class="apidocSignatureSpan">(matrix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function rightShiftMM(matrix) {
    matrix.forEachNonZero((i, j, v) =&#x3e; {
        this.set(i, j, this.get(i, j) &#x3e;&#x3e;&#x3e; v);
        return v;
    });
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.rightShiftS" id="apidoc.element.ml.Math.SparseMatrix.prototype.rightShiftS">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>rightShiftS
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function rightShiftSS(value) {
    this.forEachNonZero((i, j, v) =&#x3e; v &#x3e;&#x3e;&#x3e; value);
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.round" id="apidoc.element.ml.Math.SparseMatrix.prototype.round">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>round
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function round() {
    this.forEachNonZero((i, j, v) =&#x3e; Math.round(v));
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.sign" id="apidoc.element.ml.Math.SparseMatrix.prototype.sign">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>sign
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sign() {
    this.forEachNonZero((i, j, v) =&#x3e; Math.sign(v));
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.signPropagatingRightShift" id="apidoc.element.ml.Math.SparseMatrix.prototype.signPropagatingRightShift">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>signPropagatingRightShift
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function signPropagatingRightShift(value) {
    if (typeof value === &#x27;number&#x27;) return this.signPropagatingRightShiftS(value);
    return this.signPropagatingRightShiftM(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.signPropagatingRightShiftM" id="apidoc.element.ml.Math.SparseMatrix.prototype.signPropagatingRightShiftM">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>signPropagatingRightShiftM
        <span class="apidocSignatureSpan">(matrix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function signPropagatingRightShiftMM(matrix) {
    matrix.forEachNonZero((i, j, v) =&#x3e; {
        this.set(i, j, this.get(i, j) &#x3e;&#x3e; v);
        return v;
    });
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.signPropagatingRightShiftS" id="apidoc.element.ml.Math.SparseMatrix.prototype.signPropagatingRightShiftS">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>signPropagatingRightShiftS
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function signPropagatingRightShiftSS(value) {
    this.forEachNonZero((i, j, v) =&#x3e; v &#x3e;&#x3e; value);
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.sin" id="apidoc.element.ml.Math.SparseMatrix.prototype.sin">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>sin
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sin() {
    this.forEachNonZero((i, j, v) =&#x3e; Math.sin(v));
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.sinh" id="apidoc.element.ml.Math.SparseMatrix.prototype.sinh">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>sinh
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sinh() {
    this.forEachNonZero((i, j, v) =&#x3e; Math.sinh(v));
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.sqrt" id="apidoc.element.ml.Math.SparseMatrix.prototype.sqrt">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>sqrt
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sqrt() {
    this.forEachNonZero((i, j, v) =&#x3e; Math.sqrt(v));
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.sub" id="apidoc.element.ml.Math.SparseMatrix.prototype.sub">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>sub
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sub(value) {
    if (typeof value === &#x27;number&#x27;) return this.subS(value);
    return this.subM(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.subM" id="apidoc.element.ml.Math.SparseMatrix.prototype.subM">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>subM
        <span class="apidocSignatureSpan">(matrix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function subMM(matrix) {
    matrix.forEachNonZero((i, j, v) =&#x3e; {
        this.set(i, j, this.get(i, j) - v);
        return v;
    });
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.subS" id="apidoc.element.ml.Math.SparseMatrix.prototype.subS">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>subS
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function subSS(value) {
    this.forEachNonZero((i, j, v) =&#x3e; v - value);
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.subtract" id="apidoc.element.ml.Math.SparseMatrix.prototype.subtract">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>subtract
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function subtract(value) {
    if (typeof value === &#x27;number&#x27;) return this.subtractS(value);
    return this.subtractM(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.subtractM" id="apidoc.element.ml.Math.SparseMatrix.prototype.subtractM">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>subtractM
        <span class="apidocSignatureSpan">(matrix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function subtractMM(matrix) {
    matrix.forEachNonZero((i, j, v) =&#x3e; {
        this.set(i, j, this.get(i, j) - v);
        return v;
    });
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.subtractS" id="apidoc.element.ml.Math.SparseMatrix.prototype.subtractS">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>subtractS
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function subtractSS(value) {
    this.forEachNonZero((i, j, v) =&#x3e; v - value);
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.tan" id="apidoc.element.ml.Math.SparseMatrix.prototype.tan">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>tan
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function tan() {
    this.forEachNonZero((i, j, v) =&#x3e; Math.tan(v));
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.tanh" id="apidoc.element.ml.Math.SparseMatrix.prototype.tanh">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>tanh
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function tanh() {
    this.forEachNonZero((i, j, v) =&#x3e; Math.tanh(v));
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.tensorProduct" id="apidoc.element.ml.Math.SparseMatrix.prototype.tensorProduct">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>tensorProduct
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">kroneckerProduct(other) {
    const m = this.rows;
    const n = this.columns;
    const p = other.rows;
    const q = other.columns;

    const result = new SparseMatrix(m * p, n * q, {
        initialCapacity: this.cardinality * other.cardinality
    });
    this.forEachNonZero((i, j, v1) =&#x3e; {
        other.forEachNonZero((k, l, v2) =&#x3e; {
            result.set(p * i + k, q * j + l, v1 * v2);
            return v2;
        });
        return v1;
    });
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.trunc" id="apidoc.element.ml.Math.SparseMatrix.prototype.trunc">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>trunc
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function trunc() {
    this.forEachNonZero((i, j, v) =&#x3e; Math.trunc(v));
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.xor" id="apidoc.element.ml.Math.SparseMatrix.prototype.xor">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>xor
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function xor(value) {
    if (typeof value === &#x27;number&#x27;) return this.xorS(value);
    return this.xorM(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.xorM" id="apidoc.element.ml.Math.SparseMatrix.prototype.xorM">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>xorM
        <span class="apidocSignatureSpan">(matrix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function xorMM(matrix) {
    matrix.forEachNonZero((i, j, v) =&#x3e; {
        this.set(i, j, this.get(i, j) ^ v);
        return v;
    });
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.xorS" id="apidoc.element.ml.Math.SparseMatrix.prototype.xorS">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>xorS
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function xorSS(value) {
    this.forEachNonZero((i, j, v) =&#x3e; v ^ value);
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.zeroFillRightShift" id="apidoc.element.ml.Math.SparseMatrix.prototype.zeroFillRightShift">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>zeroFillRightShift
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function zeroFillRightShift(value) {
    if (typeof value === &#x27;number&#x27;) return this.zeroFillRightShiftS(value);
    return this.zeroFillRightShiftM(value);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.zeroFillRightShiftM" id="apidoc.element.ml.Math.SparseMatrix.prototype.zeroFillRightShiftM">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>zeroFillRightShiftM
        <span class="apidocSignatureSpan">(matrix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function zeroFillRightShiftMM(matrix) {
    matrix.forEachNonZero((i, j, v) =&#x3e; {
        this.set(i, j, this.get(i, j) &#x3e;&#x3e;&#x3e; v);
        return v;
    });
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Math.SparseMatrix.prototype.zeroFillRightShiftS" id="apidoc.element.ml.Math.SparseMatrix.prototype.zeroFillRightShiftS">
        function <span class="apidocSignatureSpan">ml.Math.SparseMatrix.prototype.</span>zeroFillRightShiftS
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function zeroFillRightShiftSS(value) {
    this.forEachNonZero((i, j, v) =&#x3e; v &#x3e;&#x3e;&#x3e; value);
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ml.Matrix" id="apidoc.module.ml.Matrix">module ml.Matrix</a></h1>


    <h2>
        <a href="#apidoc.element.ml.Matrix.Matrix" id="apidoc.element.ml.Matrix.Matrix">
        function <span class="apidocSignatureSpan">ml.</span>Matrix
        <span class="apidocSignatureSpan">(Array)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Matrix extends abstractMatrix(Array) {
    constructor(nRows, nColumns) {
        var i;
        if (arguments.length === 1 &#x26;&#x26; typeof nRows === &#x27;number&#x27;) {
            return new Array(nRows);
        }
        if (Matrix.isMatrix(nRows)) {
            return nRows.clone();
        } else if (Number.isInteger(nRows) &#x26;&#x26; nRows &#x3e; 0) { // Create an empty matrix
            super(nRows);
            if (Number.isInteger(nColumns) &#x26;&#x26; nColumns &#x3e; 0) {
                for (i = 0; i &#x3c; nRows; i++) {
                    this[i] = new Array(nColumns);
                }
            } else {
                throw new TypeError(&#x27;nColumns must be a positive integer&#x27;);
            }
        } else if (Array.isArray(nRows)) { // Copy the values from the 2D array
            const matrix = nRows;
            nRows = matrix.length;
            nColumns = matrix[0].length;
            if (typeof nColumns !== &#x27;number&#x27; || nColumns === 0) {
                throw new TypeError(&#x27;Data must be a 2D array with at least one element&#x27;);
            }
            super(nRows);
            for (i = 0; i &#x3c; nRows; i++) {
                if (matrix[i].length !== nColumns) {
                    throw new RangeError(&#x27;Inconsistent array dimensions&#x27;);
                }
                this[i] = [].concat(matrix[i]);
            }
        } else {
            throw new TypeError(&#x27;First argument must be a positive number or an array&#x27;);
        }
        this.rows = nRows;
        this.columns = nColumns;
        return this;
    }

    set(rowIndex, columnIndex, value) {
        this[rowIndex][columnIndex] = value;
        return this;
    }

    get(rowIndex, columnIndex) {
        return this[rowIndex][columnIndex];
    }

<span class="apidocCodeCommentSpan">    /**
     * Creates an exact and independent copy of the matrix
     * @return {Matrix}
     */
</span>    clone() {
        var newMatrix = new this.constructor[Symbol.species](this.rows, this.columns);
        for (var row = 0; row &#x3c; this.rows; row++) {
            for (var column = 0; column &#x3c; this.columns; column++) {
                newMatrix.set(row, column, this.get(row, column));
            }
        }
        return newMatrix;
    }

    /**
     * Removes a row from the given index
     * @param {number} index - Row index
     * @return {Matrix} this
     */
    removeRow(index) {
        util.checkRowIndex(this, index);
        if (this.rows === 1) {
            throw new RangeError(&#x27;A matrix cannot have less than one row&#x27;);
        }
        this.splice(index, 1);
        this.rows -= 1;
        return this;
    }

    /**
     * Adds a row at the given index
     * @param {number} [index = this.rows] - Row index
     * @param {Array|Matrix} array - Array or vector
     * @return {Matrix} this
     */
    addRow(index, array) {
        if (array === undefined) {
            array = index;
            index = this.rows;
        }
        util.checkRowIndex(this, index, true);
        array = util.checkRowVector(this, array, true);
        this.splice(index, 0, array);
        this.rows += 1;
        return this;
    }

    /**
     * Removes a column from the given index
     * @param {number} index - Column index
     * @return {Matrix} this
     */
    removeColumn(index) {
        util.checkColumnIndex(this, index);
        if (this.columns === 1) {
            throw new RangeError(&#x27;A matrix cannot have less than one column&#x27;);
        }
        for (var i = 0; i &#x3c; this.rows; i++) {
            this[i].splice(index, 1);
        }
        this.columns -= 1;
        return this;
    }

    /**
     * Adds a column at the given index
     * @param {number} [index = this.columns] - Column index
     * @param {Array|Matrix} array - Array or vector
     * @return {Matrix} this
     */
    addColumn(index, array) {
        if (typeof array === &#x27;undefined&#x27;) {
            array = index;
            index = this.columns;
        }
        util.checkColumnIndex(this, index, true);
        array = util.checkColumnVector(this, array);
        for (var i = 0; i &#x3c; this.rows; i++) {
            this[i].splice(index, 0, array[i]);
        } ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Matrix.abstractMatrix" id="apidoc.element.ml.Matrix.abstractMatrix">
        function <span class="apidocSignatureSpan">ml.Matrix.</span>abstractMatrix
        <span class="apidocSignatureSpan">(superCtor)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function abstractMatrix(superCtor) {
    if (superCtor === undefined) superCtor = Object;

<span class="apidocCodeCommentSpan">    /**
     * Real matrix
     * @class Matrix
     * @param {number|Array|Matrix} nRows - Number of rows of the new matrix,
     * 2D array containing the data or Matrix instance to clone
     * @param {number} [nColumns] - Number of columns of the new matrix
     */
</span>    class Matrix extends superCtor {
        static get [Symbol.species]() {
            return this;
        }

        /**
         * Constructs a Matrix with the chosen dimensions from a 1D array
         * @param {number} newRows - Number of rows
         * @param {number} newColumns - Number of columns
         * @param {Array} newData - A 1D array containing data for the matrix
         * @return {Matrix} - The new matrix
         */
        static from1DArray(newRows, newColumns, newData) {
            var length = newRows * newColumns;
            if (length !== newData.length) {
                throw new RangeError(&#x27;Data length does not match given dimensions&#x27;);
            }
            var newMatrix = new this(newRows, newColumns);
            for (var row = 0; row &#x3c; newRows; row++) {
                for (var column = 0; column &#x3c; newColumns; column++) {
                    newMatrix.set(row, column, newData[row * newColumns + column]);
                }
            }
            return newMatrix;
        }

        /**
         * Creates a row vector, a matrix with only one row.
         * @param {Array} newData - A 1D array containing data for the vector
         * @return {Matrix} - The new matrix
         */
        static rowVector(newData) {
            var vector = new this(1, newData.length);
            for (var i = 0; i &#x3c; newData.length; i++) {
                vector.set(0, i, newData[i]);
            }
            return vector;
        }

        /**
         * Creates a column vector, a matrix with only one column.
         * @param {Array} newData - A 1D array containing data for the vector
         * @return {Matrix} - The new matrix
         */
        static columnVector(newData) {
            var vector = new this(newData.length, 1);
            for (var i = 0; i &#x3c; newData.length; i++) {
                vector.set(i, 0, newData[i]);
            }
            return vector;
        }

        /**
         * Creates an empty matrix with the given dimensions. Values will be undefined. Same as using new Matrix(rows, columns).
         * @param {number} rows - Number of rows
         * @param {number} columns - Number of columns
         * @return {Matrix} - The new matrix
         */
        static empty(rows, columns) {
            return new this(rows, columns);
        }

        /**
         * Creates a matrix with the given dimensions. Values will be set to zero.
         * @param {number} rows - Number of rows
         * @param {number} columns - Number of columns
         * @return {Matrix} - The new matrix
         */
        static zeros(rows, columns) {
            return this.empty(rows, columns).fill(0);
        }

        /**
         * Creates a matrix with the given dimensions. Values will be set to one.
         * @param {number} rows - Number of rows
         * @param {number} columns - Number of columns
         * @return {Matrix} - The new matrix
         */
        static ones(rows, columns) {
            return this.empty(rows, columns).fill(1);
        }

        /**
         * Creates a matrix with the given dimensions. Values will be randomly set.
         * @param {number} rows - Number of rows
         * @param {number} columns - Number of columns
         * @param {function} [rng=Math.random] - Random number generator
         * @return {Matrix} The new matrix
         */
        static rand(rows, columns, rng) {
            if (rng === undefined) rng = Math.random;
            var matrix = this.empty(rows, columns);
            for (var i = 0; i &#x3c; rows; i++) {
                for (var j = 0; j &#x3c; columns; j++) {
                    matrix.set(i, j, rng());
                }
            }
            return matrix; ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Matrix.inv" id="apidoc.element.ml.Matrix.inv">
        function <span class="apidocSignatureSpan">ml.Matrix.</span>inv
        <span class="apidocSignatureSpan">(matrix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function inverse(matrix) {
    matrix = Matrix.checkMatrix(matrix);
    return solve(matrix, Matrix.eye(matrix.rows));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Matrix.inverse" id="apidoc.element.ml.Matrix.inverse">
        function <span class="apidocSignatureSpan">ml.Matrix.</span>inverse
        <span class="apidocSignatureSpan">(matrix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function inverse(matrix) {
    matrix = Matrix.checkMatrix(matrix);
    return solve(matrix, Matrix.eye(matrix.rows));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Matrix.solve" id="apidoc.element.ml.Matrix.solve">
        function <span class="apidocSignatureSpan">ml.Matrix.</span>solve
        <span class="apidocSignatureSpan">(leftHandSide, rightHandSide)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function solve(leftHandSide, rightHandSide) {
    leftHandSide = Matrix.checkMatrix(leftHandSide);
    rightHandSide = Matrix.checkMatrix(rightHandSide);
    return leftHandSide.isSquare() ? new LuDecomposition(leftHandSide).solve(rightHandSide) : new QrDecomposition(leftHandSide).
solve(rightHandSide);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ml.Matrix.DC" id="apidoc.module.ml.Matrix.DC">module ml.Matrix.DC</a></h1>


    <h2>
        <a href="#apidoc.element.ml.Matrix.DC.CHO" id="apidoc.element.ml.Matrix.DC.CHO">
        function <span class="apidocSignatureSpan">ml.Matrix.DC.</span>CHO
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function CholeskyDecomposition(value) {
    if (!(this instanceof CholeskyDecomposition)) {
        return new CholeskyDecomposition(value);
    }
    value = Matrix.checkMatrix(value);
    if (!value.isSymmetric()) {
        throw new Error(&#x27;Matrix is not symmetric&#x27;);
    }

    var a = value,
        dimension = a.rows,
        l = new Matrix(dimension, dimension),
        positiveDefinite = true,
        i, j, k;

    for (j = 0; j &#x3c; dimension; j++) {
        var Lrowj = l[j];
        var d = 0;
        for (k = 0; k &#x3c; j; k++) {
            var Lrowk = l[k];
            var s = 0;
            for (i = 0; i &#x3c; k; i++) {
                s += Lrowk[i] * Lrowj[i];
            }
            Lrowj[k] = s = (a[j][k] - s) / l[k][k];
            d = d + s * s;
        }

        d = a[j][j] - d;

        positiveDefinite &#x26;= (d &#x3e; 0);
        l[j][j] = Math.sqrt(Math.max(d, 0));
        for (k = j + 1; k &#x3c; dimension; k++) {
            l[j][k] = 0;
        }
    }

    if (!positiveDefinite) {
        throw new Error(&#x27;Matrix is not positive definite&#x27;);
    }

    this.L = l;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Matrix.DC.CholeskyDecomposition" id="apidoc.element.ml.Matrix.DC.CholeskyDecomposition">
        function <span class="apidocSignatureSpan">ml.Matrix.DC.</span>CholeskyDecomposition
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function CholeskyDecomposition(value) {
    if (!(this instanceof CholeskyDecomposition)) {
        return new CholeskyDecomposition(value);
    }
    value = Matrix.checkMatrix(value);
    if (!value.isSymmetric()) {
        throw new Error(&#x27;Matrix is not symmetric&#x27;);
    }

    var a = value,
        dimension = a.rows,
        l = new Matrix(dimension, dimension),
        positiveDefinite = true,
        i, j, k;

    for (j = 0; j &#x3c; dimension; j++) {
        var Lrowj = l[j];
        var d = 0;
        for (k = 0; k &#x3c; j; k++) {
            var Lrowk = l[k];
            var s = 0;
            for (i = 0; i &#x3c; k; i++) {
                s += Lrowk[i] * Lrowj[i];
            }
            Lrowj[k] = s = (a[j][k] - s) / l[k][k];
            d = d + s * s;
        }

        d = a[j][j] - d;

        positiveDefinite &#x26;= (d &#x3e; 0);
        l[j][j] = Math.sqrt(Math.max(d, 0));
        for (k = j + 1; k &#x3c; dimension; k++) {
            l[j][k] = 0;
        }
    }

    if (!positiveDefinite) {
        throw new Error(&#x27;Matrix is not positive definite&#x27;);
    }

    this.L = l;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Matrix.DC.EVD" id="apidoc.element.ml.Matrix.DC.EVD">
        function <span class="apidocSignatureSpan">ml.Matrix.DC.</span>EVD
        <span class="apidocSignatureSpan">(matrix, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EigenvalueDecomposition(matrix, options) {
    options = Object.assign({}, defaultOptions, options);
    if (!(this instanceof EigenvalueDecomposition)) {
        return new EigenvalueDecomposition(matrix, options);
    }
    matrix = Matrix.checkMatrix(matrix);
    if (!matrix.isSquare()) {
        throw new Error(&#x27;Matrix is not a square matrix&#x27;);
    }

    var n = matrix.columns,
        V = getFilled2DArray(n, n, 0),
        d = new Array(n),
        e = new Array(n),
        value = matrix,
        i, j;

    var isSymmetric = false;
    if (options.assumeSymmetric) {
        isSymmetric = true;
    } else {
        isSymmetric = matrix.isSymmetric();
    }

    if (isSymmetric) {
        for (i = 0; i &#x3c; n; i++) {
            for (j = 0; j &#x3c; n; j++) {
                V[i][j] = value.get(i, j);
            }
        }
        tred2(n, e, d, V);
        tql2(n, e, d, V);
    } else {
        var H = getFilled2DArray(n, n, 0),
            ort = new Array(n);
        for (j = 0; j &#x3c; n; j++) {
            for (i = 0; i &#x3c; n; i++) {
                H[i][j] = value.get(i, j);
            }
        }
        orthes(n, H, ort, V);
        hqr2(n, e, d, V, H);
    }

    this.n = n;
    this.e = e;
    this.d = d;
    this.V = V;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Matrix.DC.EigenvalueDecomposition" id="apidoc.element.ml.Matrix.DC.EigenvalueDecomposition">
        function <span class="apidocSignatureSpan">ml.Matrix.DC.</span>EigenvalueDecomposition
        <span class="apidocSignatureSpan">(matrix, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function EigenvalueDecomposition(matrix, options) {
    options = Object.assign({}, defaultOptions, options);
    if (!(this instanceof EigenvalueDecomposition)) {
        return new EigenvalueDecomposition(matrix, options);
    }
    matrix = Matrix.checkMatrix(matrix);
    if (!matrix.isSquare()) {
        throw new Error(&#x27;Matrix is not a square matrix&#x27;);
    }

    var n = matrix.columns,
        V = getFilled2DArray(n, n, 0),
        d = new Array(n),
        e = new Array(n),
        value = matrix,
        i, j;

    var isSymmetric = false;
    if (options.assumeSymmetric) {
        isSymmetric = true;
    } else {
        isSymmetric = matrix.isSymmetric();
    }

    if (isSymmetric) {
        for (i = 0; i &#x3c; n; i++) {
            for (j = 0; j &#x3c; n; j++) {
                V[i][j] = value.get(i, j);
            }
        }
        tred2(n, e, d, V);
        tql2(n, e, d, V);
    } else {
        var H = getFilled2DArray(n, n, 0),
            ort = new Array(n);
        for (j = 0; j &#x3c; n; j++) {
            for (i = 0; i &#x3c; n; i++) {
                H[i][j] = value.get(i, j);
            }
        }
        orthes(n, H, ort, V);
        hqr2(n, e, d, V, H);
    }

    this.n = n;
    this.e = e;
    this.d = d;
    this.V = V;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Matrix.DC.LU" id="apidoc.element.ml.Matrix.DC.LU">
        function <span class="apidocSignatureSpan">ml.Matrix.DC.</span>LU
        <span class="apidocSignatureSpan">(matrix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function LuDecomposition(matrix) {
    if (!(this instanceof LuDecomposition)) {
        return new LuDecomposition(matrix);
    }

    matrix = Matrix.Matrix.checkMatrix(matrix);

    var lu = matrix.clone(),
        rows = lu.rows,
        columns = lu.columns,
        pivotVector = new Array(rows),
        pivotSign = 1,
        i, j, k, p, s, t, v,
        LUrowi, LUcolj, kmax;

    for (i = 0; i &#x3c; rows; i++) {
        pivotVector[i] = i;
    }

    LUcolj = new Array(rows);

    for (j = 0; j &#x3c; columns; j++) {

        for (i = 0; i &#x3c; rows; i++) {
            LUcolj[i] = lu[i][j];
        }

        for (i = 0; i &#x3c; rows; i++) {
            LUrowi = lu[i];
            kmax = Math.min(i, j);
            s = 0;
            for (k = 0; k &#x3c; kmax; k++) {
                s += LUrowi[k] * LUcolj[k];
            }
            LUrowi[j] = LUcolj[i] -= s;
        }

        p = j;
        for (i = j + 1; i &#x3c; rows; i++) {
            if (Math.abs(LUcolj[i]) &#x3e; Math.abs(LUcolj[p])) {
                p = i;
            }
        }

        if (p !== j) {
            for (k = 0; k &#x3c; columns; k++) {
                t = lu[p][k];
                lu[p][k] = lu[j][k];
                lu[j][k] = t;
            }

            v = pivotVector[p];
            pivotVector[p] = pivotVector[j];
            pivotVector[j] = v;

            pivotSign = -pivotSign;
        }

        if (j &#x3c; rows &#x26;&#x26; lu[j][j] !== 0) {
            for (i = j + 1; i &#x3c; rows; i++) {
                lu[i][j] /= lu[j][j];
            }
        }
    }

    this.LU = lu;
    this.pivotVector = pivotVector;
    this.pivotSign = pivotSign;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Matrix.DC.LuDecomposition" id="apidoc.element.ml.Matrix.DC.LuDecomposition">
        function <span class="apidocSignatureSpan">ml.Matrix.DC.</span>LuDecomposition
        <span class="apidocSignatureSpan">(matrix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function LuDecomposition(matrix) {
    if (!(this instanceof LuDecomposition)) {
        return new LuDecomposition(matrix);
    }

    matrix = Matrix.Matrix.checkMatrix(matrix);

    var lu = matrix.clone(),
        rows = lu.rows,
        columns = lu.columns,
        pivotVector = new Array(rows),
        pivotSign = 1,
        i, j, k, p, s, t, v,
        LUrowi, LUcolj, kmax;

    for (i = 0; i &#x3c; rows; i++) {
        pivotVector[i] = i;
    }

    LUcolj = new Array(rows);

    for (j = 0; j &#x3c; columns; j++) {

        for (i = 0; i &#x3c; rows; i++) {
            LUcolj[i] = lu[i][j];
        }

        for (i = 0; i &#x3c; rows; i++) {
            LUrowi = lu[i];
            kmax = Math.min(i, j);
            s = 0;
            for (k = 0; k &#x3c; kmax; k++) {
                s += LUrowi[k] * LUcolj[k];
            }
            LUrowi[j] = LUcolj[i] -= s;
        }

        p = j;
        for (i = j + 1; i &#x3c; rows; i++) {
            if (Math.abs(LUcolj[i]) &#x3e; Math.abs(LUcolj[p])) {
                p = i;
            }
        }

        if (p !== j) {
            for (k = 0; k &#x3c; columns; k++) {
                t = lu[p][k];
                lu[p][k] = lu[j][k];
                lu[j][k] = t;
            }

            v = pivotVector[p];
            pivotVector[p] = pivotVector[j];
            pivotVector[j] = v;

            pivotSign = -pivotSign;
        }

        if (j &#x3c; rows &#x26;&#x26; lu[j][j] !== 0) {
            for (i = j + 1; i &#x3c; rows; i++) {
                lu[i][j] /= lu[j][j];
            }
        }
    }

    this.LU = lu;
    this.pivotVector = pivotVector;
    this.pivotSign = pivotSign;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Matrix.DC.QR" id="apidoc.element.ml.Matrix.DC.QR">
        function <span class="apidocSignatureSpan">ml.Matrix.DC.</span>QR
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function QrDecomposition(value) {
    if (!(this instanceof QrDecomposition)) {
        return new QrDecomposition(value);
    }
    value = Matrix.checkMatrix(value);

    var qr = value.clone(),
        m = value.rows,
        n = value.columns,
        rdiag = new Array(n),
        i, j, k, s;

    for (k = 0; k &#x3c; n; k++) {
        var nrm = 0;
        for (i = k; i &#x3c; m; i++) {
            nrm = hypotenuse(nrm, qr[i][k]);
        }
        if (nrm !== 0) {
            if (qr[k][k] &#x3c; 0) {
                nrm = -nrm;
            }
            for (i = k; i &#x3c; m; i++) {
                qr[i][k] /= nrm;
            }
            qr[k][k] += 1;
            for (j = k + 1; j &#x3c; n; j++) {
                s = 0;
                for (i = k; i &#x3c; m; i++) {
                    s += qr[i][k] * qr[i][j];
                }
                s = -s / qr[k][k];
                for (i = k; i &#x3c; m; i++) {
                    qr[i][j] += s * qr[i][k];
                }
            }
        }
        rdiag[k] = -nrm;
    }

    this.QR = qr;
    this.Rdiag = rdiag;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Matrix.DC.QrDecomposition" id="apidoc.element.ml.Matrix.DC.QrDecomposition">
        function <span class="apidocSignatureSpan">ml.Matrix.DC.</span>QrDecomposition
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function QrDecomposition(value) {
    if (!(this instanceof QrDecomposition)) {
        return new QrDecomposition(value);
    }
    value = Matrix.checkMatrix(value);

    var qr = value.clone(),
        m = value.rows,
        n = value.columns,
        rdiag = new Array(n),
        i, j, k, s;

    for (k = 0; k &#x3c; n; k++) {
        var nrm = 0;
        for (i = k; i &#x3c; m; i++) {
            nrm = hypotenuse(nrm, qr[i][k]);
        }
        if (nrm !== 0) {
            if (qr[k][k] &#x3c; 0) {
                nrm = -nrm;
            }
            for (i = k; i &#x3c; m; i++) {
                qr[i][k] /= nrm;
            }
            qr[k][k] += 1;
            for (j = k + 1; j &#x3c; n; j++) {
                s = 0;
                for (i = k; i &#x3c; m; i++) {
                    s += qr[i][k] * qr[i][j];
                }
                s = -s / qr[k][k];
                for (i = k; i &#x3c; m; i++) {
                    qr[i][j] += s * qr[i][k];
                }
            }
        }
        rdiag[k] = -nrm;
    }

    this.QR = qr;
    this.Rdiag = rdiag;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Matrix.DC.SVD" id="apidoc.element.ml.Matrix.DC.SVD">
        function <span class="apidocSignatureSpan">ml.Matrix.DC.</span>SVD
        <span class="apidocSignatureSpan">(value, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SingularValueDecomposition(value, options) {
    if (!(this instanceof SingularValueDecomposition)) {
        return new SingularValueDecomposition(value, options);
    }
    value = Matrix.Matrix.checkMatrix(value);

    options = options || {};

    var m = value.rows,
        n = value.columns,
        nu = Math.min(m, n);

    var wantu = true, wantv = true;
    if (options.computeLeftSingularVectors === false) wantu = false;
    if (options.computeRightSingularVectors === false) wantv = false;
    var autoTranspose = options.autoTranspose === true;

    var swapped = false;
    var a;
    if (m &#x3c; n) {
        if (!autoTranspose) {
            a = value.clone();
            // eslint-disable-next-line no-console
            console.warn(&#x27;Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose&#x27;);
        } else {
            a = value.transpose();
            m = a.rows;
            n = a.columns;
            swapped = true;
            var aux = wantu;
            wantu = wantv;
            wantv = aux;
        }
    } else {
        a = value.clone();
    }

    var s = new Array(Math.min(m + 1, n)),
        U = getFilled2DArray(m, nu, 0),
        V = getFilled2DArray(n, n, 0),
        e = new Array(n),
        work = new Array(m);

    var nct = Math.min(m - 1, n);
    var nrt = Math.max(0, Math.min(n - 2, m));

    var i, j, k, p, t, ks, f, cs, sn, max, kase,
        scale, sp, spm1, epm1, sk, ek, b, c, shift, g;

    for (k = 0, max = Math.max(nct, nrt); k &#x3c; max; k++) {
        if (k &#x3c; nct) {
            s[k] = 0;
            for (i = k; i &#x3c; m; i++) {
                s[k] = hypotenuse(s[k], a[i][k]);
            }
            if (s[k] !== 0) {
                if (a[k][k] &#x3c; 0) {
                    s[k] = -s[k];
                }
                for (i = k; i &#x3c; m; i++) {
                    a[i][k] /= s[k];
                }
                a[k][k] += 1;
            }
            s[k] = -s[k];
        }

        for (j = k + 1; j &#x3c; n; j++) {
            if ((k &#x3c; nct) &#x26;&#x26; (s[k] !== 0)) {
                t = 0;
                for (i = k; i &#x3c; m; i++) {
                    t += a[i][k] * a[i][j];
                }
                t = -t / a[k][k];
                for (i = k; i &#x3c; m; i++) {
                    a[i][j] += t * a[i][k];
                }
            }
            e[j] = a[k][j];
        }

        if (wantu &#x26;&#x26; (k &#x3c; nct)) {
            for (i = k; i &#x3c; m; i++) {
                U[i][k] = a[i][k];
            }
        }

        if (k &#x3c; nrt) {
            e[k] = 0;
            for (i = k + 1; i &#x3c; n; i++) {
                e[k] = hypotenuse(e[k], e[i]);
            }
            if (e[k] !== 0) {
                if (e[k + 1] &#x3c; 0) {
                    e[k] = 0 - e[k];
                }
                for (i = k + 1; i &#x3c; n; i++) {
                    e[i] /= e[k];
                }
                e[k + 1] += 1;
            }
            e[k] = -e[k];
            if ((k + 1 &#x3c; m) &#x26;&#x26; (e[k] !== 0)) {
                for (i = k + 1; i &#x3c; m; i++) {
                    work[i] = 0;
                }
                for (j = k + 1; j &#x3c; n; j++) {
                    for (i = k + 1; i &#x3c; m; i++) {
                        work[i] += e[j] * a[i][j];
                    }
                }
                for (j = k + 1; j &#x3c; n; j++) {
                    t = -e[j] / e[k + 1];
                    for (i = k + 1; i &#x3c; m; i++) {
                        a[i][j] += t * work[i];
                    }
                }
            }
            if (wantv) {
                for (i = k + 1; i &#x3c; n; i++) {
                    V[i][k] = e[i];
                }
            }
        }
    }

    p = Math.min(n, m + 1);
    if (nct &#x3c; n) {
        s[nct] = a[nct][nct];
    }
    if (m &#x3c; p) {
        s[p - 1] = 0;
    }
    if (nrt + 1 &#x3c; p) {
        e[nrt] = a[nrt][p - 1];
    }
    e[p - 1] = 0;

    if (wantu) {
        for (j = nct; j &#x3c; nu; j++) {
            for (i = 0; i &#x3c; m; i++) {
                U[i][j] = 0;
            }
            U[j][j] = 1;
        }
        for (k = nct - 1; k &#x3e;= 0; k ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Matrix.DC.SingularValueDecomposition" id="apidoc.element.ml.Matrix.DC.SingularValueDecomposition">
        function <span class="apidocSignatureSpan">ml.Matrix.DC.</span>SingularValueDecomposition
        <span class="apidocSignatureSpan">(value, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SingularValueDecomposition(value, options) {
    if (!(this instanceof SingularValueDecomposition)) {
        return new SingularValueDecomposition(value, options);
    }
    value = Matrix.Matrix.checkMatrix(value);

    options = options || {};

    var m = value.rows,
        n = value.columns,
        nu = Math.min(m, n);

    var wantu = true, wantv = true;
    if (options.computeLeftSingularVectors === false) wantu = false;
    if (options.computeRightSingularVectors === false) wantv = false;
    var autoTranspose = options.autoTranspose === true;

    var swapped = false;
    var a;
    if (m &#x3c; n) {
        if (!autoTranspose) {
            a = value.clone();
            // eslint-disable-next-line no-console
            console.warn(&#x27;Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose&#x27;);
        } else {
            a = value.transpose();
            m = a.rows;
            n = a.columns;
            swapped = true;
            var aux = wantu;
            wantu = wantv;
            wantv = aux;
        }
    } else {
        a = value.clone();
    }

    var s = new Array(Math.min(m + 1, n)),
        U = getFilled2DArray(m, nu, 0),
        V = getFilled2DArray(n, n, 0),
        e = new Array(n),
        work = new Array(m);

    var nct = Math.min(m - 1, n);
    var nrt = Math.max(0, Math.min(n - 2, m));

    var i, j, k, p, t, ks, f, cs, sn, max, kase,
        scale, sp, spm1, epm1, sk, ek, b, c, shift, g;

    for (k = 0, max = Math.max(nct, nrt); k &#x3c; max; k++) {
        if (k &#x3c; nct) {
            s[k] = 0;
            for (i = k; i &#x3c; m; i++) {
                s[k] = hypotenuse(s[k], a[i][k]);
            }
            if (s[k] !== 0) {
                if (a[k][k] &#x3c; 0) {
                    s[k] = -s[k];
                }
                for (i = k; i &#x3c; m; i++) {
                    a[i][k] /= s[k];
                }
                a[k][k] += 1;
            }
            s[k] = -s[k];
        }

        for (j = k + 1; j &#x3c; n; j++) {
            if ((k &#x3c; nct) &#x26;&#x26; (s[k] !== 0)) {
                t = 0;
                for (i = k; i &#x3c; m; i++) {
                    t += a[i][k] * a[i][j];
                }
                t = -t / a[k][k];
                for (i = k; i &#x3c; m; i++) {
                    a[i][j] += t * a[i][k];
                }
            }
            e[j] = a[k][j];
        }

        if (wantu &#x26;&#x26; (k &#x3c; nct)) {
            for (i = k; i &#x3c; m; i++) {
                U[i][k] = a[i][k];
            }
        }

        if (k &#x3c; nrt) {
            e[k] = 0;
            for (i = k + 1; i &#x3c; n; i++) {
                e[k] = hypotenuse(e[k], e[i]);
            }
            if (e[k] !== 0) {
                if (e[k + 1] &#x3c; 0) {
                    e[k] = 0 - e[k];
                }
                for (i = k + 1; i &#x3c; n; i++) {
                    e[i] /= e[k];
                }
                e[k + 1] += 1;
            }
            e[k] = -e[k];
            if ((k + 1 &#x3c; m) &#x26;&#x26; (e[k] !== 0)) {
                for (i = k + 1; i &#x3c; m; i++) {
                    work[i] = 0;
                }
                for (j = k + 1; j &#x3c; n; j++) {
                    for (i = k + 1; i &#x3c; m; i++) {
                        work[i] += e[j] * a[i][j];
                    }
                }
                for (j = k + 1; j &#x3c; n; j++) {
                    t = -e[j] / e[k + 1];
                    for (i = k + 1; i &#x3c; m; i++) {
                        a[i][j] += t * work[i];
                    }
                }
            }
            if (wantv) {
                for (i = k + 1; i &#x3c; n; i++) {
                    V[i][k] = e[i];
                }
            }
        }
    }

    p = Math.min(n, m + 1);
    if (nct &#x3c; n) {
        s[nct] = a[nct][nct];
    }
    if (m &#x3c; p) {
        s[p - 1] = 0;
    }
    if (nrt + 1 &#x3c; p) {
        e[nrt] = a[nrt][p - 1];
    }
    e[p - 1] = 0;

    if (wantu) {
        for (j = nct; j &#x3c; nu; j++) {
            for (i = 0; i &#x3c; m; i++) {
                U[i][j] = 0;
            }
            U[j][j] = 1;
        }
        for (k = nct - 1; k &#x3e;= 0; k ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Matrix.DC.inverse" id="apidoc.element.ml.Matrix.DC.inverse">
        function <span class="apidocSignatureSpan">ml.Matrix.DC.</span>inverse
        <span class="apidocSignatureSpan">(matrix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function inverse(matrix) {
    matrix = Matrix.checkMatrix(matrix);
    return solve(matrix, Matrix.eye(matrix.rows));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Matrix.DC.solve" id="apidoc.element.ml.Matrix.DC.solve">
        function <span class="apidocSignatureSpan">ml.Matrix.DC.</span>solve
        <span class="apidocSignatureSpan">(leftHandSide, rightHandSide)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function solve(leftHandSide, rightHandSide) {
    leftHandSide = Matrix.checkMatrix(leftHandSide);
    rightHandSide = Matrix.checkMatrix(rightHandSide);
    return leftHandSide.isSquare() ? new LuDecomposition(leftHandSide).solve(rightHandSide) : new QrDecomposition(leftHandSide).
solve(rightHandSide);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ml.Matrix.DC.CholeskyDecomposition.prototype" id="apidoc.module.ml.Matrix.DC.CholeskyDecomposition.prototype">module ml.Matrix.DC.CholeskyDecomposition.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.ml.Matrix.DC.CholeskyDecomposition.prototype.solve" id="apidoc.element.ml.Matrix.DC.CholeskyDecomposition.prototype.solve">
        function <span class="apidocSignatureSpan">ml.Matrix.DC.CholeskyDecomposition.prototype.</span>solve
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">solve = function (value) {
    value = Matrix.checkMatrix(value);

    var l = this.L,
        dimension = l.rows;

    if (value.rows !== dimension) {
        throw new Error(&#x27;Matrix dimensions do not match&#x27;);
    }

    var count = value.columns,
        B = value.clone(),
        i, j, k;

    for (k = 0; k &#x3c; dimension; k++) {
        for (j = 0; j &#x3c; count; j++) {
            for (i = 0; i &#x3c; k; i++) {
                B[k][j] -= B[i][j] * l[k][i];
            }
            B[k][j] /= l[k][k];
        }
    }

    for (k = dimension - 1; k &#x3e;= 0; k--) {
        for (j = 0; j &#x3c; count; j++) {
            for (i = k + 1; i &#x3c; dimension; i++) {
                B[k][j] -= B[i][j] * l[i][k];
            }
            B[k][j] /= l[k][k];
        }
    }

    return B;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ml.Matrix.DC.LuDecomposition.prototype" id="apidoc.module.ml.Matrix.DC.LuDecomposition.prototype">module ml.Matrix.DC.LuDecomposition.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.ml.Matrix.DC.LuDecomposition.prototype.isSingular" id="apidoc.element.ml.Matrix.DC.LuDecomposition.prototype.isSingular">
        function <span class="apidocSignatureSpan">ml.Matrix.DC.LuDecomposition.prototype.</span>isSingular
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isSingular = function () {
    var data = this.LU,
        col = data.columns;
    for (var j = 0; j &#x3c; col; j++) {
        if (data[j][j] === 0) {
            return true;
        }
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Matrix.DC.LuDecomposition.prototype.solve" id="apidoc.element.ml.Matrix.DC.LuDecomposition.prototype.solve">
        function <span class="apidocSignatureSpan">ml.Matrix.DC.LuDecomposition.prototype.</span>solve
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">solve = function (value) {
    value = Matrix.Matrix.checkMatrix(value);

    var lu = this.LU,
        rows = lu.rows;

    if (rows !== value.rows) {
        throw new Error(&#x27;Invalid matrix dimensions&#x27;);
    }
    if (this.isSingular()) {
        throw new Error(&#x27;LU matrix is singular&#x27;);
    }

    var count = value.columns;
    var X = value.subMatrixRow(this.pivotVector, 0, count - 1);
    var columns = lu.columns;
    var i, j, k;

    for (k = 0; k &#x3c; columns; k++) {
        for (i = k + 1; i &#x3c; columns; i++) {
            for (j = 0; j &#x3c; count; j++) {
                X[i][j] -= X[k][j] * lu[i][k];
            }
        }
    }
    for (k = columns - 1; k &#x3e;= 0; k--) {
        for (j = 0; j &#x3c; count; j++) {
            X[k][j] /= lu[k][k];
        }
        for (i = 0; i &#x3c; k; i++) {
            for (j = 0; j &#x3c; count; j++) {
                X[i][j] -= X[k][j] * lu[i][k];
            }
        }
    }
    return X;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ml.Matrix.DC.QrDecomposition.prototype" id="apidoc.module.ml.Matrix.DC.QrDecomposition.prototype">module ml.Matrix.DC.QrDecomposition.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.ml.Matrix.DC.QrDecomposition.prototype.isFullRank" id="apidoc.element.ml.Matrix.DC.QrDecomposition.prototype.isFullRank">
        function <span class="apidocSignatureSpan">ml.Matrix.DC.QrDecomposition.prototype.</span>isFullRank
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isFullRank = function () {
    var columns = this.QR.columns;
    for (var i = 0; i &#x3c; columns; i++) {
        if (this.Rdiag[i] === 0) {
            return false;
        }
    }
    return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Matrix.DC.QrDecomposition.prototype.solve" id="apidoc.element.ml.Matrix.DC.QrDecomposition.prototype.solve">
        function <span class="apidocSignatureSpan">ml.Matrix.DC.QrDecomposition.prototype.</span>solve
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">solve = function (value) {
    value = Matrix.checkMatrix(value);

    var qr = this.QR,
        m = qr.rows;

    if (value.rows !== m) {
        throw new Error(&#x27;Matrix row dimensions must agree&#x27;);
    }
    if (!this.isFullRank()) {
        throw new Error(&#x27;Matrix is rank deficient&#x27;);
    }

    var count = value.columns;
    var X = value.clone();
    var n = qr.columns;
    var i, j, k, s;

    for (k = 0; k &#x3c; n; k++) {
        for (j = 0; j &#x3c; count; j++) {
            s = 0;
            for (i = k; i &#x3c; m; i++) {
                s += qr[i][k] * X[i][j];
            }
            s = -s / qr[k][k];
            for (i = k; i &#x3c; m; i++) {
                X[i][j] += s * qr[i][k];
            }
        }
    }
    for (k = n - 1; k &#x3e;= 0; k--) {
        for (j = 0; j &#x3c; count; j++) {
            X[k][j] /= this.Rdiag[k];
        }
        for (i = 0; i &#x3c; k; i++) {
            for (j = 0; j &#x3c; count; j++) {
                X[i][j] -= X[k][j] * qr[i][k];
            }
        }
    }

    return X.subMatrix(0, n - 1, 0, count - 1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ml.Matrix.DC.SingularValueDecomposition.prototype" id="apidoc.module.ml.Matrix.DC.SingularValueDecomposition.prototype">module ml.Matrix.DC.SingularValueDecomposition.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.ml.Matrix.DC.SingularValueDecomposition.prototype.inverse" id="apidoc.element.ml.Matrix.DC.SingularValueDecomposition.prototype.inverse">
        function <span class="apidocSignatureSpan">ml.Matrix.DC.SingularValueDecomposition.prototype.</span>inverse
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inverse = function () {
    var V = this.V;
    var e = this.threshold,
        vrows = V.length,
        vcols = V[0].length,
        X = new Matrix.Matrix(vrows, this.s.length),
        i, j;

    for (i = 0; i &#x3c; vrows; i++) {
        for (j = 0; j &#x3c; vcols; j++) {
            if (Math.abs(this.s[j]) &#x3e; e) {
                X[i][j] = V[i][j] / this.s[j];
            } else {
                X[i][j] = 0;
            }
        }
    }

    var U = this.U;

    var urows = U.length,
        ucols = U[0].length,
        Y = new Matrix.Matrix(vrows, urows),
        k, sum;

    for (i = 0; i &#x3c; vrows; i++) {
        for (j = 0; j &#x3c; urows; j++) {
            sum = 0;
            for (k = 0; k &#x3c; ucols; k++) {
                sum += X[i][k] * U[j][k];
            }
            Y[i][j] = sum;
        }
    }

    return Y;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Matrix.DC.SingularValueDecomposition.prototype.solve" id="apidoc.element.ml.Matrix.DC.SingularValueDecomposition.prototype.solve">
        function <span class="apidocSignatureSpan">ml.Matrix.DC.SingularValueDecomposition.prototype.</span>solve
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">solve = function (value) {

    var Y = value,
        e = this.threshold,
        scols = this.s.length,
        Ls = Matrix.Matrix.zeros(scols, scols),
        i;

    for (i = 0; i &#x3c; scols; i++) {
        if (Math.abs(this.s[i]) &#x3c;= e) {
            Ls[i][i] = 0;
        } else {
            Ls[i][i] = 1 / this.s[i];
        }
    }

    var U = this.U;
    var V = this.rightSingularVectors;

    var VL = V.mmul(Ls),
        vrows = V.rows,
        urows = U.length,
        VLU = Matrix.Matrix.zeros(vrows, urows),
        j, k, sum;

    for (i = 0; i &#x3c; vrows; i++) {
        for (j = 0; j &#x3c; urows; j++) {
            sum = 0;
            for (k = 0; k &#x3c; scols; k++) {
                sum += VL[i][k] * U[j][k];
            }
            VLU[i][j] = sum;
        }
    }

    return VLU.mmul(Y);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Matrix.DC.SingularValueDecomposition.prototype.solveForDiagonal" id="apidoc.element.ml.Matrix.DC.SingularValueDecomposition.prototype.solveForDiagonal">
        function <span class="apidocSignatureSpan">ml.Matrix.DC.SingularValueDecomposition.prototype.</span>solveForDiagonal
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">solveForDiagonal = function (value) {
    return this.solve(Matrix.Matrix.diag(value));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ml.Matrix.algebra" id="apidoc.module.ml.Matrix.algebra">module ml.Matrix.algebra</a></h1>


    <h2>
        <a href="#apidoc.element.ml.Matrix.algebra.abs" id="apidoc.element.ml.Matrix.algebra.abs">
        function <span class="apidocSignatureSpan">ml.Matrix.algebra.</span>abs
        <span class="apidocSignatureSpan">(A)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function abs(A){
    if(typeof A===&#x27;number&#x27; )
        return Math.abs(A);
    var ii = A.rows, jj = A.columns;
    var result = new Matrix(ii,jj);
    for (var i = 0; i &#x3c; ii; i++) {
        for (var j = 0; j &#x3c; jj; j++) {
            result[i][j] = Math.abs(A[i][j]);

        }
    }
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Matrix.algebra.add" id="apidoc.element.ml.Matrix.algebra.add">
        function <span class="apidocSignatureSpan">ml.Matrix.algebra.</span>add
        <span class="apidocSignatureSpan">(A, B)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function add(A, B){
    if(typeof A == &#x27;number&#x27;&#x26;&#x26;typeof B === &#x27;number&#x27;)
        return A+B;
    if(typeof A == &#x27;number&#x27;)
        return this.add(B,A);

    var result = A.clone();
    return result.add(B);

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Matrix.algebra.diag" id="apidoc.element.ml.Matrix.algebra.diag">
        function <span class="apidocSignatureSpan">ml.Matrix.algebra.</span>diag
        <span class="apidocSignatureSpan">(A)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function diag(A){
    var diag = null;
    var rows = A.rows, cols = A.columns, j, r;
    //It is an array
    if(typeof cols === &#x22;undefined&#x22; &#x26;&#x26; (typeof A)==&#x27;object&#x27;){
        if(A[0]&#x26;&#x26;A[0].length){
            rows = A.length;
            cols = A[0].length;
            r = Math.min(rows,cols);
            diag = Matrix.zeros(cols, cols);
            for (j = 0; j &#x3c; cols; j++) {
                diag[j][j]=A[j][j];
            }
        }
        else{
            cols = A.length;
            diag = Matrix.zeros(cols, cols);
            for (j = 0; j &#x3c; cols; j++) {
                diag[j][j]=A[j];
            }
        }

    }
    if(rows == 1){
        diag = Matrix.zeros(cols, cols);
        for (j = 0; j &#x3c; cols; j++) {
            diag[j][j]=A[0][j];
        }
    }
    else{
        if(rows&#x3e;0 &#x26;&#x26; cols &#x3e; 0){
            r = Math.min(rows,cols);
            diag = new Array(r);
            for (j = 0; j &#x3c; r; j++) {
                diag[j] = A[j][j];
            }
        }
    }
    return diag;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Matrix.algebra.dotDivide" id="apidoc.element.ml.Matrix.algebra.dotDivide">
        function <span class="apidocSignatureSpan">ml.Matrix.algebra.</span>dotDivide
        <span class="apidocSignatureSpan">(A, B)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dotDivide(A, B){
    var result = A.clone();
    return result.div(B);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Matrix.algebra.dotMultiply" id="apidoc.element.ml.Matrix.algebra.dotMultiply">
        function <span class="apidocSignatureSpan">ml.Matrix.algebra.</span>dotMultiply
        <span class="apidocSignatureSpan">(A, B)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dotMultiply(A, B){
    var result = A.clone();
    return result.mul(B);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Matrix.algebra.dotPow" id="apidoc.element.ml.Matrix.algebra.dotPow">
        function <span class="apidocSignatureSpan">ml.Matrix.algebra.</span>dotPow
        <span class="apidocSignatureSpan">(A, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function dotPow(A, b){
    if(typeof A===&#x27;number&#x27; )
        return Math.pow(A,b);
    //console.log(A);
    var ii = A.rows, jj = A.columns;
    var result = new Matrix(ii,jj);
    for (var i = 0; i &#x3c; ii; i++) {
        for (var j = 0; j &#x3c; jj; j++) {
            result[i][j] = Math.pow(A[i][j],b);
        }
    }
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Matrix.algebra.exp" id="apidoc.element.ml.Matrix.algebra.exp">
        function <span class="apidocSignatureSpan">ml.Matrix.algebra.</span>exp
        <span class="apidocSignatureSpan">(A)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function exp(A){
    if(typeof A===&#x27;number&#x27; )
        return Math.sqrt(A);
    var ii = A.rows, jj = A.columns;
    var result = new Matrix(ii,jj);
    for (var i = 0; i &#x3c; ii; i++) {
        for (var j = 0; j &#x3c; jj; j++) {
            result[i][j] = Math.exp(A[i][j]);
        }
    }
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Matrix.algebra.eye" id="apidoc.element.ml.Matrix.algebra.eye">
        function <span class="apidocSignatureSpan">ml.Matrix.algebra.</span>eye
        <span class="apidocSignatureSpan">(rows, cols)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function eye(rows, cols){
    return Matrix.eye(rows, cols);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Matrix.algebra.inv" id="apidoc.element.ml.Matrix.algebra.inv">
        function <span class="apidocSignatureSpan">ml.Matrix.algebra.</span>inv
        <span class="apidocSignatureSpan">(A)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function inv(A){
    if(typeof A ===&#x22;number&#x22;)
        return 1/A;
    return A.inverse();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Matrix.algebra.matrix" id="apidoc.element.ml.Matrix.algebra.matrix">
        function <span class="apidocSignatureSpan">ml.Matrix.algebra.</span>matrix
        <span class="apidocSignatureSpan">(A, B)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function matrix(A, B){
    return new Matrix(A,B);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Matrix.algebra.max" id="apidoc.element.ml.Matrix.algebra.max">
        function <span class="apidocSignatureSpan">ml.Matrix.algebra.</span>max
        <span class="apidocSignatureSpan">(A, B)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function max(A, B){
    if(typeof A===&#x27;number&#x27; &#x26;&#x26; typeof B ===&#x27;number&#x27;)
        return Math.max(A,B);
    var ii = A.rows, jj = A.columns;
    var result = new Matrix(ii,jj);
    for (var i = 0; i &#x3c; ii; i++) {
        for (var j = 0; j &#x3c; jj; j++) {
            if (A[i][j] &#x3e; B[i][j]) {
                result[i][j] = A[i][j];
            }
            else{
                result[i][j] = B[i][j];
            }
        }
    }
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Matrix.algebra.min" id="apidoc.element.ml.Matrix.algebra.min">
        function <span class="apidocSignatureSpan">ml.Matrix.algebra.</span>min
        <span class="apidocSignatureSpan">(A, B)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function min(A, B){
    if(typeof A===&#x27;number&#x27; &#x26;&#x26; typeof B ===&#x27;number&#x27;)
        return Math.min(A,B);
    var ii = A.rows, jj = A.columns;
    var result = new Matrix(ii,jj);
    for (var i = 0; i &#x3c; ii; i++) {
        for (var j = 0; j &#x3c; jj; j++) {
            if (A[i][j] &#x3c; B[i][j]) {
                result[i][j] = A[i][j];
            }
            else{
                result[i][j] = B[i][j];
            }
        }
    }
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Matrix.algebra.multiply" id="apidoc.element.ml.Matrix.algebra.multiply">
        function <span class="apidocSignatureSpan">ml.Matrix.algebra.</span>multiply
        <span class="apidocSignatureSpan">(A, B)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function multiply(A, B){
    if(typeof A == &#x27;number&#x27;&#x26;&#x26;typeof B === &#x27;number&#x27;)
        return A*B;
    if(typeof A == &#x27;number&#x27;)
        return this.multiply(B,A);

    var result = A.clone();

    if(typeof B === &#x27;number&#x27;)
        result.mul(B);
    else
        result = result.mmul(B);

    if(result.rows==1&#x26;&#x26;result.columns==1)
        return result[0][0];
    else
        return result;

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Matrix.algebra.ones" id="apidoc.element.ml.Matrix.algebra.ones">
        function <span class="apidocSignatureSpan">ml.Matrix.algebra.</span>ones
        <span class="apidocSignatureSpan">(rows, cols)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ones(rows, cols){
    return Matrix.ones(rows,cols);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Matrix.algebra.random" id="apidoc.element.ml.Matrix.algebra.random">
        function <span class="apidocSignatureSpan">ml.Matrix.algebra.</span>random
        <span class="apidocSignatureSpan">(rows, cols)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function random(rows, cols){
    return Matrix.rand(rows,cols);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Matrix.algebra.solve" id="apidoc.element.ml.Matrix.algebra.solve">
        function <span class="apidocSignatureSpan">ml.Matrix.algebra.</span>solve
        <span class="apidocSignatureSpan">(A, B)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function solve(A, B){
    return A.solve(B);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Matrix.algebra.sqrt" id="apidoc.element.ml.Matrix.algebra.sqrt">
        function <span class="apidocSignatureSpan">ml.Matrix.algebra.</span>sqrt
        <span class="apidocSignatureSpan">(A)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sqrt(A){
    if(typeof A===&#x27;number&#x27; )
        return Math.sqrt(A);
    var ii = A.rows, jj = A.columns;
    var result = new Matrix(ii,jj);
    for (var i = 0; i &#x3c; ii; i++) {
        for (var j = 0; j &#x3c; jj; j++) {
            result[i][j] = Math.sqrt(A[i][j]);

        }
    }
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Matrix.algebra.subtract" id="apidoc.element.ml.Matrix.algebra.subtract">
        function <span class="apidocSignatureSpan">ml.Matrix.algebra.</span>subtract
        <span class="apidocSignatureSpan">(A, B)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function subtract(A, B){
    if(typeof A == &#x27;number&#x27;&#x26;&#x26;typeof B === &#x27;number&#x27;)
        return A-B;
    if(typeof A == &#x27;number&#x27;)
        return this.subtract(B,A);
    var result = A.clone();
    return result.sub(B);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Matrix.algebra.transpose" id="apidoc.element.ml.Matrix.algebra.transpose">
        function <span class="apidocSignatureSpan">ml.Matrix.algebra.</span>transpose
        <span class="apidocSignatureSpan">(A)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function transpose(A){
    if(typeof A == &#x27;number&#x27;)
        return A;
    var result = A.clone();
    return result.transpose();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Matrix.algebra.zeros" id="apidoc.element.ml.Matrix.algebra.zeros">
        function <span class="apidocSignatureSpan">ml.Matrix.algebra.</span>zeros
        <span class="apidocSignatureSpan">(rows, cols)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function zeros(rows, cols){
    return Matrix.zeros(rows, cols);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ml.Matrix.prototype" id="apidoc.module.ml.Matrix.prototype">module ml.Matrix.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.ml.Matrix.prototype.inv" id="apidoc.element.ml.Matrix.prototype.inv">
        function <span class="apidocSignatureSpan">ml.Matrix.prototype.</span>inv
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inv = function () {
    return inverse(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Matrix.prototype.inverse" id="apidoc.element.ml.Matrix.prototype.inverse">
        function <span class="apidocSignatureSpan">ml.Matrix.prototype.</span>inverse
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inverse = function () {
    return inverse(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Matrix.prototype.solve" id="apidoc.element.ml.Matrix.prototype.solve">
        function <span class="apidocSignatureSpan">ml.Matrix.prototype.</span>solve
        <span class="apidocSignatureSpan">(other)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">solve = function (other) {
    return solve(this, other);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ml.RNG" id="apidoc.module.ml.RNG">module ml.RNG</a></h1>


    <h2>
        <a href="#apidoc.element.ml.RNG.XSadd" id="apidoc.element.ml.RNG.XSadd">
        function <span class="apidocSignatureSpan">ml.RNG.</span>XSadd
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function XSadd() {
    var seed = arguments.length &#x3c;= 0 || arguments[0] === undefined ? Date.now() : arguments[0];

    _classCallCheck(this, XSadd);

    this.state = new Uint32Array(4);
    this.init(seed);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ml.Regression" id="apidoc.module.ml.Regression">module ml.Regression</a></h1>


    <h2>
        <a href="#apidoc.element.ml.Regression.KRR" id="apidoc.element.ml.Regression.KRR">
        function <span class="apidocSignatureSpan">ml.Regression.</span>KRR
        <span class="apidocSignatureSpan">(inputs, outputs, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class KernelRidgeRegression extends BaseRegression {
    constructor(inputs, outputs, options) {
        super();
        if (inputs === true) { // reloading model
            this.alpha = outputs.alpha;
            this.inputs = outputs.inputs;
            this.kernelType = outputs.kernelType;
            this.kernelOptions = outputs.kernelOptions;
            this.kernel = new Kernel(outputs.kernelType, outputs.kernelOptions);

            if (outputs.quality) {
                this.quality = outputs.quality;
            }
        } else {
            options = Object.assign({}, defaultOptions, options);

            const kernelFunction = new Kernel(options.kernelType, options.kernelOptions);
            const K = kernelFunction.compute(inputs);
            const n = inputs.length;
            K.add(Matrix.eye(n, n).mul(options.lambda));

            this.alpha = K.solve(outputs);
            this.inputs = inputs;
            this.kernelType = options.kernelType;
            this.kernelOptions = options.kernelOptions;
            this.kernel = kernelFunction;

            if (options.computeQuality) {
                this.quality = this.modelQuality(inputs, outputs);
            }
        }
    }

    _predict(newInputs) {
        return this.kernel.compute([newInputs], this.inputs).mmul(this.alpha)[0];
    }

    toJSON() {
        var out = {
            name: &#x27;kernelRidgeRegression&#x27;,
            alpha: this.alpha,
            inputs: this.inputs,
            kernelType: this.kernelType,
            kernelOptions: this.kernelOptions
        };
        if (this.quality) {
            out.quality = this.quality;
        }
        return out;
    }

    static load(json) {
        if (json.name !== &#x27;kernelRidgeRegression&#x27;) {
            throw new TypeError(&#x27;not a KRR model&#x27;);
        }
        return new KernelRidgeRegression(true, json);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Regression.KernelRidgeRegression" id="apidoc.element.ml.Regression.KernelRidgeRegression">
        function <span class="apidocSignatureSpan">ml.Regression.</span>KernelRidgeRegression
        <span class="apidocSignatureSpan">(inputs, outputs, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class KernelRidgeRegression extends BaseRegression {
    constructor(inputs, outputs, options) {
        super();
        if (inputs === true) { // reloading model
            this.alpha = outputs.alpha;
            this.inputs = outputs.inputs;
            this.kernelType = outputs.kernelType;
            this.kernelOptions = outputs.kernelOptions;
            this.kernel = new Kernel(outputs.kernelType, outputs.kernelOptions);

            if (outputs.quality) {
                this.quality = outputs.quality;
            }
        } else {
            options = Object.assign({}, defaultOptions, options);

            const kernelFunction = new Kernel(options.kernelType, options.kernelOptions);
            const K = kernelFunction.compute(inputs);
            const n = inputs.length;
            K.add(Matrix.eye(n, n).mul(options.lambda));

            this.alpha = K.solve(outputs);
            this.inputs = inputs;
            this.kernelType = options.kernelType;
            this.kernelOptions = options.kernelOptions;
            this.kernel = kernelFunction;

            if (options.computeQuality) {
                this.quality = this.modelQuality(inputs, outputs);
            }
        }
    }

    _predict(newInputs) {
        return this.kernel.compute([newInputs], this.inputs).mmul(this.alpha)[0];
    }

    toJSON() {
        var out = {
            name: &#x27;kernelRidgeRegression&#x27;,
            alpha: this.alpha,
            inputs: this.inputs,
            kernelType: this.kernelType,
            kernelOptions: this.kernelOptions
        };
        if (this.quality) {
            out.quality = this.quality;
        }
        return out;
    }

    static load(json) {
        if (json.name !== &#x27;kernelRidgeRegression&#x27;) {
            throw new TypeError(&#x27;not a KRR model&#x27;);
        }
        return new KernelRidgeRegression(true, json);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Regression.PolinomialFitting2D" id="apidoc.element.ml.Regression.PolinomialFitting2D">
        function <span class="apidocSignatureSpan">ml.Regression.</span>PolinomialFitting2D
        <span class="apidocSignatureSpan">(inputs, outputs, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class PolynomialFitRegression2D extends BaseRegression {
<span class="apidocCodeCommentSpan">    /**
     * Constructor for the 2D polynomial fitting
     *
     * @param inputs
     * @param outputs
     * @param options
     * @constructor
     */
</span>    constructor(inputs, outputs, options) {
        super();
        if (inputs === true) { // reloading model
            this.coefficients = Matrix.columnVector(outputs.coefficients);
            this.order = outputs.order;
            if (outputs.r) {
                this.r = outputs.r;
                this.r2 = outputs.r2;
            }
            if (outputs.chi2) {
                this.chi2 = outputs.chi2;
            }
        } else {
            options = Object.assign({}, defaultOptions, options);
            this.order = options.order;
            this.coefficients = [];
            this.X = inputs;
            this.y = outputs;

            this.train(this.X, this.y, options);

            if (options.computeQuality) {
                this.quality = this.modelQuality(inputs, outputs);
            }
        }
    }

    /**
     * Function that fits the model given the data(X) and predictions(y).
     * The third argument is an object with the following options:
     * * order: order of the polynomial to fit.
     *
     * @param {Matrix} X - A matrix with n rows and 2 columns.
     * @param {Matrix} y - A vector of the prediction values.
     */
    train(X, y) {
        if (!Matrix.isMatrix(X)) X = new Matrix(X);
        if (!Matrix.isMatrix(y)) y = Matrix.columnVector(y);

        //Perhaps y is transpose
        if (y.rows !== X.rows) {
            y = y.transpose();
        }

        if (X.columns !== 2) {
            throw new RangeError(&#x27;You give X with &#x27; + X.columns + &#x27; columns and it must be 2&#x27;);
        }
        if (X.rows !== y.rows) {
            throw new RangeError(&#x27;X and y must have the same rows&#x27;);
        }

        var examples = X.rows;
        var coefficients = ((this.order + 2) * (this.order + 1)) / 2;
        this.coefficients = new Array(coefficients);

        var x1 = X.getColumnVector(0);
        var x2 = X.getColumnVector(1);

        var scaleX1 = 1.0 / x1.clone().apply(abs).max();
        var scaleX2 = 1.0 / x2.clone().apply(abs).max();
        var scaleY = 1.0 / y.clone().apply(abs).max();

        x1.mulColumn(0, scaleX1);
        x2.mulColumn(0, scaleX2);
        y.mulColumn(0, scaleY);

        var A = new Matrix(examples, coefficients);
        var col = 0;

        for (var i = 0; i &#x3c;= this.order; ++i) {
            var limit = this.order - i;
            for (var j = 0; j &#x3c;= limit; ++j) {
                var result = powColVector(x1, i).mulColumnVector(powColVector(x2, j));
                A.setColumn(col, result);
                col++;
            }
        }

        var svd = new SVD(A.transpose(), {
            computeLeftSingularVectors: true,
            computeRightSingularVectors: true,
            autoTranspose: false
        });

        var qqs = Matrix.rowVector(svd.diagonal);
        qqs = qqs.apply(function (i, j) {
            if (this[i][j] &#x3e;= 1e-15) this[i][j] = 1 / this[i][j];
            else this[i][j] = 0;
        });

        var qqs1 = Matrix.zeros(examples, coefficients);
        for (i = 0; i &#x3c; coefficients; ++i) {
            qqs1[i][i] = qqs[0][i];
        }

        qqs = qqs1;

        var U = svd.rightSingularVectors;
        var V = svd.leftSingularVectors;

        this.coefficients = V.mmul(qqs.transpose()).mmul(U.transpose()).mmul(y);

        col = 0;

        for (i = 0; i &#x3c;= coefficients; ++i) {
            limit = this.order - i;
            for (j = 0; j &#x3c;= limit; ++j) {
                this.coefficients[col][0] = (this.coefficients[col][0] * Math.pow(scaleX1, i) * Math.pow(scaleX2, j)) / scaleY;
                col++;
            }
        }
    }

    _predict(newInputs) {
        var x1 = newInputs[0];
        var x2 = newInputs[1];

        var y = 0;
        var column = 0;

        for (var i = 0; i &#x3c;= this.order; i++) {
            for (var j = 0; j &#x3c;= this.order - i; j++) {
                y += Math.pow(x1, i) * ( ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Regression.SLR" id="apidoc.element.ml.Regression.SLR">
        function <span class="apidocSignatureSpan">ml.Regression.</span>SLR
        <span class="apidocSignatureSpan">(x, y, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class SimpleLinearRegression extends BaseRegression {

    constructor(x, y, options) {
        options = options || {};
        super();
        if (x === true) {
            this.slope = y.slope;
            this.intercept = y.intercept;
            this.quality = y.quality || {};
            if (y.quality.r) {
                this.quality.r = y.quality.r;
                this.quality.r2 = y.quality.r2;
            }
            if (y.quality.chi2) {
                this.quality.chi2 = y.quality.chi2;
            }
        } else {
            var n = x.length;
            if (n !== y.length) {
                throw new RangeError(&#x27;input and output array have a different length&#x27;);
            }

            var xSum = 0;
            var ySum = 0;

            var xSquared = 0;
            var xY = 0;

            for (var i = 0; i &#x3c; n; i++) {
                xSum += x[i];
                ySum += y[i];
                xSquared += x[i] * x[i];
                xY += x[i] * y[i];
            }

            var numerator = (n * xY - xSum * ySum);


            this.slope = numerator / (n * xSquared - xSum * xSum);
            this.intercept = (1 / n) * ySum - this.slope * (1 / n) * xSum;
            this.coefficients = [this.intercept, this.slope];
            if (options.computeQuality) {
                this.quality = this.modelQuality(x, y);
            }
        }

    }

    toJSON() {
        var out = {
            name: &#x27;simpleLinearRegression&#x27;,
            slope: this.slope,
            intercept: this.intercept
        };
        if (this.quality) {
            out.quality = this.quality;
        }

        return out;
    }

    _predict(input) {
        return this.slope * input + this.intercept;
    }

    computeX(input) {
        return (input - this.intercept) / this.slope;
    }

    toString(precision) {
        var result = &#x27;f(x) = &#x27;;
        if (this.slope) {
            var xFactor = maybeToPrecision(this.slope, precision);
            result += (Math.abs(xFactor - 1) &#x3c; 1e-5 ? &#x27;&#x27; : xFactor + &#x27; * &#x27;) + &#x27;x&#x27;;
            if (this.intercept) {
                var absIntercept = Math.abs(this.intercept);
                var operator = absIntercept === this.intercept ? &#x27;+&#x27; : &#x27;-&#x27;;
                result += &#x27; &#x27; + operator + &#x27; &#x27; + maybeToPrecision(absIntercept, precision);
            }
        } else {
            result += maybeToPrecision(this.intercept, precision);
        }
        return result;
    }

    toLaTeX(precision) {
        return this.toString(precision);
    }

    static load(json) {
        if (json.name !== &#x27;simpleLinearRegression&#x27;) {
            throw new TypeError(&#x27;not a SLR model&#x27;);
        }
        return new SimpleLinearRegression(true, json);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Regression.SimpleLinearRegression" id="apidoc.element.ml.Regression.SimpleLinearRegression">
        function <span class="apidocSignatureSpan">ml.Regression.</span>SimpleLinearRegression
        <span class="apidocSignatureSpan">(x, y, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class SimpleLinearRegression extends BaseRegression {

    constructor(x, y, options) {
        options = options || {};
        super();
        if (x === true) {
            this.slope = y.slope;
            this.intercept = y.intercept;
            this.quality = y.quality || {};
            if (y.quality.r) {
                this.quality.r = y.quality.r;
                this.quality.r2 = y.quality.r2;
            }
            if (y.quality.chi2) {
                this.quality.chi2 = y.quality.chi2;
            }
        } else {
            var n = x.length;
            if (n !== y.length) {
                throw new RangeError(&#x27;input and output array have a different length&#x27;);
            }

            var xSum = 0;
            var ySum = 0;

            var xSquared = 0;
            var xY = 0;

            for (var i = 0; i &#x3c; n; i++) {
                xSum += x[i];
                ySum += y[i];
                xSquared += x[i] * x[i];
                xY += x[i] * y[i];
            }

            var numerator = (n * xY - xSum * ySum);


            this.slope = numerator / (n * xSquared - xSum * xSum);
            this.intercept = (1 / n) * ySum - this.slope * (1 / n) * xSum;
            this.coefficients = [this.intercept, this.slope];
            if (options.computeQuality) {
                this.quality = this.modelQuality(x, y);
            }
        }

    }

    toJSON() {
        var out = {
            name: &#x27;simpleLinearRegression&#x27;,
            slope: this.slope,
            intercept: this.intercept
        };
        if (this.quality) {
            out.quality = this.quality;
        }

        return out;
    }

    _predict(input) {
        return this.slope * input + this.intercept;
    }

    computeX(input) {
        return (input - this.intercept) / this.slope;
    }

    toString(precision) {
        var result = &#x27;f(x) = &#x27;;
        if (this.slope) {
            var xFactor = maybeToPrecision(this.slope, precision);
            result += (Math.abs(xFactor - 1) &#x3c; 1e-5 ? &#x27;&#x27; : xFactor + &#x27; * &#x27;) + &#x27;x&#x27;;
            if (this.intercept) {
                var absIntercept = Math.abs(this.intercept);
                var operator = absIntercept === this.intercept ? &#x27;+&#x27; : &#x27;-&#x27;;
                result += &#x27; &#x27; + operator + &#x27; &#x27; + maybeToPrecision(absIntercept, precision);
            }
        } else {
            result += maybeToPrecision(this.intercept, precision);
        }
        return result;
    }

    toLaTeX(precision) {
        return this.toString(precision);
    }

    static load(json) {
        if (json.name !== &#x27;simpleLinearRegression&#x27;) {
            throw new TypeError(&#x27;not a SLR model&#x27;);
        }
        return new SimpleLinearRegression(true, json);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Regression.TheilSenRegression" id="apidoc.element.ml.Regression.TheilSenRegression">
        function <span class="apidocSignatureSpan">ml.Regression.</span>TheilSenRegression
        <span class="apidocSignatureSpan">(x, y, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class TheilSenRegression extends BaseRegression {

<span class="apidocCodeCommentSpan">    /**
     * Theil–Sen estimator
     * https://en.wikipedia.org/wiki/Theil%E2%80%93Sen_estimator
     * @param {Array&#x3c;number&#x3e;} x
     * @param {Array&#x3c;number&#x3e;} y
     * @param {object} options
     * @constructor
     */
</span>    constructor(x, y, options) {
        options = options || {};
        super();
        if (x === true) {
            // loads the model
            this.slope = y.slope;
            this.intercept = y.intercept;
            this.quality = Object.assign({}, y.quality, this.quality);
        } else {
            // creates the model
            let len = x.length;
            if (len !== y.length) {
                throw new RangeError(&#x27;Input and output array have a different length&#x27;);
            }

            let slopes = new Array(len * len);
            let count = 0;
            for (let i = 0; i &#x3c; len; ++i) {
                for (let j =  i + 1; j &#x3c; len; ++j) {
                    if (x[i] !== x[j]) {
                        slopes[count++] = (y[j] - y[i]) / (x[j] - x[i]);
                    }
                }
            }
            slopes.length = count;
            let medianSlope = median(slopes);

            let cuts = new Array(len);
            for (let i = 0; i &#x3c; len; ++i) {
                cuts[i] = y[i] - medianSlope * x[i];
            }

            this.slope = medianSlope;
            this.intercept = median(cuts);
            this.coefficients = [this.intercept, this.slope];
            if (options.computeQuality) {
                this.quality = this.modelQuality(x, y);
            }
        }

    }

    toJSON() {
        var out = {
            name: &#x27;TheilSenRegression&#x27;,
            slope: this.slope,
            intercept: this.intercept
        };
        if (this.quality) {
            out.quality = this.quality;
        }

        return out;
    }

    _predict(input) {
        return this.slope * input + this.intercept;
    }

    computeX(input) {
        return (input - this.intercept) / this.slope;
    }

    toString(precision) {
        var result = &#x27;f(x) = &#x27;;
        if (this.slope) {
            var xFactor = maybeToPrecision(this.slope, precision);
            result += (Math.abs(xFactor - 1) &#x3c; 1e-5 ? &#x27;&#x27; : xFactor + &#x27; * &#x27;) + &#x27;x&#x27;;
            if (this.intercept) {
                var absIntercept = Math.abs(this.intercept);
                var operator = absIntercept === this.intercept ? &#x27;+&#x27; : &#x27;-&#x27;;
                result += &#x27; &#x27; + operator + &#x27; &#x27; + maybeToPrecision(absIntercept, precision);
            }
        } else {
            result += maybeToPrecision(this.intercept, precision);
        }
        return result;
    }

    toLaTeX(precision) {
        return this.toString(precision);
    }

    static load(json) {
        if (json.name !== &#x27;TheilSenRegression&#x27;) {
            throw new TypeError(&#x27;not a Theil-Sen model&#x27;);
        }
        return new TheilSenRegression(true, json);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ml.Regression.NLR" id="apidoc.module.ml.Regression.NLR">module ml.Regression.NLR</a></h1>


    <h2>
        <a href="#apidoc.element.ml.Regression.NLR.ExpRegression" id="apidoc.element.ml.Regression.NLR.ExpRegression">
        function <span class="apidocSignatureSpan">ml.Regression.NLR.</span>ExpRegression
        <span class="apidocSignatureSpan">(x, y, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class ExpRegression extends BaseRegression {
<span class="apidocCodeCommentSpan">    /**
     * @constructor
     * @param {Array&#x3c;number&#x3e;} x - Independent variable
     * @param {Array&#x3c;number&#x3e;} y - Dependent variable
     * @param {object} options
     */
</span>    constructor(x, y, options) {
        super();
        let opt = options || {};
        if (x === true) { // reloading model
            this.A = y.A;
            this.C = y.C;
            if (y.quality) {
                this.quality = y.quality;
            }
        } else {
            var n = x.length;
            if (n !== y.length) {
                throw new RangeError(&#x27;input and output array have a different length&#x27;);
            }
            var yl = new Array(n);
            for (var i = 0; i &#x3c; n; i++) {
                yl[i] = Math.log(y[i]);
            }

            var linear = new SimpleLinearRegression(x, yl, {computeCoefficient: false});
            this.A = linear.slope;
            this.C = Math.exp(linear.intercept);
            if (opt.computeQuality) {
                this.quality = this.modelQuality(x, y);
            }
        }
    }

    _predict(newInputs) {
        return this.C * Math.exp(newInputs * this.A);
    }

    toJSON() {
        var out = {name: &#x27;expRegression&#x27;, A: this.A, C: this.C};
        if (this.quality) {
            out.quality = this.quality;
        }
        return out;
    }

    toString(precision) {
        return &#x27;f(x) = &#x27; + maybeToPrecision(this.C, precision) + &#x27; * exp(&#x27; + maybeToPrecision(this.A, precision) + &#x27; * x)&#x27;;
    }

    toLaTeX(precision) {
        if (this.A &#x3e;= 0) {
            return &#x27;f(x) = &#x27; + maybeToPrecision(this.C, precision) + &#x27;e^{&#x27; + maybeToPrecision(this.A, precision) + &#x27;x}&#x27;;
        } else {
            return &#x27;f(x) = \\frac{&#x27; + maybeToPrecision(this.C, precision) + &#x27;}{e^{&#x27; + maybeToPrecision(-this.A, precision) + &#x27;x}}&#x27;;
        }

    }

    static load(json) {
        if (json.name !== &#x27;expRegression&#x27;) {
            throw new TypeError(&#x27;not a exp regression model&#x27;);
        }
        return new ExpRegression(true, json);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Regression.NLR.PolynomialRegression" id="apidoc.element.ml.Regression.NLR.PolynomialRegression">
        function <span class="apidocSignatureSpan">ml.Regression.NLR.</span>PolynomialRegression
        <span class="apidocSignatureSpan">(x, y, M, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class PolynomialRegression extends BaseRegression {
<span class="apidocCodeCommentSpan">    /**
     * @constructor
     * @param x: Independent variable
     * @param y: Dependent variable
     * @param M: Maximum degree of the polynomial
     * @param options
     */
</span>    constructor(x, y, M, options) {
        super();
        let opt = options || {};
        if (x === true) { // reloading model
            this.coefficients = y.coefficients;
            this.powers = y.powers;
            this.M = y.M;
            if (y.quality) {
                this.quality = y.quality;
            }
        } else {
            var n = x.length;
            if (n !== y.length) {
                throw new RangeError(&#x27;input and output array have a different length&#x27;);
            }

            let powers;
            if (Array.isArray(M)) {
                powers = M;
                M = powers.length;
            } else {
                M++;
                powers = new Array(M);
                for (k = 0; k &#x3c; M; k++) {
                    powers[k] = k;
                }
            }
            var F = new Matrix(n, M);
            var Y = new Matrix([y]);
            var k, i;
            for (k = 0; k &#x3c; M; k++) {
                for (i = 0; i &#x3c; n; i++) {
                    if (powers[k] === 0) {
                        F[i][k] = 1;
                    } else {
                        F[i][k] = Math.pow(x[i], powers[k]);
                    }
                }
            }

            var FT = F.transposeView();
            var A = FT.mmul(F);
            var B = FT.mmul(Y.transposeView());

            this.coefficients = A.solve(B).to1DArray();
            this.powers = powers;
            this.M = M - 1;
            if (opt.computeQuality) {
                this.quality = this.modelQuality(x, y);
            }
        }
    }

    _predict(x) {
        var y = 0;
        for (var  k = 0; k &#x3c; this.powers.length; k++) {
            y += this.coefficients[k] * Math.pow(x, this.powers[k]);
        }
        return y;
    }

    toJSON() {
        var out = {name: &#x27;polynomialRegression&#x27;,
            coefficients: this.coefficients,
            powers: this.powers,
            M: this.M
        };

        if (this.quality) {
            out.quality = this.quality;
        }
        return out;
    }

    toString(precision) {
        return this._toFormula(precision, false);
    }

    toLaTeX(precision) {
        return this._toFormula(precision, true);
    }

    _toFormula(precision, isLaTeX) {
        var sup = &#x27;^&#x27;;
        var closeSup = &#x27;&#x27;;
        var times = &#x27; * &#x27;;
        if (isLaTeX) {
            sup = &#x27;^{&#x27;;
            closeSup = &#x27;}&#x27;;
            times = &#x27;&#x27;;
        }

        var fn =  &#x27;&#x27;, str;
        for (var k = 0; k &#x3c; this.coefficients.length; k++) {
            str = &#x27;&#x27;;
            if (this.coefficients[k] !== 0) {
                if (this.powers[k] === 0) {
                    str = maybeToPrecision(this.coefficients[k], precision);
                } else {
                    if (this.powers[k] === 1) {
                        str = maybeToPrecision(this.coefficients[k], precision) + times + &#x27;x&#x27;;
                    } else {
                        str = maybeToPrecision(this.coefficients[k], precision) + times + &#x27;x&#x27; + sup + this.powers[k] + closeSup;
                    }
                }

                if (this.coefficients[k] &#x3e; 0 &#x26;&#x26; k !== (this.coefficients.length - 1)) {
                    str = &#x27; + &#x27; + str;
                } else if (k !== (this.coefficients.length - 1)) {
                    str = &#x27; &#x27; + str;
                }
            }
            fn = str + fn;
        }
        if (fn.charAt(0) === &#x27; + &#x27;) {
            fn = fn.slice(1);
        }

        return &#x27;f(x) = &#x27; + fn;
    }

    static load(json) {
        if (json.name !== &#x27;polynomialRegression&#x27;) {
            throw new TypeError(&#x27;not a polynomial regression model&#x27;);
        }
        return new PolynomialRegression(true, json);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Regression.NLR.PotentialRegression" id="apidoc.element.ml.Regression.NLR.PotentialRegression">
        function <span class="apidocSignatureSpan">ml.Regression.NLR.</span>PotentialRegression
        <span class="apidocSignatureSpan">(x, y, M, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class PotentialRegression extends BaseRegression {
<span class="apidocCodeCommentSpan">    /**
     * @constructor
     * @param x: Independent variable
     * @param y: Dependent variable
     * @param M
     * @param options
     */
</span>    constructor(x, y, M, options) {
        super();
        let opt = options || {};
        if (x === true) { // reloading model
            this.A = y.A;
            this.M = y.M;
            if (y.quality) {
                this.quality = y.quality;
            }
        } else {
            var n = x.length;
            if (n !== y.length) {
                throw new RangeError(&#x27;input and output array have a different length&#x27;);
            }

            var linear = new PolynomialRegression(x, y, [M], {computeCoefficient: true});
            this.A = linear.coefficients[0];
            this.M = M;
            if (opt.computeQuality) {
                this.quality = this.modelQuality(x, y);
            }
        }
    }

    _predict(x) {
        return this.A * Math.pow(x, this.M);
    }

    toJSON() {
        var out = {name: &#x27;potentialRegression&#x27;, A: this.A, M: this.M};
        if (this.quality) {
            out.quality = this.quality;
        }
        return out;
    }

    toString(precision) {
        return &#x27;f(x) = &#x27; + maybeToPrecision(this.A, precision) + &#x27; * x^&#x27; + this.M;
    }

    toLaTeX(precision) {

        if (this.M &#x3e;= 0) {
            return &#x27;f(x) = &#x27; + maybeToPrecision(this.A, precision) + &#x27;x^{&#x27; + this.M + &#x27;}&#x27;;
        } else {
            return &#x27;f(x) = \\frac{&#x27; + maybeToPrecision(this.A, precision) + &#x27;}{x^{&#x27; + (-this.M) + &#x27;}}&#x27;;
        }
    }

    static load(json) {
        if (json.name !== &#x27;potentialRegression&#x27;) {
            throw new TypeError(&#x27;not a potential regression model&#x27;);
        }
        return new PotentialRegression(true, json);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Regression.NLR.PowerRegression" id="apidoc.element.ml.Regression.NLR.PowerRegression">
        function <span class="apidocSignatureSpan">ml.Regression.NLR.</span>PowerRegression
        <span class="apidocSignatureSpan">(x, y, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class PowerRegression extends BaseRegression {
<span class="apidocCodeCommentSpan">    /**
     * @constructor
     * @param x: Independent variable
     * @param y: Dependent variable
     * @param options
     */
</span>    constructor(x, y, options) {
        super();
        let opt = options || {};
        if (x === true) { // reloading model
            this.A = y.A;
            this.B = y.B;
            this.quality = y.quality || {};
            if (y.quality.r) {
                this.quality.r = y.quality.r;
                this.quality.r2 = y.quality.r2;
            }
            if (y.quality.chi2) {
                this.quality.chi2 = y.quality.chi2;
            }
        } else {
            var n = x.length;
            if (n !== y.length) {
                throw new RangeError(&#x27;input and output array have a different length&#x27;);
            }
            var xl = new Array(n), yl = new Array(n);
            for (var i = 0; i &#x3c; n; i++) {
                xl[i] = Math.log(x[i]);
                yl[i] = Math.log(y[i]);
            }

            var linear = new SimpleLinearRegression(xl, yl, {computeCoefficient: false});
            this.A = Math.exp(linear.intercept);
            this.B = linear.slope;
            if (opt.computeQuality) {
                this.quality = this.modelQuality(x, y);
            }
        }
    }

    _predict(newInputs) {
        return this.A * Math.pow(newInputs, this.B);
    }

    toJSON() {
        var out = {name: &#x27;powerRegression&#x27;, A: this.A, B: this.B};
        if (this.quality) {
            out.quality = this.quality;
        }
        return out;
    }

    toString(precision) {
        return &#x27;f(x) = &#x27; + maybeToPrecision(this.A, precision) + &#x27; * x^&#x27; + maybeToPrecision(this.B, precision);
    }

    toLaTeX(precision) {
        if (this.B &#x3e;= 0) {
            return &#x27;f(x) = &#x27; + maybeToPrecision(this.A, precision) + &#x27;x^{&#x27; + maybeToPrecision(this.B, precision) + &#x27;}&#x27;;
        } else {
            return &#x27;f(x) = \\frac{&#x27; + maybeToPrecision(this.A, precision) + &#x27;}{x^{&#x27; + maybeToPrecision(-this.B, precision) + &#x27;}}&#x27;;
        }
    }

    static load(json) {
        if (json.name !== &#x27;powerRegression&#x27;) {
            throw new TypeError(&#x27;not a power regression model&#x27;);
        }
        return new PowerRegression(true, json);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ml.SL" id="apidoc.module.ml.SL">module ml.SL</a></h1>


    <h2>
        <a href="#apidoc.element.ml.SL.KNN" id="apidoc.element.ml.SL.KNN">
        function <span class="apidocSignatureSpan">ml.SL.</span>KNN
        <span class="apidocSignatureSpan">(reload, model)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function KNN(reload, model) {
    if(reload) {
        this.kdtree = model.kdtree;
        this.k = model.k;
        this.classes = model.classes;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.SL.NaiveBayes" id="apidoc.element.ml.SL.NaiveBayes">
        function <span class="apidocSignatureSpan">ml.SL.</span>NaiveBayes
        <span class="apidocSignatureSpan">(reload, model)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function NaiveBayes(reload, model) {
    if(reload) {
        this.means = model.means;
        this.calculateProbabilities = model.calculateProbabilities;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.SL.PLS" id="apidoc.element.ml.SL.PLS">
        function <span class="apidocSignatureSpan">ml.SL.</span>PLS
        <span class="apidocSignatureSpan">(X, Y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class PLS {
    constructor(X, Y) {
        if (X === true) {
            const model = Y;
            this.meanX = model.meanX;
            this.stdDevX = model.stdDevX;
            this.meanY = model.meanY;
            this.stdDevY = model.stdDevY;
            this.PBQ = Matrix.checkMatrix(model.PBQ);
            this.R2X = model.R2X;
        } else {
            if (X.length !== Y.length)
                throw new RangeError(&#x27;The number of X rows must be equal to the number of Y rows&#x27;);

            const resultX = Utils.featureNormalize(X);
            this.X = resultX.result;
            this.meanX = resultX.means;
            this.stdDevX = resultX.std;

            const resultY = Utils.featureNormalize(Y);
            this.Y = resultY.result;
            this.meanY = resultY.means;
            this.stdDevY = resultY.std;
        }
    }

<span class="apidocCodeCommentSpan">    /**
     * Fits the model with the given data and predictions, in this function is calculated the
     * following outputs:
     *
     * T - Score matrix of X
     * P - Loading matrix of X
     * U - Score matrix of Y
     * Q - Loading matrix of Y
     * B - Matrix of regression coefficient
     * W - Weight matrix of X
     *
     * @param {Object} options - recieves the latentVectors and the tolerance of each step of the PLS
     */
</span>    train(options) {
        if(options === undefined) options = {};

        var latentVectors = options.latentVectors;
        if (latentVectors === undefined) {
            latentVectors = Math.min(this.X.length - 1, this.X[0].length);
        }

        var tolerance = options.tolerance;
        if (tolerance === undefined) {
            tolerance = 1e-5;
        }

        var X = this.X;
        var Y = this.Y;

        var rx = X.rows;
        var cx = X.columns;
        var ry = Y.rows;
        var cy = Y.columns;

        var ssqXcal = X.clone().mul(X).sum(); // for the r²
        var sumOfSquaresY = Y.clone().mul(Y).sum();

        var n = latentVectors; //Math.max(cx, cy); // components of the pls
        var T = Matrix.zeros(rx, n);
        var P = Matrix.zeros(cx, n);
        var U = Matrix.zeros(ry, n);
        var Q = Matrix.zeros(cy, n);
        var B = Matrix.zeros(n, n);
        var W = P.clone();
        var k = 0;

        while(Utils.norm(Y) &#x3e; tolerance &#x26;&#x26; k &#x3c; n) {
            var transposeX = X.transpose();
            var transposeY = Y.transpose();

            var tIndex = maxSumColIndex(X.clone().mulM(X));
            var uIndex = maxSumColIndex(Y.clone().mulM(Y));

            var t1 = X.getColumnVector(tIndex);
            var u = Y.getColumnVector(uIndex);
            var t = Matrix.zeros(rx, 1);

            while(Utils.norm(t1.clone().sub(t)) &#x3e; tolerance) {
                var w = transposeX.mmul(u);
                w.div(Utils.norm(w));
                t = t1;
                t1 = X.mmul(w);
                var q = transposeY.mmul(t1);
                q.div(Utils.norm(q));
                u = Y.mmul(q);
            }

            t = t1;
            var num = transposeX.mmul(t);
            var den = (t.transpose().mmul(t))[0][0];
            var p = num.div(den);
            var pnorm = Utils.norm(p);
            p.div(pnorm);
            t.mul(pnorm);
            w.mul(pnorm);

            num = u.transpose().mmul(t);
            den = (t.transpose().mmul(t))[0][0];
            var b = (num.div(den))[0][0];
            X.sub(t.mmul(p.transpose()));
            Y.sub(t.clone().mul(b).mmul(q.transpose()));

            T.setColumn(k, t);
            P.setColumn(k, p);
            U.setColumn(k, u);
            Q.setColumn(k, q);
            W.setColumn(k, w);

            B[k][k] = b;
            k++;
        }

        k--;
        T = T.subMatrix(0, T.rows - 1, 0, k);
        P = P.subMatrix(0, P.rows - 1, 0, k);
        U = U.subMatrix(0, U.rows - 1, 0, k);
        Q = Q.subMatrix(0, Q.rows - 1, 0, k);
        W = W.subMatrix(0, W.rows - 1, 0, k);
        B = B.subMatrix(0, k, 0, k);

        // TODO: review of R2Y
        //this.R2Y = t.transpose().mmul(t).mul(q[k][0]*q[k][0]).divS(ssqYcal)[0][0]; ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.SL.SVM" id="apidoc.element.ml.SL.SVM">
        function <span class="apidocSignatureSpan">ml.SL.</span>SVM
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SVM(options) {
    this.options = Object.assign({}, defaultOptions, options);

    this.kernel = new Kernel(this.options.kernel, this.options.kernelOptions);
    this.b = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ml.SL.CV" id="apidoc.module.ml.SL.CV">module ml.SL.CV</a></h1>


    <h2>
        <a href="#apidoc.element.ml.SL.CV.kFold" id="apidoc.element.ml.SL.CV.kFold">
        function <span class="apidocSignatureSpan">ml.SL.CV.</span>kFold
        <span class="apidocSignatureSpan">(Classifier, features, labels, classifierOptions, k)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">kFold = function (Classifier, features, labels, classifierOptions, k) {
    check(features, labels);
    const distinct = getDistinct(labels);
    const confusionMatrix = initMatrix(distinct.length, distinct.length);
    var N = features.length;
    var allIdx = new Array(N);
    for (var i = 0; i &#x3c; N; i++) {
        allIdx[i] = i;
    }

    var l = Math.floor(N / k);
    // create random k-folds
    var current = [];
    var folds = [];
    while (allIdx.length) {
        var randi = Math.floor(Math.random() * allIdx.length);
        current.push(allIdx[randi]);
        allIdx.splice(randi, 1);
        if (current.length === l) {
            folds.push(current);
            current = [];
        }
    }
    if (current.length) folds.push(current);
    folds = folds.slice(0, k);


    for (i = 0; i &#x3c; folds.length; i++) {
        var testIdx = folds[i];
        var trainIdx = [];
        for (var j = 0; j &#x3c; folds.length; j++) {
            if (j !== i) trainIdx = trainIdx.concat(folds[j]);
        }

        validate(Classifier, features, labels, classifierOptions, testIdx, trainIdx, confusionMatrix, distinct);
    }

    return new ConfusionMatrix(confusionMatrix, distinct);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.SL.CV.leaveOneOut" id="apidoc.element.ml.SL.CV.leaveOneOut">
        function <span class="apidocSignatureSpan">ml.SL.CV.</span>leaveOneOut
        <span class="apidocSignatureSpan">(Classifier, features, labels, classifierOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">leaveOneOut = function (Classifier, features, labels, classifierOptions) {
    return CV.leavePOut(Classifier, features, labels, classifierOptions, 1);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.SL.CV.leavePOut" id="apidoc.element.ml.SL.CV.leavePOut">
        function <span class="apidocSignatureSpan">ml.SL.CV.</span>leavePOut
        <span class="apidocSignatureSpan">(Classifier, features, labels, classifierOptions, p)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">leavePOut = function (Classifier, features, labels, classifierOptions, p) {
    check(features, labels);
    const distinct = getDistinct(labels);
    const confusionMatrix = initMatrix(distinct.length, distinct.length);
    var i, N = features.length;
    var gen = combinations(p, N);
    var allIdx = new Array(N);
    for (i = 0; i &#x3c; N; i++) {
        allIdx[i] = i;
    }
    for (const testIdx of gen) {
        var trainIdx = allIdx.slice();

        for (i = testIdx.length - 1; i &#x3e;= 0; i--) {
            trainIdx.splice(testIdx[i], 1);
        }

        validate(Classifier, features, labels, classifierOptions, testIdx, trainIdx, confusionMatrix, distinct);
    }

    return new ConfusionMatrix(confusionMatrix, distinct);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ml.SL.KNN" id="apidoc.module.ml.SL.KNN">module ml.SL.KNN</a></h1>


    <h2>
        <a href="#apidoc.element.ml.SL.KNN.KNN" id="apidoc.element.ml.SL.KNN.KNN">
        function <span class="apidocSignatureSpan">ml.SL.</span>KNN
        <span class="apidocSignatureSpan">(reload, model)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function KNN(reload, model) {
    if(reload) {
        this.kdtree = model.kdtree;
        this.k = model.k;
        this.classes = model.classes;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.SL.KNN.load" id="apidoc.element.ml.SL.KNN.load">
        function <span class="apidocSignatureSpan">ml.SL.KNN.</span>load
        <span class="apidocSignatureSpan">(model)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">load = function (model) {
    if(model.modelName !== &#x22;KNN&#x22;)
        throw new RangeError(&#x22;The given model is invalid!&#x22;);

    return new KNN(true, model);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ml.SL.KNN.prototype" id="apidoc.module.ml.SL.KNN.prototype">module ml.SL.KNN.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.ml.SL.KNN.prototype.export" id="apidoc.element.ml.SL.KNN.prototype.export">
        function <span class="apidocSignatureSpan">ml.SL.KNN.prototype.</span>export
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">export = function () {
    return {
        modelName: &#x22;KNN&#x22;,
        kdtree: this.kdtree,
        k: this.k,
        classes: this.classes
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.SL.KNN.prototype.getSinglePrediction" id="apidoc.element.ml.SL.KNN.prototype.getSinglePrediction">
        function <span class="apidocSignatureSpan">ml.SL.KNN.prototype.</span>getSinglePrediction
        <span class="apidocSignatureSpan">(currentCase)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getSinglePrediction = function (currentCase) {
    var nearestPoints = this.kdtree.nearest(currentCase, this.k);
    var pointsPerClass = new Array(this.classes);
    var predictedClass = -1;
    var maxPoints = -1;
    var lastElement = nearestPoints[0][0].length - 1;

    for(var i = 0; i &#x3c; pointsPerClass.length; ++i) {
        pointsPerClass[i] = 0;
    }

    for(i = 0; i &#x3c; nearestPoints.length; ++i) {
        var currentClass = nearestPoints[i][0][lastElement];
        var currentPoints = ++pointsPerClass[currentClass];
        if(currentPoints &#x3e; maxPoints) {
            predictedClass = currentClass;
            maxPoints = currentPoints;
        }
    }

    return predictedClass;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.SL.KNN.prototype.predict" id="apidoc.element.ml.SL.KNN.prototype.predict">
        function <span class="apidocSignatureSpan">ml.SL.KNN.prototype.</span>predict
        <span class="apidocSignatureSpan">(dataset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">predict = function (dataset) {
    var predictions = new Array(dataset.length);
    for(var i = 0; i &#x3c; dataset.length; ++i) {
        predictions[i] = this.getSinglePrediction(dataset[i]);
    }

    return predictions;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.SL.KNN.prototype.train" id="apidoc.element.ml.SL.KNN.prototype.train">
        function <span class="apidocSignatureSpan">ml.SL.KNN.prototype.</span>train
        <span class="apidocSignatureSpan">(trainingSet, trainingLabels, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">train = function (trainingSet, trainingLabels, options) {
    if(options === undefined) options = {};
    if(options.distance === undefined) options.distance = Distances.distance.euclidean;
    if(options.k === undefined) options.k = trainingSet[0].length + 1;

    var classes = 0;
    var exist = new Array(1000);
    var j = 0;
    for(var i = 0; i &#x3c; trainingLabels.length; ++i) {
        if(exist.indexOf(trainingLabels[i]) === -1) {
            classes++;
            exist[j] = trainingLabels[i];
            j++;
        }
    }

    // copy dataset
    var points = new Array(trainingSet.length);
    for(i = 0; i &#x3c; points.length; ++i) {
        points[i] = trainingSet[i].slice();
    }

    this.features = trainingSet[0].length;
    for(i = 0; i &#x3c; trainingLabels.length; ++i) {
        points[i].push(trainingLabels[i]);
    }

    var dimensions = new Array(trainingSet[0].length);
    for(i = 0; i &#x3c; dimensions.length; ++i) {
        dimensions[i] = i;
    }

    this.kdtree = new KDTree(points, options.distance, dimensions);
    this.k = options.k;
    this.classes = classes;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ml.SL.NaiveBayes" id="apidoc.module.ml.SL.NaiveBayes">module ml.SL.NaiveBayes</a></h1>


    <h2>
        <a href="#apidoc.element.ml.SL.NaiveBayes.NaiveBayes" id="apidoc.element.ml.SL.NaiveBayes.NaiveBayes">
        function <span class="apidocSignatureSpan">ml.SL.</span>NaiveBayes
        <span class="apidocSignatureSpan">(reload, model)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function NaiveBayes(reload, model) {
    if(reload) {
        this.means = model.means;
        this.calculateProbabilities = model.calculateProbabilities;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.SL.NaiveBayes.load" id="apidoc.element.ml.SL.NaiveBayes.load">
        function <span class="apidocSignatureSpan">ml.SL.NaiveBayes.</span>load
        <span class="apidocSignatureSpan">(model)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">load = function (model) {
    if(model.modelName !== &#x27;NaiveBayes&#x27;)
        throw new RangeError(&#x22;The given model is invalid!&#x22;);

    return new NaiveBayes(true, model);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.SL.NaiveBayes.separateClasses" id="apidoc.element.ml.SL.NaiveBayes.separateClasses">
        function <span class="apidocSignatureSpan">ml.SL.NaiveBayes.</span>separateClasses
        <span class="apidocSignatureSpan">(X, y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function separateClasses(X, y) {
    var features = X.columns;

    var classes = 0;
    var totalPerClasses = new Array(100); // max upperbound of classes
    for (var i = 0; i &#x3c; y.length; i++) {
        if(totalPerClasses[y[i]] === undefined) {
            totalPerClasses[y[i]] = 0;
            classes++;
        }
        totalPerClasses[y[i]]++;
    }
    var separatedClasses = new Array(classes);
    var currentIndex = new Array(classes);
    for(i = 0; i &#x3c; classes; ++i) {
        separatedClasses[i] = new Matrix(totalPerClasses[i], features);
        currentIndex[i] = 0;
    }
    for(i = 0; i &#x3c; X.rows; ++i) {
        separatedClasses[y[i]].setRow(currentIndex[y[i]], X.getRow(i));
        currentIndex[y[i]]++;
    }
    return separatedClasses;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ml.SL.NaiveBayes.prototype" id="apidoc.module.ml.SL.NaiveBayes.prototype">module ml.SL.NaiveBayes.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.ml.SL.NaiveBayes.prototype.export" id="apidoc.element.ml.SL.NaiveBayes.prototype.export">
        function <span class="apidocSignatureSpan">ml.SL.NaiveBayes.prototype.</span>export
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">export = function () {
    return {
        modelName: &#x22;NaiveBayes&#x22;,
        means: this.means,
        calculateProbabilities: this.calculateProbabilities
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.SL.NaiveBayes.prototype.predict" id="apidoc.element.ml.SL.NaiveBayes.prototype.predict">
        function <span class="apidocSignatureSpan">ml.SL.NaiveBayes.prototype.</span>predict
        <span class="apidocSignatureSpan">(dataset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">predict = function (dataset) {
    if(dataset[0].length === this.calculateProbabilities[0].length)
        throw new RangeError(&#x27;the dataset must have the same features as the training set&#x27;);

    var predictions = new Array(dataset.length);

    for(var i = 0; i &#x3c; predictions.length; ++i) {
        predictions[i] = getCurrentClass(dataset[i], this.means, this.calculateProbabilities);
    }

    return predictions;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.SL.NaiveBayes.prototype.train" id="apidoc.element.ml.SL.NaiveBayes.prototype.train">
        function <span class="apidocSignatureSpan">ml.SL.NaiveBayes.prototype.</span>train
        <span class="apidocSignatureSpan">(trainingSet, trainingLabels)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">train = function (trainingSet, trainingLabels) {
    var C1 = Math.sqrt(2*Math.PI); // constant to precalculate the squared root
    if(!Matrix.isMatrix(trainingSet)) trainingSet = new Matrix(trainingSet);
    else trainingSet = trainingSet.clone();

    if(trainingSet.rows !== trainingLabels.length)
        throw new RangeError(&#x22;the size of the training set and the training labels must be the same.&#x22;);

    var separatedClasses = separateClasses(trainingSet, trainingLabels);
    var calculateProbabilities = new Array(separatedClasses.length);
    this.means = new Array(separatedClasses.length);
    for(var i = 0; i &#x3c; separatedClasses.length; ++i) {
        var means = Stat.matrix.mean(separatedClasses[i]);
        var std = Stat.matrix.standardDeviation(separatedClasses[i], means);

        var logPriorProbability = Math.log(separatedClasses[i].rows / trainingSet.rows);
        calculateProbabilities[i] = new Array(means.length + 1);

        calculateProbabilities[i][0] = logPriorProbability;
        for(var j = 1; j &#x3c; means.length + 1; ++j) {
            var currentStd = std[j - 1];
            calculateProbabilities[i][j] = [(1 / (C1 * currentStd)), -2*currentStd*currentStd];
        }

        this.means[i] = means;
    }

    this.calculateProbabilities = calculateProbabilities;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ml.SL.PLS" id="apidoc.module.ml.SL.PLS">module ml.SL.PLS</a></h1>


    <h2>
        <a href="#apidoc.element.ml.SL.PLS.PLS" id="apidoc.element.ml.SL.PLS.PLS">
        function <span class="apidocSignatureSpan">ml.SL.</span>PLS
        <span class="apidocSignatureSpan">(X, Y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class PLS {
    constructor(X, Y) {
        if (X === true) {
            const model = Y;
            this.meanX = model.meanX;
            this.stdDevX = model.stdDevX;
            this.meanY = model.meanY;
            this.stdDevY = model.stdDevY;
            this.PBQ = Matrix.checkMatrix(model.PBQ);
            this.R2X = model.R2X;
        } else {
            if (X.length !== Y.length)
                throw new RangeError(&#x27;The number of X rows must be equal to the number of Y rows&#x27;);

            const resultX = Utils.featureNormalize(X);
            this.X = resultX.result;
            this.meanX = resultX.means;
            this.stdDevX = resultX.std;

            const resultY = Utils.featureNormalize(Y);
            this.Y = resultY.result;
            this.meanY = resultY.means;
            this.stdDevY = resultY.std;
        }
    }

<span class="apidocCodeCommentSpan">    /**
     * Fits the model with the given data and predictions, in this function is calculated the
     * following outputs:
     *
     * T - Score matrix of X
     * P - Loading matrix of X
     * U - Score matrix of Y
     * Q - Loading matrix of Y
     * B - Matrix of regression coefficient
     * W - Weight matrix of X
     *
     * @param {Object} options - recieves the latentVectors and the tolerance of each step of the PLS
     */
</span>    train(options) {
        if(options === undefined) options = {};

        var latentVectors = options.latentVectors;
        if (latentVectors === undefined) {
            latentVectors = Math.min(this.X.length - 1, this.X[0].length);
        }

        var tolerance = options.tolerance;
        if (tolerance === undefined) {
            tolerance = 1e-5;
        }

        var X = this.X;
        var Y = this.Y;

        var rx = X.rows;
        var cx = X.columns;
        var ry = Y.rows;
        var cy = Y.columns;

        var ssqXcal = X.clone().mul(X).sum(); // for the r²
        var sumOfSquaresY = Y.clone().mul(Y).sum();

        var n = latentVectors; //Math.max(cx, cy); // components of the pls
        var T = Matrix.zeros(rx, n);
        var P = Matrix.zeros(cx, n);
        var U = Matrix.zeros(ry, n);
        var Q = Matrix.zeros(cy, n);
        var B = Matrix.zeros(n, n);
        var W = P.clone();
        var k = 0;

        while(Utils.norm(Y) &#x3e; tolerance &#x26;&#x26; k &#x3c; n) {
            var transposeX = X.transpose();
            var transposeY = Y.transpose();

            var tIndex = maxSumColIndex(X.clone().mulM(X));
            var uIndex = maxSumColIndex(Y.clone().mulM(Y));

            var t1 = X.getColumnVector(tIndex);
            var u = Y.getColumnVector(uIndex);
            var t = Matrix.zeros(rx, 1);

            while(Utils.norm(t1.clone().sub(t)) &#x3e; tolerance) {
                var w = transposeX.mmul(u);
                w.div(Utils.norm(w));
                t = t1;
                t1 = X.mmul(w);
                var q = transposeY.mmul(t1);
                q.div(Utils.norm(q));
                u = Y.mmul(q);
            }

            t = t1;
            var num = transposeX.mmul(t);
            var den = (t.transpose().mmul(t))[0][0];
            var p = num.div(den);
            var pnorm = Utils.norm(p);
            p.div(pnorm);
            t.mul(pnorm);
            w.mul(pnorm);

            num = u.transpose().mmul(t);
            den = (t.transpose().mmul(t))[0][0];
            var b = (num.div(den))[0][0];
            X.sub(t.mmul(p.transpose()));
            Y.sub(t.clone().mul(b).mmul(q.transpose()));

            T.setColumn(k, t);
            P.setColumn(k, p);
            U.setColumn(k, u);
            Q.setColumn(k, q);
            W.setColumn(k, w);

            B[k][k] = b;
            k++;
        }

        k--;
        T = T.subMatrix(0, T.rows - 1, 0, k);
        P = P.subMatrix(0, P.rows - 1, 0, k);
        U = U.subMatrix(0, U.rows - 1, 0, k);
        Q = Q.subMatrix(0, Q.rows - 1, 0, k);
        W = W.subMatrix(0, W.rows - 1, 0, k);
        B = B.subMatrix(0, k, 0, k);

        // TODO: review of R2Y
        //this.R2Y = t.transpose().mmul(t).mul(q[k][0]*q[k][0]).divS(ssqYcal)[0][0]; ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.SL.PLS.OPLS" id="apidoc.element.ml.SL.PLS.OPLS">
        function <span class="apidocSignatureSpan">ml.SL.PLS.</span>OPLS
        <span class="apidocSignatureSpan">(dataset, predictions, numberOSC)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function OPLS(dataset, predictions, numberOSC) {
    var X = new Matrix(dataset);
    var y = new Matrix(predictions);

    X = Utils.featureNormalize(X).result;
    y = Utils.featureNormalize(y).result;

    var rows = X.rows;
    var columns = X.columns;

    var sumOfSquaresX = X.clone().mul(X).sum();
    var w = X.transpose().mmul(y);
    w.div(Utils.norm(w));

    var orthoW = new Array(numberOSC);
    var orthoT = new Array(numberOSC);
    var orthoP = new Array(numberOSC);
    for (var i = 0; i &#x3c; numberOSC; i++) {
        var t = X.mmul(w);

        var numerator = X.transpose().mmul(t);
        var denominator = t.transpose().mmul(t)[0][0];
        var p =  numerator.div(denominator);

        numerator = w.transpose().mmul(p)[0][0];
        denominator = w.transpose().mmul(w)[0][0];
        var wOsc = p.sub(w.clone().mul(numerator / denominator));
        wOsc.div(Utils.norm(wOsc));

        var tOsc = X.mmul(wOsc);

        numerator = X.transpose().mmul(tOsc);
        denominator = tOsc.transpose().mmul(tOsc)[0][0];
        var pOsc = numerator.div(denominator);

        X.sub(tOsc.mmul(pOsc.transpose()));
        orthoW[i] = wOsc.getColumn(0);
        orthoT[i] = tOsc.getColumn(0);
        orthoP[i] = pOsc.getColumn(0);
    }

    this.Xosc = X;

    var sumOfSquaresXosx = this.Xosc.clone().mul(this.Xosc).sum();
    this.R2X = 1 - sumOfSquaresXosx/sumOfSquaresX;

    this.W = orthoW;
    this.T = orthoT;
    this.P = orthoP;
    this.numberOSC = numberOSC;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ml.SL.PLS.OPLS.prototype" id="apidoc.module.ml.SL.PLS.OPLS.prototype">module ml.SL.PLS.OPLS.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.ml.SL.PLS.OPLS.prototype.correctDataset" id="apidoc.element.ml.SL.PLS.OPLS.prototype.correctDataset">
        function <span class="apidocSignatureSpan">ml.SL.PLS.OPLS.prototype.</span>correctDataset
        <span class="apidocSignatureSpan">(dataset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">correctDataset = function (dataset) {
    var X = new Matrix(dataset);

    var sumOfSquaresX = X.clone().mul(X).sum();
    for (var i = 0; i &#x3c; this.numberOSC; i++) {
        var currentW = this.W.getColumnVector(i);
        var currentP = this.P.getColumnVector(i);

        var t = X.mmul(currentW);
        X.sub(t.mmul(currentP));
    }
    var sumOfSquaresXosx = X.clone().mul(X).sum();

    var R2X = 1 - sumOfSquaresXosx / sumOfSquaresX;

    return {
        datasetOsc: X,
        R2Dataset: R2X
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ml.SL.SVM" id="apidoc.module.ml.SL.SVM">module ml.SL.SVM</a></h1>


    <h2>
        <a href="#apidoc.element.ml.SL.SVM.SVM" id="apidoc.element.ml.SL.SVM.SVM">
        function <span class="apidocSignatureSpan">ml.SL.</span>SVM
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SVM(options) {
    this.options = Object.assign({}, defaultOptions, options);

    this.kernel = new Kernel(this.options.kernel, this.options.kernelOptions);
    this.b = 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.SL.SVM.load" id="apidoc.element.ml.SL.SVM.load">
        function <span class="apidocSignatureSpan">ml.SL.SVM.</span>load
        <span class="apidocSignatureSpan">(model)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">load = function (model) {
    this._loaded = true;
    this._trained = false;
    var svm = new SVM(model.options);
    if (model.options.kernel === &#x27;linear&#x27;) {
        svm.W = model.W.slice();
        svm.D = svm.W.length;
    } else {
        svm.X = model.X.slice();
        svm.Y = model.Y.slice();
        svm.alphas = model.alphas.slice();
        svm.N = svm.X.length;
        svm.D = svm.X[0].length;
    }
    svm.minMax = model.minMax;
    svm.b = model.b;
    svm._loaded = true;
    svm._trained = false;
    return svm;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ml.SL.SVM.prototype" id="apidoc.module.ml.SL.SVM.prototype">module ml.SL.SVM.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.ml.SL.SVM.prototype._applyWhitening" id="apidoc.element.ml.SL.SVM.prototype._applyWhitening">
        function <span class="apidocSignatureSpan">ml.SL.SVM.prototype.</span>_applyWhitening
        <span class="apidocSignatureSpan">(features)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_applyWhitening = function (features) {
    if (!this.minMax) throw new Error(&#x27;Could not apply whitening&#x27;);
    var whitened = new Array(features.length);
    for (var j = 0; j &#x3c; features.length; j++) {
        whitened[j] = (features[j] - this.minMax[j].min) / (this.minMax[j].max - this.minMax[j].min);
    }
    return whitened;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.SL.SVM.prototype._marginOnePrecomputed" id="apidoc.element.ml.SL.SVM.prototype._marginOnePrecomputed">
        function <span class="apidocSignatureSpan">ml.SL.SVM.prototype.</span>_marginOnePrecomputed
        <span class="apidocSignatureSpan">(index, kernel)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_marginOnePrecomputed = function (index, kernel) {
    var ans = this.b, i;
    for (i = 0; i &#x3c; this.N; i++) {
        ans += this.alphas[i] * this.Y[i] * kernel[index][i];
    }
    return ans;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.SL.SVM.prototype.margin" id="apidoc.element.ml.SL.SVM.prototype.margin">
        function <span class="apidocSignatureSpan">ml.SL.SVM.prototype.</span>margin
        <span class="apidocSignatureSpan">(features)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">margin = function (features) {
    if (Array.isArray(features)) {
        return features.map(this.marginOne.bind(this));
    } else {
        return this.marginOne(features);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.SL.SVM.prototype.marginOne" id="apidoc.element.ml.SL.SVM.prototype.marginOne">
        function <span class="apidocSignatureSpan">ml.SL.SVM.prototype.</span>marginOne
        <span class="apidocSignatureSpan">(features, noWhitening)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">marginOne = function (features, noWhitening) {
    // Apply normalization
    if (this.options.whitening &#x26;&#x26; !noWhitening) {
        features = this._applyWhitening(features);
    }
    var ans = this.b, i;
    if (this.options.kernel === &#x27;linear&#x27; &#x26;&#x26; this.W) {
        // Use weights, it&#x27;s faster
        for (i = 0; i &#x3c; this.W.length; i++) {
            ans += this.W[i] * features[i];
        }
    } else {
        for (i = 0; i &#x3c; this.N; i++) {
            ans += this.alphas[i] * this.Y[i] * this.kernel.compute([features], [this.X[i]])[0][0];
        }
    }
    return ans;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.SL.SVM.prototype.predict" id="apidoc.element.ml.SL.SVM.prototype.predict">
        function <span class="apidocSignatureSpan">ml.SL.SVM.prototype.</span>predict
        <span class="apidocSignatureSpan">(features)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">predict = function (features) {
    if (!this._trained &#x26;&#x26; !this._loaded) throw new Error(&#x27;Cannot predict, you need to train the SVM first&#x27;);
    if (Array.isArray(features) &#x26;&#x26; Array.isArray(features[0])) {
        return features.map(this.predictOne.bind(this));
    } else {
        return this.predictOne(features);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.SL.SVM.prototype.predictOne" id="apidoc.element.ml.SL.SVM.prototype.predictOne">
        function <span class="apidocSignatureSpan">ml.SL.SVM.prototype.</span>predictOne
        <span class="apidocSignatureSpan">(p)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">predictOne = function (p) {
    var margin = this.marginOne(p);
    return margin &#x3e; 0 ? 1 : -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.SL.SVM.prototype.supportVectors" id="apidoc.element.ml.SL.SVM.prototype.supportVectors">
        function <span class="apidocSignatureSpan">ml.SL.SVM.prototype.</span>supportVectors
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">supportVectors = function () {
    if (!this._trained &#x26;&#x26; !this._loaded) throw new Error(&#x27;Cannot get support vectors, you need to train the SVM first&#x27;);
    if (this._loaded &#x26;&#x26; this.options.kernel === &#x27;linear&#x27;) throw new Error(&#x27;Cannot get support vectors from saved linear model, you
 need to train the SVM to have them&#x27;);
    return this._supportVectorIdx;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.SL.SVM.prototype.toJSON" id="apidoc.element.ml.SL.SVM.prototype.toJSON">
        function <span class="apidocSignatureSpan">ml.SL.SVM.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () {
    if (!this._trained &#x26;&#x26; !this._loaded) throw new Error(&#x27;Cannot export, you need to train the SVM first&#x27;);
    var model = {};
    model.options = Object.assign({}, this.options);
    model.b = this.b;
    model.minMax = this.minMax;
    if (model.options.kernel === &#x27;linear&#x27;) {
        model.W = this.W.slice();
    } else {
        // Exporting non-linear models is heavier
        model.X = this.X.slice();
        model.Y = this.Y.slice();
        model.alphas = this.alphas.slice();
    }
    return model;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.SL.SVM.prototype.train" id="apidoc.element.ml.SL.SVM.prototype.train">
        function <span class="apidocSignatureSpan">ml.SL.SVM.prototype.</span>train
        <span class="apidocSignatureSpan">(features, labels)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">train = function (features, labels) {
    if (features.length !== labels.length) {
        throw new Error(&#x27;Features and labels should have the same length&#x27;);
    }
    if (features.length &#x3c; 2) {
        throw new Error(&#x27;Cannot train with less than 2 observations&#x27;);
    }
    this._trained = false;
    this._loaded = false;
    this.N = labels.length;
    this.D = features[0].length;
    if (this.options.whitening) {
        this.X = new Array(this.N);
        for (var i = 0; i &#x3c; this.N; i++) {
            this.X[i] = new Array(this.D);
        }
        this.minMax = new Array(this.D);
        // Apply normalization and keep normalization parameters
        for (var j = 0; j &#x3c; this.D; j++) {
            var d = new Array(this.N);
            for (i = 0; i &#x3c; this.N; i++) {
                d[i] = features[i][j];
            }
            this.minMax[j] = stat.minMax(d);
            for (i = 0; i &#x3c; this.N; i++) {
                this.X[i][j] = (features[i][j] - this.minMax[j].min) / (this.minMax[j].max - this.minMax[j].min);
            }
        }
    } else {
        this.X = features;
    }
    this.Y = labels;
    this.b = 0;
    this.W = undefined;

    var kernel = this.kernel.compute(this.X);
    var m = labels.length;
    var alpha = new Array(m).fill(0);
    this.alphas = alpha;
    for (var a = 0; a &#x3c; m; a++)
        alpha[a] = 0;

    var b1 = 0,
        b2 = 0,
        iter = 0,
        passes = 0,
        Ei = 0,
        Ej = 0,
        ai = 0,
        aj = 0,
        L = 0,
        H = 0,
        eta = 0;

    while (passes &#x3c; this.options.maxPasses &#x26;&#x26; iter &#x3c; this.options.maxIterations) {
        var numChange = 0;
        for (i = 0; i &#x3c; m; i++) {
            Ei = this._marginOnePrecomputed(i, kernel) - labels[i];
            if (labels[i] * Ei &#x3c; -this.options.tol &#x26;&#x26; alpha[i] &#x3c; this.options.C || labels[i] * Ei &#x3e; this.options.tol &#x26;&#x26; alpha[i] &#x3e;
0) {
                j = i;
                while (j === i) j = Math.floor(this.options.random() * m);
                Ej = this._marginOnePrecomputed(j, kernel) - labels[j];
                ai = alpha[i];
                aj = alpha[j];
                if (labels[i] === labels[j]) {
                    L = Math.max(0, ai + aj - this.options.C);
                    H = Math.min(this.options.C, ai + aj);
                } else  {
                    L = Math.max(0, aj - ai);
                    H = Math.min(this.options.C, this.options.C + aj + ai);
                }
                if (Math.abs(L - H) &#x3c; 1e-4) continue;

                eta = 2 * kernel[i][j] - kernel[i][i] - kernel[j][j];
                if (eta &#x3e;= 0) continue;
                var newaj = alpha[j] - labels[j] * (Ei - Ej) / eta;
                if (newaj &#x3e; H)
                    newaj = H;
                else if (newaj &#x3c; L)
                    newaj = L;
                if (Math.abs(aj - newaj) &#x3c; 10e-4) continue;
                alpha[j] = newaj;
                alpha[i] = alpha[i] + labels[i] * labels[j] * (aj - newaj);
                b1 = this.b - Ei - labels[i] * (alpha[i] - ai) * kernel[i][i] - labels[j] * (alpha[j] - aj) * kernel[i][j];
                b2 = this.b - Ej - labels[i] * (alpha[i] - ai) * kernel[i][j] - labels[j] * (alpha[j] - aj) * kernel[j][j];
                this.b = (b1 + b2) / 2;
                if (alpha[i] &#x3c; this.options.C &#x26;&#x26; alpha[i] &#x3e; 0) this.b = b1;
                if (alpha[j] &#x3c; this.options.C &#x26;&#x26; alpha[j] &#x3e; 0) this.b = b2;
                numChange += 1;
            }
        }
        iter++;
        if (numChange === 0)
            passes += 1;
        else
            passes = 0;
    }
    if (iter === this.options.maxIterations) {
        throw new Error(&#x27;max iterations reached&#x27;);
    }

    this.iterations = iter;

    // Compute the weights (useful for fast decision on new test instances when linear SVM)
    if (this.options.kernel === &#x27;linear&#x27;) {
        this.W = new Array(this.D);
        for (var r = 0; r &#x3c; this.D; r++) {
            this.W[r] = 0;
            for (var w = 0; w &#x3c; m; w++)
                this.W[r] += labels[w] * alpha[w] * this.X[w][r];
        }
    } ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ml.Stat" id="apidoc.module.ml.Stat">module ml.Stat</a></h1>


    <h2>
        <a href="#apidoc.element.ml.Stat.PCA" id="apidoc.element.ml.Stat.PCA">
        function <span class="apidocSignatureSpan">ml.Stat.</span>PCA
        <span class="apidocSignatureSpan">(dataset, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class PCA {
    constructor(dataset, options) {
        if (dataset === true) {
            const model = options;
            this.center = model.center;
            this.scale = model.scale;
            this.means = model.means;
            this.stdevs = model.stdevs;
            this.U = Matrix.checkMatrix(model.U);
            this.S = model.S;
            return;
        }

        options = Object.assign({}, defaultOptions, options);

        this.center = false;
        this.scale = false;
        this.means = null;
        this.stdevs = null;

        if (options.isCovarianceMatrix) { // user provided a covariance matrix instead of dataset
            this._computeFromCovarianceMatrix(dataset);
            return;
        }

        var useCovarianceMatrix;
        if (typeof options.useCovarianceMatrix === &#x27;boolean&#x27;) {
            useCovarianceMatrix = options.useCovarianceMatrix;
        } else {
            useCovarianceMatrix = dataset.length &#x3e; dataset[0].length;
        }

        if (useCovarianceMatrix) { // user provided a dataset but wants us to compute and use the covariance matrix
            dataset = this._adjust(dataset, options);
            const covarianceMatrix = dataset.transposeView().mmul(dataset).div(dataset.rows - 1);
            this._computeFromCovarianceMatrix(covarianceMatrix);
        } else {
            dataset = this._adjust(dataset, options);
            var svd = new SVD(dataset, {
                computeLeftSingularVectors: false,
                computeRightSingularVectors: true,
                autoTranspose: true
            });

            this.U = svd.rightSingularVectors;

            const singularValues = svd.diagonal;
            const eigenvalues = new Array(singularValues.length);
            for (var i = 0; i &#x3c; singularValues.length; i++) {
                eigenvalues[i] = singularValues[i] * singularValues[i] / (dataset.length - 1);
            }
            this.S = eigenvalues;
        }
    }

<span class="apidocCodeCommentSpan">    /**
     * Load a PCA model from JSON
     * @param {Object} model
     * @return {PCA}
     */
</span>    static load(model) {
        if (model.name !== &#x27;PCA&#x27;)
            throw new RangeError(&#x27;Invalid model: &#x27; + model.name);
        return new PCA(true, model);
    }

    /**
     * Project the dataset into the PCA space
     * @param {Matrix} dataset
     * @return {Matrix} dataset projected in the PCA space
     */
    predict(dataset) {
        dataset = new Matrix(dataset);

        if (this.center) {
            dataset.subRowVector(this.means);
            if (this.scale) {
                dataset.divRowVector(this.stdevs);
            }
        }

        return dataset.mmul(this.U);
    }

    /**
     * Returns the proportion of variance for each component
     * @return {[number]}
     */
    getExplainedVariance() {
        var sum = 0;
        for (var i = 0; i &#x3c; this.S.length; i++) {
            sum += this.S[i];
        }
        return this.S.map(value =&#x3e; value / sum);
    }

    /**
     * Returns the cumulative proportion of variance
     * @return {[number]}
     */
    getCumulativeVariance() {
        var explained = this.getExplainedVariance();
        for (var i = 1; i &#x3c; explained.length; i++) {
            explained[i] += explained[i - 1];
        }
        return explained;
    }

    /**
     * Returns the Eigenvectors of the covariance matrix
     * @returns {Matrix}
     */
    getEigenvectors() {
        return this.U;
    }

    /**
     * Returns the Eigenvalues (on the diagonal)
     * @returns {[number]}
     */
    getEigenvalues() {
        return this.S;
    }

    /**
     * Returns the standard deviations of the principal components
     * @returns {[number]}
     */
    getStandardDeviations() {
        return this.S.map(x =&#x3e; Math.sqrt(x));
    }

    /**
     * Returns the loadings matrix
     * @return {Matrix}
     */
    getLoadings() {
        return this.U.transpose();
    }

    /**
     * Export the current model to a JSON object
     * @return {Object} model
     */
    toJSON() {
        return {
            name: &#x27;PCA&#x27;, ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Stat.Performance" id="apidoc.element.ml.Stat.Performance">
        function <span class="apidocSignatureSpan">ml.Stat.</span>Performance
        <span class="apidocSignatureSpan">(values: truthy for same class, falsy for different class)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Performance {
<span class="apidocCodeCommentSpan">    /**
     *
     * @param prediction - The prediction matrix
     * @param target - The target matrix (values: truthy for same class, falsy for different class)
     * @param options
     *
     * @option    all    True if the entire matrix must be used. False to ignore the diagonal and lower part (default is false,
for similarity/distance matrices)
     * @option    max    True if the max value corresponds to a perfect match (like in similarity matrices), false if it is the
min value (default is false, like in distance matrices. All values will be multiplied by -1)
     */
</span>    constructor(prediction, target, options) {
        options = options || {};
        if (prediction.length !== target.length || prediction[0].length !== target[0].length) {
            throw new Error(&#x27;dimensions of prediction and target do not match&#x27;);
        }
        const rows = prediction.length;
        const columns = prediction[0].length;
        const isDistance = !options.max;

        const predP = [];

        if (options.all) {
            for (var i = 0; i &#x3c; rows; i++) {
                for (var j = 0; j &#x3c; columns; j++) {
                    predP.push({
                        pred: prediction[i][j],
                        targ: target[i][j]
                    });
                }
            }
        } else {
            if (rows &#x3c; 3 || rows !== columns) {
                throw new Error(&#x27;When &#x22;all&#x22; option is false, the prediction matrix must be square and have at least 3 columns&#x27;);
            }
            for (var i = 0; i &#x3c; rows - 1; i++) {
                for (var j = i + 1; j &#x3c; columns; j++) {
                    predP.push({
                        pred: prediction[i][j],
                        targ: target[i][j]
                    });
                }
            }
        }

        if (isDistance) {
            predP.sort((a, b) =&#x3e; a.pred - b.pred);
        } else {
            predP.sort((a, b) =&#x3e; b.pred - a.pred);
        }

        const cutoffs = this.cutoffs = [isDistance ? Number.MIN_VALUE : Number.MAX_VALUE];
        const fp = this.fp = [0];
        const tp = this.tp = [0];

        var nPos = 0;
        var nNeg = 0;

        var currentPred = predP[0].pred;
        var nTp = 0;
        var nFp = 0;
        for (var i = 0; i &#x3c; predP.length; i++) {
            if (predP[i].pred !== currentPred) {
                cutoffs.push(currentPred);
                fp.push(nFp);
                tp.push(nTp);
                currentPred = predP[i].pred;
            }
            if (predP[i].targ) {
                nPos++;
                nTp++;
            } else {
                nNeg++;
                nFp++;
            }
        }
        cutoffs.push(currentPred);
        fp.push(nFp);
        tp.push(nTp);

        const l = cutoffs.length;
        const fn = this.fn = new Array(l);
        const tn = this.tn = new Array(l);
        const nPosPred = this.nPosPred = new Array(l);
        const nNegPred = this.nNegPred = new Array(l);

        for (var i = 0; i &#x3c; l; i++) {
            fn[i] = nPos - tp[i];
            tn[i] = nNeg - fp[i];

            nPosPred[i] = tp[i] + fp[i];
            nNegPred[i] = tn[i] + fn[i];
        }

        this.nPos = nPos;
        this.nNeg = nNeg;
        this.nSamples = nPos + nNeg;
    }

    /**
     * Computes a measure from the prediction object.
     *
     * Many measures are available and can be combined :
     * To create a ROC curve, you need fpr and tpr
     * To create a DET curve, you need fnr and fpr
     * To create a Lift chart, you need rpp and lift
     *
     * Possible measures are : threshold (Threshold), acc (Accuracy), err (Error rate),
     * fpr (False positive rate), tpr (True positive rate), fnr (False negative rate), tnr (True negative rate), ppv (Positive predictive
 value),
     * npv (Negative predictive value), pcfall (Prediction-conditioned fallout), pcmiss (Prediction-conditioned miss), lift (Lift
 value), rpp (Rate of positive predictions), rnp (Rate of negative predictions)
     *
     * @param measure - The s ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ml.Stat.array" id="apidoc.module.ml.Stat.array">module ml.Stat.array</a></h1>


    <h2>
        <a href="#apidoc.element.ml.Stat.array.arithmeticMean" id="apidoc.element.ml.Stat.array.arithmeticMean">
        function <span class="apidocSignatureSpan">ml.Stat.array.</span>arithmeticMean
        <span class="apidocSignatureSpan">(values)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function arithmeticMean(values) {
    var sum = 0;
    var l = values.length;
    for (var i = 0; i &#x3c; l; i++) {
        sum += values[i];
    }
    return sum / l;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Stat.array.center" id="apidoc.element.ml.Stat.array.center">
        function <span class="apidocSignatureSpan">ml.Stat.array.</span>center
        <span class="apidocSignatureSpan">(values, inPlace)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function center(values, inPlace) {
    if (typeof (inPlace) === &#x27;undefined&#x27;) inPlace = false;

    var result = values;
    if (!inPlace)
        result = [].concat(values);

    var theMean = exports.mean(result), l = result.length;
    for (var i = 0; i &#x3c; l; i++)
        result[i] -= theMean;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Stat.array.contraHarmonicMean" id="apidoc.element.ml.Stat.array.contraHarmonicMean">
        function <span class="apidocSignatureSpan">ml.Stat.array.</span>contraHarmonicMean
        <span class="apidocSignatureSpan">(values)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function contraHarmonicMean(values) {
    var r1 = 0;
    var r2 = 0;
    var l = values.length;
    for (var i = 0; i &#x3c; l; i++) {
        r1 += values[i] * values[i];
        r2 += values[i];
    }
    if (r2 &#x3c; 0) {
        throw new RangeError(&#x27;sum of values is negative&#x27;);
    }
    return r1 / r2;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Stat.array.covariance" id="apidoc.element.ml.Stat.array.covariance">
        function <span class="apidocSignatureSpan">ml.Stat.array.</span>covariance
        <span class="apidocSignatureSpan">(vector1, vector2, unbiased)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function covariance(vector1, vector2, unbiased) {
    if (typeof (unbiased) === &#x27;undefined&#x27;) unbiased = true;
    var mean1 = exports.mean(vector1);
    var mean2 = exports.mean(vector2);

    if (vector1.length !== vector2.length)
        throw &#x27;Vectors do not have the same dimensions&#x27;;

    var cov = 0, l = vector1.length;
    for (var i = 0; i &#x3c; l; i++) {
        var x = vector1[i] - mean1;
        var y = vector2[i] - mean2;
        cov += x * y;
    }

    if (unbiased)
        return cov / (l - 1);
    else
        return cov / l;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Stat.array.cumulativeSum" id="apidoc.element.ml.Stat.array.cumulativeSum">
        function <span class="apidocSignatureSpan">ml.Stat.array.</span>cumulativeSum
        <span class="apidocSignatureSpan">(array)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cumulativeSum(array) {
    var l = array.length;
    var result = new Array(l);
    result[0] = array[0];
    for (var i = 1; i &#x3c; l; i++)
        result[i] = result[i - 1] + array[i];
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Stat.array.entropy" id="apidoc.element.ml.Stat.array.entropy">
        function <span class="apidocSignatureSpan">ml.Stat.array.</span>entropy
        <span class="apidocSignatureSpan">(values, eps)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function entropy(values, eps) {
    if (typeof (eps) === &#x27;undefined&#x27;) eps = 0;
    var sum = 0, l = values.length;
    for (var i = 0; i &#x3c; l; i++)
        sum += values[i] * Math.log(values[i] + eps);
    return -sum;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Stat.array.geometricMean" id="apidoc.element.ml.Stat.array.geometricMean">
        function <span class="apidocSignatureSpan">ml.Stat.array.</span>geometricMean
        <span class="apidocSignatureSpan">(values)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function geometricMean(values) {
    var mul = 1;
    var l = values.length;
    for (var i = 0; i &#x3c; l; i++) {
        mul *= values[i];
    }
    return Math.pow(mul, 1 / l);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Stat.array.grandMean" id="apidoc.element.ml.Stat.array.grandMean">
        function <span class="apidocSignatureSpan">ml.Stat.array.</span>grandMean
        <span class="apidocSignatureSpan">(means, samples)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function grandMean(means, samples) {
    var sum = 0;
    var n = 0;
    var l = means.length;
    for (var i = 0; i &#x3c; l; i++) {
        sum += samples[i] * means[i];
        n += samples[i];
    }
    return sum / n;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Stat.array.harmonicMean" id="apidoc.element.ml.Stat.array.harmonicMean">
        function <span class="apidocSignatureSpan">ml.Stat.array.</span>harmonicMean
        <span class="apidocSignatureSpan">(values)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function harmonicMean(values) {
    var sum = 0;
    var l = values.length;
    for (var i = 0; i &#x3c; l; i++) {
        if (values[i] === 0) {
            throw new RangeError(&#x27;value at index &#x27; + i + &#x27;is zero&#x27;);
        }
        sum += 1 / values[i];
    }
    return l / sum;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Stat.array.kurtosis" id="apidoc.element.ml.Stat.array.kurtosis">
        function <span class="apidocSignatureSpan">ml.Stat.array.</span>kurtosis
        <span class="apidocSignatureSpan">(values, unbiased)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function kurtosis(values, unbiased) {
    if (typeof (unbiased) === &#x27;undefined&#x27;) unbiased = true;
    var theMean = exports.mean(values);
    var n = values.length, s2 = 0, s4 = 0;

    for (var i = 0; i &#x3c; n; i++) {
        var dev = values[i] - theMean;
        s2 += dev * dev;
        s4 += dev * dev * dev * dev;
    }
    var m2 = s2 / n;
    var m4 = s4 / n;

    if (unbiased) {
        var v = s2 / (n - 1);
        var a = (n * (n + 1)) / ((n - 1) * (n - 2) * (n - 3));
        var b = s4 / (v * v);
        var c = ((n - 1) * (n - 1)) / ((n - 2) * (n - 3));

        return a * b - 3 * c;
    } else {
        return m4 / (m2 * m2) - 3;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Stat.array.logMean" id="apidoc.element.ml.Stat.array.logMean">
        function <span class="apidocSignatureSpan">ml.Stat.array.</span>logMean
        <span class="apidocSignatureSpan">(values)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function logMean(values) {
    var lnsum = 0;
    var l = values.length;
    for (var i = 0; i &#x3c; l; i++) {
        lnsum += Math.log(values[i]);
    }
    return lnsum / l;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Stat.array.max" id="apidoc.element.ml.Stat.array.max">
        function <span class="apidocSignatureSpan">ml.Stat.array.</span>max
        <span class="apidocSignatureSpan">(values)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function max(values) {
    var max = values[0];
    var l = values.length;
    for (var i = 1; i &#x3c; l; i++) {
        if (values[i] &#x3e; max) max = values[i];
    }
    return max;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Stat.array.mean" id="apidoc.element.ml.Stat.array.mean">
        function <span class="apidocSignatureSpan">ml.Stat.array.</span>mean
        <span class="apidocSignatureSpan">(values)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function arithmeticMean(values) {
    var sum = 0;
    var l = values.length;
    for (var i = 0; i &#x3c; l; i++) {
        sum += values[i];
    }
    return sum / l;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Stat.array.median" id="apidoc.element.ml.Stat.array.median">
        function <span class="apidocSignatureSpan">ml.Stat.array.</span>median
        <span class="apidocSignatureSpan">(values, alreadySorted)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function median(values, alreadySorted) {
    if (alreadySorted === undefined) alreadySorted = false;
    if (!alreadySorted) {
        values = [].concat(values).sort(compareNumbers);
    }
    var l = values.length;
    var half = Math.floor(l / 2);
    if (l % 2 === 0) {
        return (values[half - 1] + values[half]) * 0.5;
    } else {
        return values[half];
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Stat.array.min" id="apidoc.element.ml.Stat.array.min">
        function <span class="apidocSignatureSpan">ml.Stat.array.</span>min
        <span class="apidocSignatureSpan">(values)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function min(values) {
    var min = values[0];
    var l = values.length;
    for (var i = 1; i &#x3c; l; i++) {
        if (values[i] &#x3c; min) min = values[i];
    }
    return min;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Stat.array.minMax" id="apidoc.element.ml.Stat.array.minMax">
        function <span class="apidocSignatureSpan">ml.Stat.array.</span>minMax
        <span class="apidocSignatureSpan">(values)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function minMax(values) {
    var min = values[0];
    var max = values[0];
    var l = values.length;
    for (var i = 1; i &#x3c; l; i++) {
        if (values[i] &#x3c; min) min = values[i];
        if (values[i] &#x3e; max) max = values[i];
    }
    return {
        min: min,
        max: max
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Stat.array.mode" id="apidoc.element.ml.Stat.array.mode">
        function <span class="apidocSignatureSpan">ml.Stat.array.</span>mode
        <span class="apidocSignatureSpan">(values)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mode(values) {
    var l = values.length,
        itemCount = new Array(l),
        i;
    for (i = 0; i &#x3c; l; i++) {
        itemCount[i] = 0;
    }
    var itemArray = new Array(l);
    var count = 0;

    for (i = 0; i &#x3c; l; i++) {
        var index = itemArray.indexOf(values[i]);
        if (index &#x3e;= 0)
            itemCount[index]++;
        else {
            itemArray[count] = values[i];
            itemCount[count] = 1;
            count++;
        }
    }

    var maxValue = 0, maxIndex = 0;
    for (i = 0; i &#x3c; count; i++) {
        if (itemCount[i] &#x3e; maxValue) {
            maxValue = itemCount[i];
            maxIndex = i;
        }
    }

    return itemArray[maxIndex];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Stat.array.pooledStandardDeviation" id="apidoc.element.ml.Stat.array.pooledStandardDeviation">
        function <span class="apidocSignatureSpan">ml.Stat.array.</span>pooledStandardDeviation
        <span class="apidocSignatureSpan">(samples, unbiased)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function pooledStandardDeviation(samples, unbiased) {
    return Math.sqrt(exports.pooledVariance(samples, unbiased));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Stat.array.pooledVariance" id="apidoc.element.ml.Stat.array.pooledVariance">
        function <span class="apidocSignatureSpan">ml.Stat.array.</span>pooledVariance
        <span class="apidocSignatureSpan">(samples, unbiased)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function pooledVariance(samples, unbiased) {
    if (typeof (unbiased) === &#x27;undefined&#x27;) unbiased = true;
    var sum = 0;
    var length = 0, l = samples.length;
    for (var i = 0; i &#x3c; l; i++) {
        var values = samples[i];
        var vari = exports.variance(values);

        sum += (values.length - 1) * vari;

        if (unbiased)
            length += values.length - 1;
        else
            length += values.length;
    }
    return sum / length;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Stat.array.quartiles" id="apidoc.element.ml.Stat.array.quartiles">
        function <span class="apidocSignatureSpan">ml.Stat.array.</span>quartiles
        <span class="apidocSignatureSpan">(values, alreadySorted)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function quartiles(values, alreadySorted) {
    if (typeof (alreadySorted) === &#x27;undefined&#x27;) alreadySorted = false;
    if (!alreadySorted) {
        values = [].concat(values).sort(compareNumbers);
    }

    var quart = values.length / 4;
    var q1 = values[Math.ceil(quart) - 1];
    var q2 = exports.median(values, true);
    var q3 = values[Math.ceil(quart * 3) - 1];

    return {q1: q1, q2: q2, q3: q3};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Stat.array.robustMeanAndStdev" id="apidoc.element.ml.Stat.array.robustMeanAndStdev">
        function <span class="apidocSignatureSpan">ml.Stat.array.</span>robustMeanAndStdev
        <span class="apidocSignatureSpan">(y)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function robustMeanAndStdev(y) {
    var mean = 0, stdev = 0;
    var length = y.length, i = 0;
    for (i = 0; i &#x3c; length; i++) {
        mean += y[i];
    }
    mean /= length;
    var averageDeviations = new Array(length);
    for (i = 0; i &#x3c; length; i++)
        averageDeviations[i] = Math.abs(y[i] - mean);
    averageDeviations.sort(compareNumbers);
    if (length % 2 === 1) {
        stdev = averageDeviations[(length - 1) / 2] / 0.6745;
    } else {
        stdev = 0.5 * (averageDeviations[length / 2] + averageDeviations[length / 2 - 1]) / 0.6745;
    }

    return {
        mean: mean,
        stdev: stdev
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Stat.array.skewness" id="apidoc.element.ml.Stat.array.skewness">
        function <span class="apidocSignatureSpan">ml.Stat.array.</span>skewness
        <span class="apidocSignatureSpan">(values, unbiased)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function skewness(values, unbiased) {
    if (typeof (unbiased) === &#x27;undefined&#x27;) unbiased = true;
    var theMean = exports.mean(values);

    var s2 = 0, s3 = 0, l = values.length;
    for (var i = 0; i &#x3c; l; i++) {
        var dev = values[i] - theMean;
        s2 += dev * dev;
        s3 += dev * dev * dev;
    }
    var m2 = s2 / l;
    var m3 = s3 / l;

    var g = m3 / (Math.pow(m2, 3 / 2.0));
    if (unbiased) {
        var a = Math.sqrt(l * (l - 1));
        var b = l - 2;
        return (a / b) * g;
    } else {
        return g;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Stat.array.standardDeviation" id="apidoc.element.ml.Stat.array.standardDeviation">
        function <span class="apidocSignatureSpan">ml.Stat.array.</span>standardDeviation
        <span class="apidocSignatureSpan">(values, unbiased)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function standardDeviation(values, unbiased) {
    return Math.sqrt(exports.variance(values, unbiased));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Stat.array.standardError" id="apidoc.element.ml.Stat.array.standardError">
        function <span class="apidocSignatureSpan">ml.Stat.array.</span>standardError
        <span class="apidocSignatureSpan">(values)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function standardError(values) {
    return exports.standardDeviation(values) / Math.sqrt(values.length);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Stat.array.standardize" id="apidoc.element.ml.Stat.array.standardize">
        function <span class="apidocSignatureSpan">ml.Stat.array.</span>standardize
        <span class="apidocSignatureSpan">(values, standardDev, inPlace)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function standardize(values, standardDev, inPlace) {
    if (typeof (standardDev) === &#x27;undefined&#x27;) standardDev = exports.standardDeviation(values);
    if (typeof (inPlace) === &#x27;undefined&#x27;) inPlace = false;
    var l = values.length;
    var result = inPlace ? values : new Array(l);
    for (var i = 0; i &#x3c; l; i++)
        result[i] = values[i] / standardDev;
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Stat.array.sum" id="apidoc.element.ml.Stat.array.sum">
        function <span class="apidocSignatureSpan">ml.Stat.array.</span>sum
        <span class="apidocSignatureSpan">(values)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sum(values) {
    var sum = 0;
    for (var i = 0; i &#x3c; values.length; i++) {
        sum += values[i];
    }
    return sum;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Stat.array.truncatedMean" id="apidoc.element.ml.Stat.array.truncatedMean">
        function <span class="apidocSignatureSpan">ml.Stat.array.</span>truncatedMean
        <span class="apidocSignatureSpan">(values, percent, alreadySorted)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function truncatedMean(values, percent, alreadySorted) {
    if (alreadySorted === undefined) alreadySorted = false;
    if (!alreadySorted) {
        values = [].concat(values).sort(compareNumbers);
    }
    var l = values.length;
    var k = Math.floor(l * percent);
    var sum = 0;
    for (var i = k; i &#x3c; (l - k); i++) {
        sum += values[i];
    }
    return sum / (l - 2 * k);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Stat.array.variance" id="apidoc.element.ml.Stat.array.variance">
        function <span class="apidocSignatureSpan">ml.Stat.array.</span>variance
        <span class="apidocSignatureSpan">(values, unbiased)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function variance(values, unbiased) {
    if (unbiased === undefined) unbiased = true;
    var theMean = exports.mean(values);
    var theVariance = 0;
    var l = values.length;

    for (var i = 0; i &#x3c; l; i++) {
        var x = values[i] - theMean;
        theVariance += x * x;
    }

    if (unbiased) {
        return theVariance / (l - 1);
    } else {
        return theVariance / l;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Stat.array.weightedMean" id="apidoc.element.ml.Stat.array.weightedMean">
        function <span class="apidocSignatureSpan">ml.Stat.array.</span>weightedMean
        <span class="apidocSignatureSpan">(values, weights)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function weightedMean(values, weights) {
    var sum = 0, l = values.length;
    for (var i = 0; i &#x3c; l; i++)
        sum += values[i] * weights[i];
    return sum;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Stat.array.weightedStandardDeviation" id="apidoc.element.ml.Stat.array.weightedStandardDeviation">
        function <span class="apidocSignatureSpan">ml.Stat.array.</span>weightedStandardDeviation
        <span class="apidocSignatureSpan">(values, weights)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function weightedStandardDeviation(values, weights) {
    return Math.sqrt(exports.weightedVariance(values, weights));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Stat.array.weightedVariance" id="apidoc.element.ml.Stat.array.weightedVariance">
        function <span class="apidocSignatureSpan">ml.Stat.array.</span>weightedVariance
        <span class="apidocSignatureSpan">(values, weights)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function weightedVariance(values, weights) {
    var theMean = exports.weightedMean(values, weights);
    var vari = 0, l = values.length;
    var a = 0, b = 0;

    for (var i = 0; i &#x3c; l; i++) {
        var z = values[i] - theMean;
        var w = weights[i];

        vari += w * (z * z);
        b += w;
        a += w * w;
    }

    return vari * (b / (b * b - a));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ml.Stat.matrix" id="apidoc.module.ml.Stat.matrix">module ml.Stat.matrix</a></h1>


    <h2>
        <a href="#apidoc.element.ml.Stat.matrix.center" id="apidoc.element.ml.Stat.matrix.center">
        function <span class="apidocSignatureSpan">ml.Stat.matrix.</span>center
        <span class="apidocSignatureSpan">(matrix, means, inPlace)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function center(matrix, means, inPlace) {
    means = means || exports.mean(matrix);
    var result = matrix,
        l = matrix.length,
        i, j, jj;

    if (!inPlace) {
        result = new Array(l);
        for (i = 0; i &#x3c; l; i++) {
            result[i] = new Array(matrix[i].length);
        }
    }

    for (i = 0; i &#x3c; l; i++) {
        var row = result[i];
        for (j = 0, jj = row.length; j &#x3c; jj; j++) {
            row[j] = matrix[i][j] - means[j];
        }
    }
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Stat.matrix.correlation" id="apidoc.element.ml.Stat.matrix.correlation">
        function <span class="apidocSignatureSpan">ml.Stat.matrix.</span>correlation
        <span class="apidocSignatureSpan">(matrix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function correlation(matrix) {
    var means = exports.mean(matrix),
        standardDeviations = exports.standardDeviation(matrix, true, means),
        scores = exports.zScores(matrix, means, standardDeviations),
        rows = matrix.length,
        cols = matrix[0].length,
        i, j;

    var cor = new Array(cols);
    for (i = 0; i &#x3c; cols; i++) {
        cor[i] = new Array(cols);
    }
    for (i = 0; i &#x3c; cols; i++) {
        for (j = i; j &#x3c; cols; j++) {
            var c = 0;
            for (var k = 0, l = scores.length; k &#x3c; l; k++) {
                c += scores[k][j] * scores[k][i];
            }
            c /= rows - 1;
            cor[i][j] = c;
            cor[j][i] = c;
        }
    }
    return cor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Stat.matrix.covariance" id="apidoc.element.ml.Stat.matrix.covariance">
        function <span class="apidocSignatureSpan">ml.Stat.matrix.</span>covariance
        <span class="apidocSignatureSpan">(matrix, dimension)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function covariance(matrix, dimension) {
    return exports.scatter(matrix, undefined, dimension);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Stat.matrix.entropy" id="apidoc.element.ml.Stat.matrix.entropy">
        function <span class="apidocSignatureSpan">ml.Stat.matrix.</span>entropy
        <span class="apidocSignatureSpan">(matrix, eps)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function entropy(matrix, eps) {
    if (typeof (eps) === &#x27;undefined&#x27;) {
        eps = 0;
    }
    var sum = 0,
        l1 = matrix.length,
        l2 = matrix[0].length;
    for (var i = 0; i &#x3c; l1; i++) {
        for (var j = 0; j &#x3c; l2; j++) {
            sum += matrix[i][j] * Math.log(matrix[i][j] + eps);
        }
    }
    return -sum;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Stat.matrix.kurtosis" id="apidoc.element.ml.Stat.matrix.kurtosis">
        function <span class="apidocSignatureSpan">ml.Stat.matrix.</span>kurtosis
        <span class="apidocSignatureSpan">(matrix, unbiased)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function kurtosis(matrix, unbiased) {
    if (typeof (unbiased) === &#x27;undefined&#x27;) unbiased = true;
    var means = exports.mean(matrix);
    var n = matrix.length, m = matrix[0].length;
    var kurt = new Array(m);

    for (var j = 0; j &#x3c; m; j++) {
        var s2 = 0, s4 = 0;
        for (var i = 0; i &#x3c; n; i++) {
            var dev = matrix[i][j] - means[j];
            s2 += dev * dev;
            s4 += dev * dev * dev * dev;
        }
        var m2 = s2 / n;
        var m4 = s4 / n;

        if (unbiased) {
            var v = s2 / (n - 1);
            var a = (n * (n + 1)) / ((n - 1) * (n - 2) * (n - 3));
            var b = s4 / (v * v);
            var c = ((n - 1) * (n - 1)) / ((n - 2) * (n - 3));
            kurt[j] = a * b - 3 * c;
        } else {
            kurt[j] = m4 / (m2 * m2) - 3;
        }
    }
    return kurt;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Stat.matrix.max" id="apidoc.element.ml.Stat.matrix.max">
        function <span class="apidocSignatureSpan">ml.Stat.matrix.</span>max
        <span class="apidocSignatureSpan">(matrix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function max(matrix) {
    var max = -Infinity;
    for (var i = 0; i &#x3c; matrix.length; i++) {
        for (var j = 0; j &#x3c; matrix[i].length; j++) {
            if (matrix[i][j] &#x3e; max) max = matrix[i][j];
        }
    }
    return max;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Stat.matrix.mean" id="apidoc.element.ml.Stat.matrix.mean">
        function <span class="apidocSignatureSpan">ml.Stat.matrix.</span>mean
        <span class="apidocSignatureSpan">(matrix, dimension)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mean(matrix, dimension) {
    if (typeof (dimension) === &#x27;undefined&#x27;) {
        dimension = 0;
    }
    var rows = matrix.length,
        cols = matrix[0].length,
        theMean, N, i, j;

    if (dimension === -1) {
        theMean = [0];
        N = rows * cols;
        for (i = 0; i &#x3c; rows; i++) {
            for (j = 0; j &#x3c; cols; j++) {
                theMean[0] += matrix[i][j];
            }
        }
        theMean[0] /= N;
    } else if (dimension === 0) {
        theMean = new Array(cols);
        N = rows;
        for (j = 0; j &#x3c; cols; j++) {
            theMean[j] = 0;
            for (i = 0; i &#x3c; rows; i++) {
                theMean[j] += matrix[i][j];
            }
            theMean[j] /= N;
        }
    } else if (dimension === 1) {
        theMean = new Array(rows);
        N = cols;
        for (j = 0; j &#x3c; rows; j++) {
            theMean[j] = 0;
            for (i = 0; i &#x3c; cols; i++) {
                theMean[j] += matrix[j][i];
            }
            theMean[j] /= N;
        }
    } else {
        throw new Error(&#x27;Invalid dimension&#x27;);
    }
    return theMean;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Stat.matrix.median" id="apidoc.element.ml.Stat.matrix.median">
        function <span class="apidocSignatureSpan">ml.Stat.matrix.</span>median
        <span class="apidocSignatureSpan">(matrix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function median(matrix) {
    var rows = matrix.length, cols = matrix[0].length;
    var medians = new Array(cols);

    for (var i = 0; i &#x3c; cols; i++) {
        var data = new Array(rows);
        for (var j = 0; j &#x3c; rows; j++) {
            data[j] = matrix[j][i];
        }
        data.sort(compareNumbers);
        var N = data.length;
        if (N % 2 === 0) {
            medians[i] = (data[N / 2] + data[(N / 2) - 1]) * 0.5;
        } else {
            medians[i] = data[Math.floor(N / 2)];
        }
    }
    return medians;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Stat.matrix.min" id="apidoc.element.ml.Stat.matrix.min">
        function <span class="apidocSignatureSpan">ml.Stat.matrix.</span>min
        <span class="apidocSignatureSpan">(matrix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function min(matrix) {
    var min = Infinity;
    for (var i = 0; i &#x3c; matrix.length; i++) {
        for (var j = 0; j &#x3c; matrix[i].length; j++) {
            if (matrix[i][j] &#x3c; min) min = matrix[i][j];
        }
    }
    return min;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Stat.matrix.minMax" id="apidoc.element.ml.Stat.matrix.minMax">
        function <span class="apidocSignatureSpan">ml.Stat.matrix.</span>minMax
        <span class="apidocSignatureSpan">(matrix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function minMax(matrix) {
    var min = Infinity;
    var max = -Infinity;
    for (var i = 0; i &#x3c; matrix.length; i++) {
        for (var j = 0; j &#x3c; matrix[i].length; j++) {
            if (matrix[i][j] &#x3c; min) min = matrix[i][j];
            if (matrix[i][j] &#x3e; max) max = matrix[i][j];
        }
    }
    return {
        min:min,
        max:max
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Stat.matrix.mode" id="apidoc.element.ml.Stat.matrix.mode">
        function <span class="apidocSignatureSpan">ml.Stat.matrix.</span>mode
        <span class="apidocSignatureSpan">(matrix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mode(matrix) {
    var rows = matrix.length,
        cols = matrix[0].length,
        modes = new Array(cols),
        i, j;
    for (i = 0; i &#x3c; cols; i++) {
        var itemCount = new Array(rows);
        for (var k = 0; k &#x3c; rows; k++) {
            itemCount[k] = 0;
        }
        var itemArray = new Array(rows);
        var count = 0;

        for (j = 0; j &#x3c; rows; j++) {
            var index = itemArray.indexOf(matrix[j][i]);
            if (index &#x3e;= 0) {
                itemCount[index]++;
            } else {
                itemArray[count] = matrix[j][i];
                itemCount[count] = 1;
                count++;
            }
        }

        var maxValue = 0, maxIndex = 0;
        for (j = 0; j &#x3c; count; j++) {
            if (itemCount[j] &#x3e; maxValue) {
                maxValue = itemCount[j];
                maxIndex = j;
            }
        }

        modes[i] = itemArray[maxIndex];
    }
    return modes;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Stat.matrix.product" id="apidoc.element.ml.Stat.matrix.product">
        function <span class="apidocSignatureSpan">ml.Stat.matrix.</span>product
        <span class="apidocSignatureSpan">(matrix, dimension)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function product(matrix, dimension) {
    if (typeof (dimension) === &#x27;undefined&#x27;) {
        dimension = 0;
    }
    var rows = matrix.length,
        cols = matrix[0].length,
        theProduct, i, j;

    if (dimension === -1) {
        theProduct = [1];
        for (i = 0; i &#x3c; rows; i++) {
            for (j = 0; j &#x3c; cols; j++) {
                theProduct[0] *= matrix[i][j];
            }
        }
    } else if (dimension === 0) {
        theProduct = new Array(cols);
        for (j = 0; j &#x3c; cols; j++) {
            theProduct[j] = 1;
            for (i = 0; i &#x3c; rows; i++) {
                theProduct[j] *= matrix[i][j];
            }
        }
    } else if (dimension === 1) {
        theProduct = new Array(rows);
        for (j = 0; j &#x3c; rows; j++) {
            theProduct[j] = 1;
            for (i = 0; i &#x3c; cols; i++) {
                theProduct[j] *= matrix[j][i];
            }
        }
    } else {
        throw new Error(&#x27;Invalid dimension&#x27;);
    }
    return theProduct;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Stat.matrix.scatter" id="apidoc.element.ml.Stat.matrix.scatter">
        function <span class="apidocSignatureSpan">ml.Stat.matrix.</span>scatter
        <span class="apidocSignatureSpan">(matrix, divisor, dimension)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function scatter(matrix, divisor, dimension) {
    if (typeof (dimension) === &#x27;undefined&#x27;) {
        dimension = 0;
    }
    if (typeof (divisor) === &#x27;undefined&#x27;) {
        if (dimension === 0) {
            divisor = matrix.length - 1;
        } else if (dimension === 1) {
            divisor = matrix[0].length - 1;
        }
    }
    var means = exports.mean(matrix, dimension);
    var rows = matrix.length;
    if (rows === 0) {
        return [[]];
    }
    var cols = matrix[0].length,
        cov, i, j, s, k;

    if (dimension === 0) {
        cov = new Array(cols);
        for (i = 0; i &#x3c; cols; i++) {
            cov[i] = new Array(cols);
        }
        for (i = 0; i &#x3c; cols; i++) {
            for (j = i; j &#x3c; cols; j++) {
                s = 0;
                for (k = 0; k &#x3c; rows; k++) {
                    s += (matrix[k][j] - means[j]) * (matrix[k][i] - means[i]);
                }
                s /= divisor;
                cov[i][j] = s;
                cov[j][i] = s;
            }
        }
    } else if (dimension === 1) {
        cov = new Array(rows);
        for (i = 0; i &#x3c; rows; i++) {
            cov[i] = new Array(rows);
        }
        for (i = 0; i &#x3c; rows; i++) {
            for (j = i; j &#x3c; rows; j++) {
                s = 0;
                for (k = 0; k &#x3c; cols; k++) {
                    s += (matrix[j][k] - means[j]) * (matrix[i][k] - means[i]);
                }
                s /= divisor;
                cov[i][j] = s;
                cov[j][i] = s;
            }
        }
    } else {
        throw new Error(&#x27;Invalid dimension&#x27;);
    }

    return cov;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Stat.matrix.skewness" id="apidoc.element.ml.Stat.matrix.skewness">
        function <span class="apidocSignatureSpan">ml.Stat.matrix.</span>skewness
        <span class="apidocSignatureSpan">(matrix, unbiased)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function skewness(matrix, unbiased) {
    if (typeof (unbiased) === &#x27;undefined&#x27;) unbiased = true;
    var means = exports.mean(matrix);
    var n = matrix.length, l = means.length;
    var skew = new Array(l);

    for (var j = 0; j &#x3c; l; j++) {
        var s2 = 0, s3 = 0;
        for (var i = 0; i &#x3c; n; i++) {
            var dev = matrix[i][j] - means[j];
            s2 += dev * dev;
            s3 += dev * dev * dev;
        }

        var m2 = s2 / n;
        var m3 = s3 / n;
        var g = m3 / Math.pow(m2, 3 / 2);

        if (unbiased) {
            var a = Math.sqrt(n * (n - 1));
            var b = n - 2;
            skew[j] = (a / b) * g;
        } else {
            skew[j] = g;
        }
    }
    return skew;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Stat.matrix.standardDeviation" id="apidoc.element.ml.Stat.matrix.standardDeviation">
        function <span class="apidocSignatureSpan">ml.Stat.matrix.</span>standardDeviation
        <span class="apidocSignatureSpan">(matrix, means, unbiased)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function standardDeviation(matrix, means, unbiased) {
    var vari = exports.variance(matrix, means, unbiased), l = vari.length;
    for (var i = 0; i &#x3c; l; i++) {
        vari[i] = Math.sqrt(vari[i]);
    }
    return vari;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Stat.matrix.standardError" id="apidoc.element.ml.Stat.matrix.standardError">
        function <span class="apidocSignatureSpan">ml.Stat.matrix.</span>standardError
        <span class="apidocSignatureSpan">(matrix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function standardError(matrix) {
    var samples = matrix.length;
    var standardDeviations = exports.standardDeviation(matrix);
    var l = standardDeviations.length;
    var standardErrors = new Array(l);
    var sqrtN = Math.sqrt(samples);

    for (var i = 0; i &#x3c; l; i++) {
        standardErrors[i] = standardDeviations[i] / sqrtN;
    }
    return standardErrors;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Stat.matrix.standardize" id="apidoc.element.ml.Stat.matrix.standardize">
        function <span class="apidocSignatureSpan">ml.Stat.matrix.</span>standardize
        <span class="apidocSignatureSpan">(matrix, standardDeviations, inPlace)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function standardize(matrix, standardDeviations, inPlace) {
    if (typeof (standardDeviations) === &#x27;undefined&#x27;) standardDeviations = exports.standardDeviation(matrix);
    var result = matrix,
        l = matrix.length,
        i, j, jj;

    if (!inPlace) {
        result = new Array(l);
        for (i = 0; i &#x3c; l; i++) {
            result[i] = new Array(matrix[i].length);
        }
    }

    for (i = 0; i &#x3c; l; i++) {
        var resultRow = result[i];
        var sourceRow = matrix[i];
        for (j = 0, jj = resultRow.length; j &#x3c; jj; j++) {
            if (standardDeviations[j] !== 0 &#x26;&#x26; !isNaN(standardDeviations[j])) {
                resultRow[j] = sourceRow[j] / standardDeviations[j];
            }
        }
    }
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Stat.matrix.sum" id="apidoc.element.ml.Stat.matrix.sum">
        function <span class="apidocSignatureSpan">ml.Stat.matrix.</span>sum
        <span class="apidocSignatureSpan">(matrix, dimension)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function sum(matrix, dimension) {
    if (typeof (dimension) === &#x27;undefined&#x27;) {
        dimension = 0;
    }
    var rows = matrix.length,
        cols = matrix[0].length,
        theSum, i, j;

    if (dimension === -1) {
        theSum = [0];
        for (i = 0; i &#x3c; rows; i++) {
            for (j = 0; j &#x3c; cols; j++) {
                theSum[0] += matrix[i][j];
            }
        }
    } else if (dimension === 0) {
        theSum = new Array(cols);
        for (j = 0; j &#x3c; cols; j++) {
            theSum[j] = 0;
            for (i = 0; i &#x3c; rows; i++) {
                theSum[j] += matrix[i][j];
            }
        }
    } else if (dimension === 1) {
        theSum = new Array(rows);
        for (j = 0; j &#x3c; rows; j++) {
            theSum[j] = 0;
            for (i = 0; i &#x3c; cols; i++) {
                theSum[j] += matrix[j][i];
            }
        }
    } else {
        throw new Error(&#x27;Invalid dimension&#x27;);
    }
    return theSum;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Stat.matrix.variance" id="apidoc.element.ml.Stat.matrix.variance">
        function <span class="apidocSignatureSpan">ml.Stat.matrix.</span>variance
        <span class="apidocSignatureSpan">(matrix, means, unbiased)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function variance(matrix, means, unbiased) {
    if (typeof (unbiased) === &#x27;undefined&#x27;) {
        unbiased = true;
    }
    means = means || exports.mean(matrix);
    var rows = matrix.length;
    if (rows === 0) return [];
    var cols = matrix[0].length;
    var vari = new Array(cols);

    for (var j = 0; j &#x3c; cols; j++) {
        var sum1 = 0, sum2 = 0, x = 0;
        for (var i = 0; i &#x3c; rows; i++) {
            x = matrix[i][j] - means[j];
            sum1 += x;
            sum2 += x * x;
        }
        if (unbiased) {
            vari[j] = (sum2 - ((sum1 * sum1) / rows)) / (rows - 1);
        } else {
            vari[j] = (sum2 - ((sum1 * sum1) / rows)) / rows;
        }
    }
    return vari;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Stat.matrix.weightedCovariance" id="apidoc.element.ml.Stat.matrix.weightedCovariance">
        function <span class="apidocSignatureSpan">ml.Stat.matrix.</span>weightedCovariance
        <span class="apidocSignatureSpan">(matrix, weights, means, dimension)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function weightedCovariance(matrix, weights, means, dimension) {
    dimension = dimension || 0;
    means = means || exports.weightedMean(matrix, weights, dimension);
    var s1 = 0, s2 = 0;
    for (var i = 0, ii = weights.length; i &#x3c; ii; i++) {
        s1 += weights[i];
        s2 += weights[i] * weights[i];
    }
    var factor = s1 / (s1 * s1 - s2);
    return exports.weightedScatter(matrix, weights, means, factor, dimension);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Stat.matrix.weightedMean" id="apidoc.element.ml.Stat.matrix.weightedMean">
        function <span class="apidocSignatureSpan">ml.Stat.matrix.</span>weightedMean
        <span class="apidocSignatureSpan">(matrix, weights, dimension)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function weightedMean(matrix, weights, dimension) {
    if (typeof (dimension) === &#x27;undefined&#x27;) {
        dimension = 0;
    }
    var rows = matrix.length;
    if (rows === 0) return [];
    var cols = matrix[0].length,
        means, i, ii, j, w, row;

    if (dimension === 0) {
        means = new Array(cols);
        for (i = 0; i &#x3c; cols; i++) {
            means[i] = 0;
        }
        for (i = 0; i &#x3c; rows; i++) {
            row = matrix[i];
            w = weights[i];
            for (j = 0; j &#x3c; cols; j++) {
                means[j] += row[j] * w;
            }
        }
    } else if (dimension === 1) {
        means = new Array(rows);
        for (i = 0; i &#x3c; rows; i++) {
            means[i] = 0;
        }
        for (j = 0; j &#x3c; rows; j++) {
            row = matrix[j];
            w = weights[j];
            for (i = 0; i &#x3c; cols; i++) {
                means[j] += row[i] * w;
            }
        }
    } else {
        throw new Error(&#x27;Invalid dimension&#x27;);
    }

    var weightSum = arrayStat.sum(weights);
    if (weightSum !== 0) {
        for (i = 0, ii = means.length; i &#x3c; ii; i++) {
            means[i] /= weightSum;
        }
    }
    return means;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Stat.matrix.weightedScatter" id="apidoc.element.ml.Stat.matrix.weightedScatter">
        function <span class="apidocSignatureSpan">ml.Stat.matrix.</span>weightedScatter
        <span class="apidocSignatureSpan">(matrix, weights, means, factor, dimension)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function weightedScatter(matrix, weights, means, factor, dimension) {
    dimension = dimension || 0;
    means = means || exports.weightedMean(matrix, weights, dimension);
    if (typeof (factor) === &#x27;undefined&#x27;) {
        factor = 1;
    }
    var rows = matrix.length;
    if (rows === 0) {
        return [[]];
    }
    var cols = matrix[0].length,
        cov, i, j, k, s;

    if (dimension === 0) {
        cov = new Array(cols);
        for (i = 0; i &#x3c; cols; i++) {
            cov[i] = new Array(cols);
        }
        for (i = 0; i &#x3c; cols; i++) {
            for (j = i; j &#x3c; cols; j++) {
                s = 0;
                for (k = 0; k &#x3c; rows; k++) {
                    s += weights[k] * (matrix[k][j] - means[j]) * (matrix[k][i] - means[i]);
                }
                cov[i][j] = s * factor;
                cov[j][i] = s * factor;
            }
        }
    } else if (dimension === 1) {
        cov = new Array(rows);
        for (i = 0; i &#x3c; rows; i++) {
            cov[i] = new Array(rows);
        }
        for (i = 0; i &#x3c; rows; i++) {
            for (j = i; j &#x3c; rows; j++) {
                s = 0;
                for (k = 0; k &#x3c; cols; k++) {
                    s += weights[k] * (matrix[j][k] - means[j]) * (matrix[i][k] - means[i]);
                }
                cov[i][j] = s * factor;
                cov[j][i] = s * factor;
            }
        }
    } else {
        throw new Error(&#x27;Invalid dimension&#x27;);
    }

    return cov;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Stat.matrix.weightedVariance" id="apidoc.element.ml.Stat.matrix.weightedVariance">
        function <span class="apidocSignatureSpan">ml.Stat.matrix.</span>weightedVariance
        <span class="apidocSignatureSpan">(matrix, weights)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function weightedVariance(matrix, weights) {
    var means = exports.mean(matrix);
    var rows = matrix.length;
    if (rows === 0) return [];
    var cols = matrix[0].length;
    var vari = new Array(cols);

    for (var j = 0; j &#x3c; cols; j++) {
        var sum = 0;
        var a = 0, b = 0;

        for (var i = 0; i &#x3c; rows; i++) {
            var z = matrix[i][j] - means[j];
            var w = weights[i];

            sum += w * (z * z);
            b += w;
            a += w * w;
        }

        vari[j] = sum * (b / (b * b - a));
    }

    return vari;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.Stat.matrix.zScores" id="apidoc.element.ml.Stat.matrix.zScores">
        function <span class="apidocSignatureSpan">ml.Stat.matrix.</span>zScores
        <span class="apidocSignatureSpan">(matrix, means, standardDeviations)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function zScores(matrix, means, standardDeviations) {
    means = means || exports.mean(matrix);
    if (typeof (standardDeviations) === &#x27;undefined&#x27;) standardDeviations = exports.standardDeviation(matrix, true, means);
    return exports.standardize(exports.center(matrix, means, false), standardDeviations, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ml.nn" id="apidoc.module.ml.nn">module ml.nn</a></h1>


    <h2>
        <a href="#apidoc.element.ml.nn.FNN" id="apidoc.element.ml.nn.FNN">
        function <span class="apidocSignatureSpan">ml.nn.</span>FNN
        <span class="apidocSignatureSpan">(also known as epsilon)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class FeedForwardNeuralNetworks {

<span class="apidocCodeCommentSpan">    /**
     * Create a new Feedforword neural network model.
     * @param {object} options
     * @param {Array} [options.hiddenLayers=[10]] - Array that contains the sizes of the hidden layers.
     * @oaram {number} [options.iterations=50] - Number of iterations at the training step.
     * @param {number} [options.learningRate=0.01] - Learning rate of the neural net (also known as epsilon).
     * @poram {number} [options.regularization=0.01] - Regularization parameter af the neural net.
     * @poram {string} [options.activation=&#x27;tanh&#x27;] - activation function to be used. (options: &#x27;tanh&#x27;(default),
     * &#x27;identity&#x27;, &#x27;logistic&#x27;, &#x27;arctan&#x27;, &#x27;softsign&#x27;, &#x27;relu&#x27;, &#x27;softplus&#x27;, &#x27;bent&#x27;, &#x27;sinusoid&#x27;, &#x27;sinc&#x27;, &#x27;gaussian&#x27;).
     * (single-parametric options: &#x27;parametric-relu&#x27;, &#x27;exponential-relu&#x27;, &#x27;soft-exponential&#x27;).
     * @param {number} [options.activationParam=1] - if the selected activation function needs a parameter.
     */
</span>    constructor(options) {
        options = options || {};
        if (options.model) {
            // load network
            this.hiddenLayers = options.hiddenLayers;
            this.iterations = options.iterations;
            this.learningRate = options.learningRate;
            this.regularization = options.regularization;
            this.dicts = options.dicts;
            this.activation = options.activation;
            this.activationParam = options.activationParam;
            this.model = new Array(options.layers.length);

            for (var i = 0; i &#x3c; this.model.length - 1; ++i) {
                this.model[i] = Layer.load(options.layers[i]);
            }
            this.model[this.model.length - 1] = OutputLayer.load(options.layers[this.model.length - 1]);
        } else {
            // default constructor
            this.hiddenLayers = options.hiddenLayers === undefined ? [10] : options.hiddenLayers;
            this.iterations = options.iterations === undefined ? 50 : options.iterations;

            this.learningRate = options.learningRate === undefined ? 0.01 : options.learningRate;
            //this.momentum = options.momentum === undefined ? 0.1 : options.momentum;
            this.regularization = options.regularization === undefined ? 0.01 : options.regularization;

            this.activation = options.activation === undefined ? &#x27;tanh&#x27; : options.activation;
            this.activationParam = options.activationParam === undefined ? 1 : options.activationParam;
            if (!(this.activation in Object.keys(ACTIVATION_FUNCTIONS))) {
                this.activation = &#x27;tanh&#x27;;
            }
        }
    }

    /**
     * Function that build and initialize the neural net.
     * @param {number} inputSize - total of features to fit.
     * @param {number} outputSize - total of labels of the prediction set.
     */
    buildNetwork(inputSize, outputSize) {
        var size = 2 + (this.hiddenLayers.length - 1);
        this.model = new Array(size);

        // input layer
        this.model[0] = new Layer({
            inputSize: inputSize,
            outputSize: this.hiddenLayers[0],
            activation: this.activation,
            activationParam: this.activationParam,
            regularization: this.regularization,
            epsilon: this.learningRate
        });

        // hidden layers
        for (var i = 1; i &#x3c; this.hiddenLayers.length; ++i) {
            this.model[i] = new Layer({
                inputSize: this.hiddenLayers[i - 1],
                outputSize: this.hiddenLayers[i],
                activation: this.activation,
                activationParam: this.activationParam,
                regularization: this.regularization,
                epsilon: this.learningRate
            });
        }

        // output layer
        this.model[size - 1] = new OutputLayer({
            inputSize: this.hiddenLayers[this.hiddenLayers.length - 1],
            outputSize: outputSize,
            activation: this.activation,
            activationParam: this.activationParam,
            regularization: this.regularization, ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.nn.SOM" id="apidoc.element.ml.nn.SOM">
        function <span class="apidocSignatureSpan">ml.nn.</span>SOM
        <span class="apidocSignatureSpan">(x, y, options, reload)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SOM(x, y, options, reload) {

    this.x = x;
    this.y = y;

    options = options || {};
    this.options = {};
    for (var i in defaultOptions) {
        if (options.hasOwnProperty(i)) {
            this.options[i] = options[i];
        } else {
            this.options[i] = defaultOptions[i];
        }
    }

    if (typeof this.options.fields === &#x27;number&#x27;) {
        this.numWeights = this.options.fields;
    } else if (Array.isArray(this.options.fields)) {
        this.numWeights = this.options.fields.length;
        var converters = getConverters(this.options.fields);
        this.extractor = converters.extractor;
        this.creator = converters.creator;
    } else {
        throw new Error(&#x27;Invalid fields definition&#x27;);
    }

    if (this.options.gridType === &#x27;rect&#x27;) {
        this.nodeType = NodeSquare;
        this.gridDim = {
            x: x,
            y: y
        };
    } else {
        this.nodeType = NodeHexagonal;
        var hx = this.x - Math.floor(this.y / 2);
        this.gridDim = {
            x: hx,
            y: this.y,
            z: -(0 - hx - this.y)
        };
    }

    this.torus = this.options.torus;
    this.distanceMethod = this.torus ? &#x27;getDistanceTorus&#x27; : &#x27;getDistance&#x27;;

    this.distance = this.options.distance;

    this.maxDistance = getMaxDistance(this.distance, this.numWeights);

    if (reload === true) { // For model loading
        this.done = true;
        return;
    }
    if (!(x &#x3e; 0 &#x26;&#x26; y &#x3e; 0)) {
        throw new Error(&#x27;x and y must be positive&#x27;);
    }

    this.times = {
        findBMU: 0,
        adjust: 0
    };

    this.randomizer = this.options.randomizer;

    this.iterationCount = 0;
    this.iterations = this.options.iterations;

    this.startLearningRate = this.learningRate = this.options.learningRate;

    this.mapRadius = Math.floor(Math.max(x, y) / 2);

    this.algorithmMethod = this.options.method;

    this._initNodes();

    this.done = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ml.nn.SOM" id="apidoc.module.ml.nn.SOM">module ml.nn.SOM</a></h1>


    <h2>
        <a href="#apidoc.element.ml.nn.SOM.SOM" id="apidoc.element.ml.nn.SOM.SOM">
        function <span class="apidocSignatureSpan">ml.nn.</span>SOM
        <span class="apidocSignatureSpan">(x, y, options, reload)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SOM(x, y, options, reload) {

    this.x = x;
    this.y = y;

    options = options || {};
    this.options = {};
    for (var i in defaultOptions) {
        if (options.hasOwnProperty(i)) {
            this.options[i] = options[i];
        } else {
            this.options[i] = defaultOptions[i];
        }
    }

    if (typeof this.options.fields === &#x27;number&#x27;) {
        this.numWeights = this.options.fields;
    } else if (Array.isArray(this.options.fields)) {
        this.numWeights = this.options.fields.length;
        var converters = getConverters(this.options.fields);
        this.extractor = converters.extractor;
        this.creator = converters.creator;
    } else {
        throw new Error(&#x27;Invalid fields definition&#x27;);
    }

    if (this.options.gridType === &#x27;rect&#x27;) {
        this.nodeType = NodeSquare;
        this.gridDim = {
            x: x,
            y: y
        };
    } else {
        this.nodeType = NodeHexagonal;
        var hx = this.x - Math.floor(this.y / 2);
        this.gridDim = {
            x: hx,
            y: this.y,
            z: -(0 - hx - this.y)
        };
    }

    this.torus = this.options.torus;
    this.distanceMethod = this.torus ? &#x27;getDistanceTorus&#x27; : &#x27;getDistance&#x27;;

    this.distance = this.options.distance;

    this.maxDistance = getMaxDistance(this.distance, this.numWeights);

    if (reload === true) { // For model loading
        this.done = true;
        return;
    }
    if (!(x &#x3e; 0 &#x26;&#x26; y &#x3e; 0)) {
        throw new Error(&#x27;x and y must be positive&#x27;);
    }

    this.times = {
        findBMU: 0,
        adjust: 0
    };

    this.randomizer = this.options.randomizer;

    this.iterationCount = 0;
    this.iterations = this.options.iterations;

    this.startLearningRate = this.learningRate = this.options.learningRate;

    this.mapRadius = Math.floor(Math.max(x, y) / 2);

    this.algorithmMethod = this.options.method;

    this._initNodes();

    this.done = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.nn.SOM.load" id="apidoc.element.ml.nn.SOM.load">
        function <span class="apidocSignatureSpan">ml.nn.SOM.</span>load
        <span class="apidocSignatureSpan">(model, distance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function loadModel(model, distance) {
    if (model.name === &#x27;SOM&#x27;) {
        var x = model.data.length,
            y = model.data[0].length;
        if (distance) {
            model.options.distance = distance;
        } else if (model.options.distance) {
            model.options.distance = eval(&#x27;(&#x27; + model.options.distance + &#x27;)&#x27;);
        }
        var som = new SOM(x, y, model.options, true);
        som.nodes = new Array(x);
        for (var i = 0; i &#x3c; x; i++) {
            som.nodes[i] = new Array(y);
            for (var j = 0; j &#x3c; y; j++) {
                som.nodes[i][j] = new som.nodeType(i, j, model.data[i][j], som);
            }
        }
        return som;
    } else {
        throw new Error(&#x27;expecting a SOM model&#x27;);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ml.nn.SOM.prototype" id="apidoc.module.ml.nn.SOM.prototype">module ml.nn.SOM.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.ml.nn.SOM.prototype._adjust" id="apidoc.element.ml.nn.SOM.prototype._adjust">
        function <span class="apidocSignatureSpan">ml.nn.SOM.prototype.</span>_adjust
        <span class="apidocSignatureSpan">(trainingValue, neighbourhoodRadius)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function adjust(trainingValue, neighbourhoodRadius) {
    var now = Date.now(),
        x, y, dist, influence;

    var bmu = this._findBestMatchingUnit(trainingValue);

    var now2 = Date.now();
    this.times.findBMU += now2 - now;

    var radiusLimit = Math.floor(neighbourhoodRadius);
    var xMin = bmu.x - radiusLimit,
        xMax = bmu.x + radiusLimit,
        yMin = bmu.y - radiusLimit,
        yMax = bmu.y + radiusLimit;

    for (x = xMin; x &#x3c;= xMax; x++) {
        var theX = x;
        if (x &#x3c; 0) {
            theX += this.x;
        } else if (x &#x3e;= this.x) {
            theX -= this.x;
        }
        for (y = yMin; y &#x3c;= yMax; y++) {
            var theY = y;
            if (y &#x3c; 0) {
                theY += this.y;
            } else if (y &#x3e;= this.y) {
                theY -= this.y;
            }

            dist = bmu[this.distanceMethod](this.nodes[theX][theY]);

            if (dist &#x3c; neighbourhoodRadius) {
                influence = Math.exp(-dist / (2 * neighbourhoodRadius));
                this.nodes[theX][theY].adjustWeights(trainingValue, this.learningRate, influence);
            }

        }
    }

    this.times.adjust += (Date.now() - now2);

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.nn.SOM.prototype._findBestMatchingUnit" id="apidoc.element.ml.nn.SOM.prototype._findBestMatchingUnit">
        function <span class="apidocSignatureSpan">ml.nn.SOM.prototype.</span>_findBestMatchingUnit
        <span class="apidocSignatureSpan">(candidate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function findBestMatchingUnit(candidate) {

    var bmu,
        lowest = Infinity,
        dist;

    for (var i = 0; i &#x3c; this.x; i++) {
        for (var j = 0; j &#x3c; this.y; j++) {
            dist = this.distance(this.nodes[i][j].weights, candidate);
            if (dist &#x3c; lowest) {
                lowest = dist;
                bmu = this.nodes[i][j];
            }
        }
    }

    return bmu;

}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.nn.SOM.prototype._initNodes" id="apidoc.element.ml.nn.SOM.prototype._initNodes">
        function <span class="apidocSignatureSpan">ml.nn.SOM.prototype.</span>_initNodes
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function initNodes() {
    var now = Date.now(),
        i, j, k;
    this.nodes = new Array(this.x);
    for (i = 0; i &#x3c; this.x; i++) {
        this.nodes[i] = new Array(this.y);
        for (j = 0; j &#x3c; this.y; j++) {
            var weights = new Array(this.numWeights);
            for (k = 0; k &#x3c; this.numWeights; k++) {
                weights[k] = this.randomizer();
            }
            this.nodes[i][j] = new this.nodeType(i, j, weights, this);
        }
    }
    this.times.initNodes = Date.now() - now;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.nn.SOM.prototype._predict" id="apidoc.element.ml.nn.SOM.prototype._predict">
        function <span class="apidocSignatureSpan">ml.nn.SOM.prototype.</span>_predict
        <span class="apidocSignatureSpan">(element, computePosition)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _predict(element, computePosition) {
    if (!Array.isArray(element)) {
        element = this.extractor(element);
    }
    var bmu = this._findBestMatchingUnit(element);
    var result = [bmu.x, bmu.y];
    if (computePosition) {
        result[2] = bmu.getPosition(element);
    }
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.nn.SOM.prototype.export" id="apidoc.element.ml.nn.SOM.prototype.export">
        function <span class="apidocSignatureSpan">ml.nn.SOM.prototype.</span>export
        <span class="apidocSignatureSpan">(includeDistance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function exportModel(includeDistance) {
    if (!this.done) {
        throw new Error(&#x27;model is not ready yet&#x27;);
    }
    var model = {
        name: &#x27;SOM&#x27;
    };
    model.options = {
        fields: this.options.fields,
        gridType: this.options.gridType,
        torus: this.options.torus
    };
    model.data = new Array(this.x);
    for (var i = 0; i &#x3c; this.x; i++) {
        model.data[i] = new Array(this.y);
        for (var j = 0; j &#x3c; this.y; j++) {
            model.data[i][j] = this.nodes[i][j].weights;
        }
    }
    if (includeDistance) {
        model.options.distance = this.distance.toString();
    }
    return model;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.nn.SOM.prototype.getConvertedNodes" id="apidoc.element.ml.nn.SOM.prototype.getConvertedNodes">
        function <span class="apidocSignatureSpan">ml.nn.SOM.prototype.</span>getConvertedNodes
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getConvertedNodes() {
    var result = new Array(this.x);
    for (var i = 0; i &#x3c; this.x; i++) {
        result[i] = new Array(this.y);
        for (var j = 0; j &#x3c; this.y; j++) {
            var node = this.nodes[i][j];
            result[i][j] = this.creator ? this.creator(node.weights) : node.weights;
        }
    }
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.nn.SOM.prototype.getFit" id="apidoc.element.ml.nn.SOM.prototype.getFit">
        function <span class="apidocSignatureSpan">ml.nn.SOM.prototype.</span>getFit
        <span class="apidocSignatureSpan">(dataset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getFit(dataset) {
    if (!dataset) {
        dataset = this.trainingSet;
    }
    var l = dataset.length,
        bmu,
        result = new Array(l);
    for (var i = 0; i &#x3c; l; i++) {
        bmu = this._findBestMatchingUnit(dataset[i]);
        result[i] = Math.sqrt(this.distance(dataset[i], bmu.weights));
    }
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.nn.SOM.prototype.getQuantizationError" id="apidoc.element.ml.nn.SOM.prototype.getQuantizationError">
        function <span class="apidocSignatureSpan">ml.nn.SOM.prototype.</span>getQuantizationError
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getQuantizationError() {
    var fit = this.getFit(),
        l = fit.length,
        sum = 0;
    for (var i = 0; i &#x3c; l; i++) {
        sum += fit[i];
    }
    return sum / l;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.nn.SOM.prototype.predict" id="apidoc.element.ml.nn.SOM.prototype.predict">
        function <span class="apidocSignatureSpan">ml.nn.SOM.prototype.</span>predict
        <span class="apidocSignatureSpan">(data, computePosition)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function predict(data, computePosition) {
    if (typeof data === &#x27;boolean&#x27;) {
        computePosition = data;
        data = null;
    }
    if (!data) {
        data = this.trainingSet;
    }
    if (Array.isArray(data) &#x26;&#x26; (Array.isArray(data[0]) || (typeof data[0] === &#x27;object&#x27;))) { // predict a dataset
        var self = this;
        return data.map(function (element) {
            return self._predict(element, computePosition);
        });
    } else { // predict a single element
        return this._predict(data, computePosition);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.nn.SOM.prototype.setTraining" id="apidoc.element.ml.nn.SOM.prototype.setTraining">
        function <span class="apidocSignatureSpan">ml.nn.SOM.prototype.</span>setTraining
        <span class="apidocSignatureSpan">(trainingSet)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setTraining(trainingSet) {
    if (this.trainingSet) {
        throw new Error(&#x27;training set has already been set&#x27;);
    }
    var now = Date.now();
    var convertedSet = trainingSet;
    var i, l = trainingSet.length;
    if (this.extractor) {
        convertedSet = new Array(l);
        for (i = 0; i &#x3c; l; i++) {
            convertedSet[i] = this.extractor(trainingSet[i]);
        }
    }
    this.numIterations = this.iterations * l;

    if (this.algorithmMethod === &#x27;random&#x27;) {
        this.timeConstant = this.numIterations / Math.log(this.mapRadius);
    } else {
        this.timeConstant = l / Math.log(this.mapRadius);
    }
    this.trainingSet = convertedSet;
    this.times.setTraining = Date.now() - now;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.nn.SOM.prototype.train" id="apidoc.element.ml.nn.SOM.prototype.train">
        function <span class="apidocSignatureSpan">ml.nn.SOM.prototype.</span>train
        <span class="apidocSignatureSpan">(trainingSet)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function train(trainingSet) {
    if (!this.done) {
        this.setTraining(trainingSet);
        while (this.trainOne()) {
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.nn.SOM.prototype.trainOne" id="apidoc.element.ml.nn.SOM.prototype.trainOne">
        function <span class="apidocSignatureSpan">ml.nn.SOM.prototype.</span>trainOne
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function trainOne() {
    if (this.done) {

        return false;

    } else if (this.numIterations-- &#x3e; 0) {

        var neighbourhoodRadius,
            trainingValue,
            trainingSetFactor;

        if (this.algorithmMethod === &#x27;random&#x27;) { // Pick a random value of the training set at each step
            neighbourhoodRadius = this.mapRadius * Math.exp(-this.iterationCount / this.timeConstant);
            trainingValue = getRandomValue(this.trainingSet, this.randomizer);
            this._adjust(trainingValue, neighbourhoodRadius);
            this.learningRate = this.startLearningRate * Math.exp(-this.iterationCount / this.numIterations);
        } else { // Get next input vector
            trainingSetFactor = -Math.floor(this.iterationCount / this.trainingSet.length);
            neighbourhoodRadius = this.mapRadius * Math.exp(trainingSetFactor / this.timeConstant);
            trainingValue = this.trainingSet[this.iterationCount % this.trainingSet.length];
            this._adjust(trainingValue, neighbourhoodRadius);
            if (((this.iterationCount + 1) % this.trainingSet.length) === 0) {
                this.learningRate = this.startLearningRate * Math.exp(trainingSetFactor / Math.floor(this.numIterations / this.trainingSet
.length));
            }
        }

        this.iterationCount++;

        return true;

    } else {

        this.done = true;
        return false;

    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.ml.numSort" id="apidoc.module.ml.numSort">module ml.numSort</a></h1>


    <h2>
        <a href="#apidoc.element.ml.numSort.asc" id="apidoc.element.ml.numSort.asc">
        function <span class="apidocSignatureSpan">ml.numSort.</span>asc
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">asc = function (a, b) {
	assertNum(a);
	assertNum(b);
	return a - b;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.ml.numSort.desc" id="apidoc.element.ml.numSort.desc">
        function <span class="apidocSignatureSpan">ml.numSort.</span>desc
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">desc = function (a, b) {
	assertNum(a);
	assertNum(b);
	return b - a;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
